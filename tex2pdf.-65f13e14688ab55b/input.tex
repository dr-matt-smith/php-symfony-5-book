\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[a4paperpaper,openright]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

% Table of contents formatting
\renewcommand{\contentsname}{Table of Contents}
\setcounter{tocdepth}{3}

\setcounter{secnumdepth}{4}


% \renewcommand\thesection{\Roman{section}}

 
% Headers and page numbering 
\usepackage{fancyhdr}

\fancyhead{}
\fancyhead[R]{\leftmark}
\renewcommand{\headrulewidth}{0.4pt}

\fancyfoot[R]{\thepage}
\fancyfoot[C]{}
\fancyfoot[L]{\textit{An Introduction to Symfony 5 \copyright Matt Smith 2020}}
\renewcommand{\footrulewidth}{0.4pt}

\pagestyle{fancy}

% Fonts and typesetting
\setsansfont{Verdana}

% Set figure legends and captions to be smaller sized sans serif font
\usepackage[font={footnotesize,sf}]{caption}

\usepackage{siunitx}

% Adjust spacing between lines to 1.5
\usepackage{setspace}
\onehalfspacing
\raggedbottom

% Set margins
\usepackage[top=1.25in,bottom=1.25in]{geometry}

% Chapter styling
\usepackage[grey]{quotchap}
\makeatletter
\renewcommand*{\chapnumfont}{%
  \usefont{T1}{\@defaultcnfont}{b}{n}\fontsize{80}{100}\selectfont% Default: 100/130
  \color{chaptergrey}%
}
\makeatother

% Set colour of links to black so that they don't show up when printed
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=black}

% Tables
\usepackage{booktabs}
\usepackage{threeparttable}
\usepackage{array}
\newcolumntype{x}[1]{%
>{\centering\arraybackslash}m{#1}}%

% Allow for long captions and float captions on opposite page of figures 
\usepackage[rightFloats, CaptionBefore]{fltpage}

% Don't let floats cross subsections
\usepackage[section,subsection]{extraplaceins}

\date{}

\begin{document}

\begin{titlepage}
    \begin{center}
    
        \vspace*{1cm}
        

       \large{ \textbf{ \uppercase{An Introduction to Symfony 5}\\(for people that already know OO-PHP and some MVC stuff)}}
        
        \vspace{1.5cm}

        by\\
        \textbf{
        Matt Smith, Ph.D.\\https://github.com/dr-matt-smith
        }

       

        
        
        \vfill
  
            \copyright ~ 2020

     \end{center}
    \thispagestyle{empty}
\end{titlepage}

\newpage
\thispagestyle{empty}
\mbox{}

\frontmatter

\chapter{Acknowledgements}

Thanks to \ldots{} \tableofcontents

\mainmatter

\part{Introduction to Symfony}

\hypertarget{introduction}{%
\chapter{Introduction}\label{introduction}}

\hypertarget{what-is-symfony-5}{%
\section{What is Symfony 5?}\label{what-is-symfony-5}}

It's a PHP `framework' that does loads for you, if you're writing a
secure, database-drive web application.

\hypertarget{what-to-i-need-on-my-computer-to-get-started}{%
\section{What to I need on my computer to get
started?}\label{what-to-i-need-on-my-computer-to-get-started}}

I recommend you install the following:

\begin{itemize}
\tightlist
\item
  PHP 7 (download/install from \href{https://php.net/}{php.net})
\item
  a good text editor (I like
  \href{https://www.jetbrains.com/phpstorm/specials/phpstorm/phpstorm.html?\&gclid=CJTK_8SDrtICFWq-7Qodh98NpQ\&gclsrc=aw.ds.ds\&dclid=CNPY28WDrtICFQGn7QodqekBWg}{PHPStorm},
  but then it's free for educational users\ldots{})
\item
  \href{https://getcomposer.org/}{Composer} (PHP package manager - a PHP
  program)
\end{itemize}

The following are also a good idea: - a MySQL database server -
e.g.~MySQLWorkbench Community is free and cross-platform - Git - see
\href{https://git-scm.com/download/win}{GitforWindows} - the
\href{https://symfony.com/download}{Symfony} command line tool

or \ldots{} you could use something like
\href{https://c9.io/dr_matt_smith}{Cloud9}, web-based IDE. You can get
started on the free version and work from there \ldots{}

Learn more about the software needed for Symfony developmnent in
Appendix \ref{appendix_software}. For steps in installing PHP and the
other software, see Appendices \ref{appendix_php} and
\ref{appendix_software_setup}.

\hypertarget{how-to-i-get-started-with-a-new-symfony-project}{%
\section{How to I get started with a new Symfony
project}\label{how-to-i-get-started-with-a-new-symfony-project}}

In a CLI (Command Line Interface) terminal window, \texttt{cd} into the
directory where you want to create your Symfony project(s). Then create
a new Symfony empty web application project, named \texttt{project01}
(or whatever you wish) by typing:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{symfony}\NormalTok{ new --full project01}
\end{Highlighting}
\end{Shaded}

NOTE: If for some reason you don't have the Symfony command line tool
installed, you can also create a project using Composer:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ create-project symfony/website-skeleton project01}
\end{Highlighting}
\end{Shaded}

You should see the following, if all is going well:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ }\ExtensionTok{symfony}\NormalTok{ new --full project01}
\ExtensionTok{*}\NormalTok{ Creating a new Symfony project with Composer}
  \KeywordTok{(}\ExtensionTok{running}\NormalTok{ /usr/local/bin/composer create-project symfony/website-skeleton /Users/matt/project01}\KeywordTok{)}

\ExtensionTok{*}\NormalTok{ Setting up the project under Git version control}
  \KeywordTok{(}\ExtensionTok{running}\NormalTok{ git init /Users/matt/project01}\KeywordTok{)}
                                                                                                                        
\NormalTok{ [}\ExtensionTok{OK}\NormalTok{] Your project is now ready in /Users/matt/project01    }
\end{Highlighting}
\end{Shaded}

NOTE: - If the first line does not show a Symfony version starting with
\texttt{v4} then you may have an old version of PHP installed. You need
PHP 7.2.5 minimum to run Symfony 5.

Another way to get going quickly with Symfomy is to download one of the
projects accompanying this book \ldots{}

\hypertarget{where-are-the-projects-accompanying-this-book}{%
\section{Where are the projects accompanying this
book?}\label{where-are-the-projects-accompanying-this-book}}

All the projects in this book are freely available, as public
repositories on Github as follows:

\begin{itemize}
\tightlist
\item
  \url{https://github.com/dr-matt-smith/php-symfony5-book-codes}
\end{itemize}

To retrieve and setup a sample project follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  download the project to your local computer
  (e.g.~\texttt{git\ clone\ URL})
\item
  change (\texttt{cd}) into the created directory
\item
  type \texttt{composer\ install} to download any required 3rd-party
  packages into a \texttt{/vendor} folder

  \begin{itemize}
  \tightlist
  \item
    NOTE: \texttt{composer\ install} installs the \textbf{same}
    component versions as defined in the \texttt{composer.lock} file.
    \texttt{composer\ update} will attempt to install the \textbf{most
    up to date stable} versions of the components in the
    \texttt{composer.json} file.
  \end{itemize}
\item
  Then run your web server (see below) and explore via a web browser
\end{enumerate}

\hypertarget{how-to-i-run-a-symfony-webapp}{%
\section{How to I run a Symfony
webapp?}\label{how-to-i-run-a-symfony-webapp}}

\hypertarget{from-the-cli}{%
\subsection{From the CLI}\label{from-the-cli}}

At the CLI (command line terminal) ensure you are at the base level of
your project (i.e.~the same directory that has your
\texttt{composer.json} file), and type the following to run

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{symfony}\NormalTok{ serve}
\end{Highlighting}
\end{Shaded}

If you don't have the Symfony command line tool installed you could also
use the PHP built-in web server:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ -S localhost:8000 -t public}
\end{Highlighting}
\end{Shaded}

Then open a web browser and visit the website root at
\texttt{http://localhost:8000}.

See Figure \ref{default_home_page} for a screenshot of the default
Symfony 5 home page (with a message saying you've not configured a home
page!).

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/271098101c6e08a7fad30eb75ff110e370abc4c2.png}
\caption{Screenshot default Symfony 4 home page.
\label{default_home_page}}
\end{figure}

\hypertarget{from-a-webserver-application-like-apache-or-xampp}{%
\subsection{From a Webserver application (like Apache or
XAMPP)}\label{from-a-webserver-application-like-apache-or-xampp}}

If you are running a webserver (or combined web and database server like
XAMPP or Laragon), then point your web server root to the project's
\texttt{/public} folder - this is where public files go in Symfony
projects.

\hypertarget{it-isnt-working-problem-solving}{%
\section{It isn't working! (Problem
Solving)}\label{it-isnt-working-problem-solving}}

If you have trouble with running Symfony, take a look at Appendix
\ref{appendix_problem_solving}, which lists some common issues and how
to solve them.

\hypertarget{can-i-see-a-demo-project-with-lots-of-symfony-features}{%
\section{Can I see a demo project with lots of Symfony
features?}\label{can-i-see-a-demo-project-with-lots-of-symfony-features}}

Yes! There is a full-featured Symfony demo project. Checkout Appendix
\ref{appendix_sf_demo} for details of downloading and running the demo
and its associated automated tests.

\hypertarget{any-free-videos-about-sf5-to-get-me-going}{%
\section{Any free videos about SF5 to get me
going?}\label{any-free-videos-about-sf5-to-get-me-going}}

Yes! Those nice people at Symfonycasts have released a bunch of free
videos all about Symfony 5 (and OO PHP in general).

So plug in your headphones and watch them, or read the transcripts below
the video if you're no headphones. A good rule is to watch a video or
two \textbf{before} trying it out yourself.

You'll find the video tutorials at:

\begin{itemize}
\tightlist
\item
  \url{https://symfonycasts.com/tracks/symfony}
\end{itemize}

(ask Matt to ask his contacts in Symfonycasts to try to get his students
a month's free access \ldots{})

\hypertarget{first-steps}{%
\chapter{First steps}\label{first-steps}}

\hypertarget{what-well-make-basic01}{%
\section{\texorpdfstring{What we'll make
(\texttt{basic01})}{What we'll make (basic01)}}\label{what-well-make-basic01}}

See Figure \ref{new_home_page} for a screenshot of the new homepage
we'll create in our first project (after some setup steps).

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/9fd62910f505d54b27171036acbf12dafc5b8057.png}
\caption{New home page.\label{new_home_page}}
\end{figure}

There are 3 things Symfony needs to serve up a page:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  a route
\item
  a controller class and method
\item
  a Response object to be returned to the web client
\end{enumerate}

The first 2 can be combined, through the use of `Annotation' comments,
which declare the route in a comment immediately before the controller
method defining the `action' for that route. See this example:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/",}\CommentTok{ name="homepage")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ indexAction}\OtherTok{()}
\NormalTok{    \{}
        \StringTok{...}\NormalTok{ build }\KeywordTok{and} \KeywordTok{return}\NormalTok{ Response }\KeywordTok{object}\NormalTok{ here }\StringTok{...}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

For example the code below defines:

\begin{itemize}
\item
  an annotation Route comment for URL pattern \texttt{/} (i.e.~website
  route)

  -- \texttt{@Route("/",\ name="homepage")}

  -- the Symfony ``router'' system attempts to match pattern \texttt{/}
  in the URL of the HTTP Request received by the server
\item
  controller method \texttt{indexAction()}

  -- this method will be involved if the route matches

  -- controller method have the responsibility to create and return a
  Symfony \texttt{Response} object
\item
  note, Symfony allows us to declare an internal name for each route (in
  the example above \texttt{homepage})

  -- we can use the internal name when generating URLs for links in out
  templating system

  -- the advantage is that the route is only defined once (in the
  annotation comment), so if the route changes, it only needs to be
  changed in one place, and all references to the internal route name
  will automatically use the updated route

  -- for example, if this homepage route was changed from \texttt{/} to
  \texttt{/default} all URls generated using the \texttt{homepage}
  internal name would now generated \texttt{/default}
\end{itemize}

\hypertarget{create-a-new-symfony-project}{%
\section{Create a new Symfony
project}\label{create-a-new-symfony-project}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create new Symfony project (and then \texttt{cd} into it):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{symfony}\NormalTok{ new --full basic01}
    \ExtensionTok{Installing}\NormalTok{ symfony/skeleton (v4.0.5)}
      \ExtensionTok{-}\NormalTok{ Installing symfony/skeleton (v4.0.5)}\BuiltInTok{:}\NormalTok{ Loading from cache}

    \ExtensionTok{...}\NormalTok{ etc. ...}

\NormalTok{    $ }\BuiltInTok{cd}\NormalTok{ basic01}
\end{Highlighting}
\end{Shaded}
\item
  Check this vanilla, empty project is all fine by running the web sever
  and visit website root at \texttt{http://localhost:8000/}:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{symfony}\NormalTok{ serve}
\NormalTok{     [}\ExtensionTok{OK}\NormalTok{] Server listening on http://127.0.0.1:8000}
     \ExtensionTok{//}\NormalTok{ Quit the server with CONTROL-C.}
\end{Highlighting}
\end{Shaded}

Figure \ref{default_page} shows a screenshot of the default page for the
web root (path \texttt{/}), when we have no routes set up and we are in
development mode (i.e.~our \texttt{.env} file contains
\texttt{APP\_ENV=dev}).

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/271098101c6e08a7fad30eb75ff110e370abc4c2.png}
\caption{Screenshot default Symfony 4 page for web root (when no routes
defined). \label{default_page}}
\end{figure}

\hypertarget{list-the-routes}{%
\section{List the routes}\label{list-the-routes}}

There should not be any (non-debug) routes yet. All routes starting with
an underscore \texttt{\_} symbol are debugging routes used by the verye
useful Symfony profiler - this creates the information footer at the
bottom of our pages when we are developing Symfony applications.

but let's check at the console by typing
\texttt{php\ bin/console\ debug:router}:

\begin{verbatim}
    $ php bin/console debug:router
         -------------------------- -------- -------- ------ ----------------------------------- 
          Name                       Method   Scheme   Host   Path                               
         -------------------------- -------- -------- ------ ----------------------------------- 
          _preview_error             ANY      ANY      ANY    /_error/{code}.{_format}           
          _wdt                       ANY      ANY      ANY    /_wdt/{token}                      
          _profiler_home             ANY      ANY      ANY    /_profiler/                        
          _profiler_search           ANY      ANY      ANY    /_profiler/search                  
          _profiler_search_bar       ANY      ANY      ANY    /_profiler/search_bar              
          _profiler_phpinfo          ANY      ANY      ANY    /_profiler/phpinfo                 
          _profiler_search_results   ANY      ANY      ANY    /_profiler/{token}/search/results  
          _profiler_open_file        ANY      ANY      ANY    /_profiler/open                    
          _profiler                  ANY      ANY      ANY    /_profiler/{token}                 
          _profiler_router           ANY      ANY      ANY    /_profiler/{token}/router          
          _profiler_exception        ANY      ANY      ANY    /_profiler/{token}/exception       
          _profiler_exception_css    ANY      ANY      ANY    /_profiler/{token}/exception.css   
         -------------------------- -------- -------- ------ ----------------------------------- 
\end{verbatim}

The only routes we can see all start with an underscore
(e.g.~\texttt{\_preview\_error}), so no application routes have been
declared yet \ldots{}

\hypertarget{create-a-controller}{%
\section{Create a controller}\label{create-a-controller}}

We could write a new class for our homepage controller, but \ldots{}
let's ask Symfony to make it for us. Typical pages seen by non-logged-in
users like the home page, about page, contact details etc. are often
referred to as `default' pages, and so we'll name the controller class
for these pages our \texttt{DefaultController}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Tell Symfony to create a new homepage (default) controller:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:controller Default}

         \ExtensionTok{created}\NormalTok{: src/Controller/DefaultController.php}
         \ExtensionTok{created}\NormalTok{: templates/default/index.html.twig}
        
          \ExtensionTok{Success}\NormalTok{! }
        
         \ExtensionTok{Next}\NormalTok{: Open your new controller class and add some pages!}
\end{Highlighting}
\end{Shaded}

Symfony controller classes are stored in directory
\texttt{/src/Controller}. We can see that a new controller class has
been created named \texttt{DefaultController.php} in folder
\texttt{/src/Controller}.

A second file was also created, a view template file
\texttt{templates/default/index.html.twig},

Look inside the generated class
\texttt{/src/Controller/DefaultController.php}. It should look something
like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php    }
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Controller}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Bundle\textbackslash{}FrameworkBundle\textbackslash{}Controller\textbackslash{}AbstractController}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Routing\textbackslash{}Annotation\textbackslash{}Route}\OtherTok{;}
    
    \KeywordTok{class}\NormalTok{ DefaultController }\KeywordTok{extends}\NormalTok{ AbstractController}
\NormalTok{    \{}
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/default",}\CommentTok{ name="default")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\StringTok{'default/index.html.twig'}\OtherTok{,} \OtherTok{[}
                \StringTok{'controller_name'}\NormalTok{ => }\StringTok{'DefaultController'}\OtherTok{,}
            \OtherTok{]);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

This default controller uses a \textbf{Twig} template to return an HTML
page.

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{\{}
        \DataTypeTok{"message"}\FunctionTok{:}\StringTok{"Welcome to your new controller!"}\FunctionTok{,}
        \DataTypeTok{"path"}\FunctionTok{:}\StringTok{"src}\CharTok{\textbackslash{}/}\StringTok{Controller}\CharTok{\textbackslash{}/}\StringTok{DefaultController.php"}\FunctionTok{,}
    \FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

Let's `make this our own' by changing the contents of the Response
returned to a simple text response. Do the following:

\begin{itemize}
\item
  comment-out the body of the \texttt{index()} method
\item
  at the top of the class add a \texttt{use} statement, so we can make
  use of the Symfony HTTFoundation class \texttt{Response}

  \texttt{use\ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Response;}
\item
  write a new body for the \texttt{index()} method to output a simple
  text message response:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{return} \KeywordTok{new}\NormalTok{ Response}\OtherTok{(}\StringTok{'Welcome to your new controller!'}\OtherTok{);}
\end{Highlighting}
\end{Shaded}
\end{itemize}

So the listing of your \texttt{DefaultController} should look as
follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<?php}
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Controller}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Bundle\textbackslash{}FrameworkBundle\textbackslash{}Controller\textbackslash{}AbstractController}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Routing\textbackslash{}Annotation\textbackslash{}Route}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Response}\OtherTok{;}
    
    \KeywordTok{class}\NormalTok{ DefaultController }\KeywordTok{extends}\NormalTok{ AbstractController}
\NormalTok{    \{}
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/default",}\CommentTok{ name="default")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{return} \KeywordTok{new}\NormalTok{ Response}\OtherTok{(}\StringTok{'Welcome to your new controller!'}\OtherTok{);}
    \CommentTok{//        return $this->render('default/index.html.twig', [}
    \CommentTok{//            'controller_name' => 'DefaultController',}
    \CommentTok{//        ]);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{run-web-server-to-visit-new-default-route}{%
\section{Run web server to visit new default
route}\label{run-web-server-to-visit-new-default-route}}

Run the web sever and visit the home page at
\texttt{http://localhost:8000/}.

But we see that default Symfony welcome page, not our custom response
text message!

Since we \textbf{have} defined a route, we don't get the default page
any more. However, since we named our controller \texttt{Default}, then
this is the route that was defined for it:

\begin{Shaded}
\begin{Highlighting}[]
  \ExtensionTok{Name}\NormalTok{                       Method   Scheme   Host   Path}
 \ExtensionTok{--------------------------}\NormalTok{ -------- -------- ------ -----------------------------------}
  \ExtensionTok{_...}\NormalTok{(all those debug routes starting with _ )}
  \ExtensionTok{default}\NormalTok{                    ANY      ANY      ANY    /default}
\end{Highlighting}
\end{Shaded}

If we look more closely at the generated code, we can see this route
\texttt{/default} in the \textbf{annotation} comment preceding
controller method \texttt{index()} in
\texttt{src/Controllers/DefaultController.php}

\begin{Shaded}
\begin{Highlighting}[]
    \ErrorTok{@}\NormalTok{Route}\OtherTok{(}\StringTok{"/default"}\OtherTok{,}\NormalTok{ name=}\StringTok{"default"}\OtherTok{)}
\end{Highlighting}
\end{Shaded}

So visit \texttt{http://localhost:8000/default} instead, to see the page
generated by our \texttt{DefaultController-\textgreater{}index()}
method.

Figure \ref{generated_default} shows a screenshot of the message created
from our generated default controller method.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/1ed3d02a50a2750e79c73555fde09e2b4117bd0f.png}
\caption{Screenshot of generated page for URL path \texttt{/default}.
\label{generated_default}}
\end{figure}

\hypertarget{other-types-of-response-content}{%
\section{Other types of Response
content}\label{other-types-of-response-content}}

We could also have asked our Controller function to return JSON rather
than text. We can create JSON either using Twig, or with the inherited
\texttt{-\textgreater{}json(...)} method. For example, try replacing the
body of your \texttt{index()} method with the following:

\begin{Shaded}
\begin{Highlighting}[]
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->json}\OtherTok{([}
                \StringTok{'name'}\NormalTok{ => }\StringTok{'matt'}\OtherTok{,}
                \StringTok{'age'}\NormalTok{ => }\StringTok{'21 again!'}\OtherTok{,}
            \OtherTok{]);}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-default-twig-page}{%
\section{The default Twig page}\label{the-default-twig-page}}

If we return our \texttt{index()} method back to what was first
automatically generated for us, we can see an HTML page in our browser
that is output from the Twig template:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\StringTok{'default/index.html.twig'}\OtherTok{,} \OtherTok{[}
            \StringTok{'controller_name'}\NormalTok{ => }\StringTok{'DefaultController'}\OtherTok{,}
        \OtherTok{]);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Figure \ref{generated_twig_default} shows a screenshot of the Twig HTML
page that was automatically generated.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/4e20ebf6b80bf441fbc12d17c09ac3680e146cf1.png}
\caption{Screenshot of generated Twig page for URL path
\texttt{/default}. \label{generated_twig_default}}
\end{figure}

\hypertarget{twig-templating}{%
\chapter{Twig templating}\label{twig-templating}}

\hypertarget{customizing-the-twig-output-basic02}{%
\section{\texorpdfstring{Customizing the Twig output
(\texttt{basic02})}{Customizing the Twig output (basic02)}}\label{customizing-the-twig-output-basic02}}

Look at the generated code for the \texttt{index()} method of class
\texttt{DefaultController}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Controller}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Bundle\textbackslash{}FrameworkBundle\textbackslash{}Controller\textbackslash{}AbstractController}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Routing\textbackslash{}Annotation\textbackslash{}Route}\OtherTok{;}
    
    \KeywordTok{class}\NormalTok{ DefaultController }\KeywordTok{extends}\NormalTok{ AbstractController}
\NormalTok{    \{}
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/default",}\CommentTok{ name="default")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\StringTok{'default/index.html.twig'}\OtherTok{,} \OtherTok{[}
                \StringTok{'controller_name'}\NormalTok{ => }\StringTok{'DefaultController'}\OtherTok{,}
            \OtherTok{]);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

As you can see, the controller method now returns the output of method
\texttt{\$this-\textgreater{}render(...)} rather than directly creating
a \texttt{Response} object. With the Twig bundle added, each controller
class now has access to the Twig \texttt{render(...)} method.

Figure \ref{generated_default_twig} shows a screenshot of the message
created from our generated default controller method with Twig.

NOTE: The actual look of the default generated Twig content may be a
little different (e.g.~19 Feb 2019 it now says
\texttt{Hello\ DefaultController!})\ldots{}

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/4e20ebf6b80bf441fbc12d17c09ac3680e146cf1.png}
\caption{Screenshot of generated page for URL path \texttt{/default}.
\label{generated_default_twig}}
\end{figure}

\hypertarget{specific-url-path-and-internal-name-for-our-default-route-method}{%
\section{Specific URL path and internal name for our default route
method}\label{specific-url-path-and-internal-name-for-our-default-route-method}}

Let's change the URL path to the website root (\texttt{/}) and name the
route \texttt{homepage} by editing the annotation comments preceding
method \texttt{index()} in
\texttt{src/Controllers/DefaultController.php}.

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{class}\NormalTok{ DefaultController }\KeywordTok{extends}\NormalTok{ Controller}
\NormalTok{    \{}
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/",}\CommentTok{ name="homepage")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{()}
\end{Highlighting}
\end{Shaded}

Now the route is:

\begin{Shaded}
\begin{Highlighting}[]
  \ExtensionTok{Name}\NormalTok{                       Method   Scheme   Host   Path}
 \ExtensionTok{--------------------------}\NormalTok{ -------- -------- ------ -----------------------------------}
  \ExtensionTok{homepage}\NormalTok{                   ANY      ANY      ANY    /}
\end{Highlighting}
\end{Shaded}

Finally, let's replace that default message with an HTTP response that
\textbf{we} have created - how about the message \texttt{hello\ there!}.
We can generate an HTTP response by creating an instance of the
\texttt{Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Response}
class.

Luckily, if we are using a PHP-friendly editor like PHPStorm, as we
start to type the name of a class, the IDE will popup a suggestion of
namespaced classes to choose from. Figure \ref{phpstorm_response} shows
a screenshot of PHPStorm offering up a list of suggested classes after
we have typed the letters \texttt{new\ Re}. If we accept a suggested
class from PHPStorm, then an appropriate \texttt{use} statement will be
inserted before the class declaration for us.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/99d1c7b61646671719a4ba00450a74787e31b522.png}
\caption{Screenshot of PHPStorm IDE suggesting namespaces classes.
\label{phpstorm_response}}
\end{figure}

Here is a complete \texttt{DefaultController} class:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Controller}\OtherTok{;}

    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Routing\textbackslash{}Annotation\textbackslash{}Route}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Bundle\textbackslash{}FrameworkBundle\textbackslash{}Controller\textbackslash{}AbstractController}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Response}\OtherTok{;}

    \KeywordTok{class}\NormalTok{ DefaultController }\KeywordTok{extends}\NormalTok{ AbstractController}
\NormalTok{    \{}
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/",}\CommentTok{ name="homepage")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ indexAction}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{return} \KeywordTok{new}\NormalTok{ Response}\OtherTok{(}\StringTok{'Hello there!'}\OtherTok{);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Figure \ref{hello_there} shows a screenshot of the message created from
our \texttt{Response()} object.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/4372c0edcc841710e99167f5f25657ffd5c0aaef.png}
\caption{Screenshot of page seen for
\texttt{new\ Response(\textquotesingle{}hello\ there!\textquotesingle{})}.
\label{hello_there}}
\end{figure}

\hypertarget{clearing-the-cache}{%
\section{Clearing the cache}\label{clearing-the-cache}}

Sometimes, when we've added a new route, we still get an error saying
the route was not found, or showing us out-of-date content. This can be
a problem of the Symfony \textbf{cache}.

So clearing the cache is a good way to resolve this problem (you may get
in the habit of clearing the cache each time you add/change any routes).

You can clear the cache in 2 ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Simply delete directory \texttt{/var/cache}
\item
  Use the CLI command to clear the cache:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console cache:clear}

    \ExtensionTok{//}\NormalTok{ Clearing the cache for the dev environment with debug true                                                          }
\NormalTok{    [}\ExtensionTok{OK}\NormalTok{] Cache for the }\StringTok{"dev"}\NormalTok{ environment (debug=true) }\ExtensionTok{was}\NormalTok{ successfully cleared.   }

\NormalTok{    $}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{lets-create-a-nice-twig-hom-page}{%
\section{Let's create a nice Twig hom
page}\label{lets-create-a-nice-twig-hom-page}}

We are (soon) going to create Twig template in
\texttt{templates/default/homepage.html.twig}. So we need to ask the
\texttt{Twig} object in our Symfony project to create an HTTP response
via its \texttt{render()} method. Part of the `magic' of PHP
Object-Orienteted inheritance (and the \textbf{Dependancy Injection}
design pattern), is that since our controller class is a subclass of
\texttt{Symfony\textbackslash{}Bundle\textbackslash{}FrameworkBundle\textbackslash{}Controller\textbackslash{}Controller},
then objects of our controller automatically have access to a
\texttt{render(...)} method for an automatically generated Twig object.

In a nutshell, to output an HTTP response generated from Twig, we just
have to specify the Twig template name, and relative location\footnote{The
  `root' of Twig template locations is, by default, \texttt{/templates}.
  To keep files well-organised, we should create subdirectories for
  related pages. For example, if there is a Twig template
  \texttt{/templates/admin/loginForm.html.twig}, then we would need to
  refer to its location (relative to \texttt{/templates}) as
  \texttt{admin/loginForm.html.twig}. }, and supply an array of any
parameters we want to pass to the template.

So we can simply write the following to ask Symfony to generate an HTTP
response from Twig's text output from rendering the template that can
(will soon!) be found in \texttt{/tempaltes/default/homepage.html.twig}:

\begin{Shaded}
\begin{Highlighting}[]
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/",}\CommentTok{ name="homepage")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ indexAction}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{$template}\NormalTok{ = }\StringTok{'default/index.html.twig'}\OtherTok{;}
            \KeywordTok{$args}\NormalTok{ = }\OtherTok{[];}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}

Now let's put our own personal content in that Twig template in
\texttt{/templates/default/homepage.html.twig}!

\begin{itemize}
\item
  Replace the contents of file \texttt{index.html.twig} with the
  following:

\begin{verbatim}
    {% extends 'base.html.twig' %}

    {% block body %}
        <h1>Home page</h1>

        <p>
            welcome to the home page
        </p>
    {% endblock %}
\end{verbatim}
\end{itemize}

Note that Twig paths searches from the Twig root location of
\texttt{/templates}, not from the location of the file doing the
inheriting, so do \textbf{NOT} write
\texttt{\{\%\ extends\ \textquotesingle{}default/base.html.twig\textquotesingle{}\ \%\}}\ldots{}

Figure \ref{twig_page} shows a screenshot our Twig-generated page in the
web browser.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/9fd62910f505d54b27171036acbf12dafc5b8057.png}
\caption{Screenshot of page from our Twig template. \label{twig_page}}
\end{figure}

\hypertarget{creating-our-own-classes}{%
\chapter{Creating our own classes}\label{creating-our-own-classes}}

\hypertarget{goals}{%
\section{Goals}\label{goals}}

Our goals are to:

\begin{itemize}
\tightlist
\item
  create a simple Student entity class (by hand - not using the
  \textbf{make} tool)
\item
  create a route / controller / template to show one student on a web
  page
\item
  create a repository class, to manage an array of Student objects
\item
  create a route / controller / template to list all students as a web
  page
\item
  create a route / controller / template to show one student on a web
  page for a given Id
\end{itemize}

\hypertarget{lets-create-an-entity-student-basic03}{%
\section{\texorpdfstring{Let's create an Entity \texttt{Student}
(\texttt{basic03})}{Let's create an Entity Student (basic03)}}\label{lets-create-an-entity-student-basic03}}

Entity classes are declared as PHP classes in \texttt{/src/Entity}, in
the namespace \texttt{App\textbackslash{}Entity}. So let's create a
simple \texttt{Student} class:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php}
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Entity}\OtherTok{;}

    \KeywordTok{class}\NormalTok{ Student}
\NormalTok{    \{}
        \KeywordTok{private} \KeywordTok{$id}\OtherTok{;}
        \KeywordTok{private} \KeywordTok{$firstName}\OtherTok{;}
        \KeywordTok{private} \KeywordTok{$surname}\OtherTok{;}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

That's enough typing - use your IDE (E.g. PHPStorm) to generate a public
constructor (taking in values for all 3 properties), and also public
getters/setters for each property.

\hypertarget{create-a-studentcontroller-class}{%
\section{Create a StudentController
class}\label{create-a-studentcontroller-class}}

Generate a StudentController class:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:controller Student}
\end{Highlighting}
\end{Shaded}

It should look something like this
(\texttt{/src/Controller/StudentController.php}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php}
    
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Controller}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Bundle\textbackslash{}FrameworkBundle\textbackslash{}Controller\textbackslash{}AbstractController}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Routing\textbackslash{}Annotation\textbackslash{}Route}\OtherTok{;}
    
    \KeywordTok{class}\NormalTok{ StudentController }\KeywordTok{extends}\NormalTok{ AbstractController}
\NormalTok{    \{}
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/student",}\CommentTok{ name="student")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{()}
\NormalTok{        \{}
            \StringTok{...} \KeywordTok{default }\NormalTok{code here }\StringTok{...}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

NOTE!!!!: When adding new routes, it's a good idea to \textbf{CLEAR THE
CACHE}, otherwise Symfony may not recognised the new or changed routes
\ldots{} Either manually delete the \texttt{/var/cache} directory, or
run the \texttt{cache:clear} console command:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console cache:clear}

    \ExtensionTok{//}\NormalTok{ Clearing the cache for the dev environment with debug true}
\NormalTok{    [}\ExtensionTok{OK}\NormalTok{] Cache for the }\StringTok{"dev"}\NormalTok{ environment (debug=true) }\ExtensionTok{was}\NormalTok{ successfully cleared.}
\end{Highlighting}
\end{Shaded}

Let's make this create a student (\texttt{1}, \texttt{matt},
\texttt{smith}) and display it with a Twig template (which we'll write
next!). We will also improve the route internal name, changing it to
\texttt{student\_show}, and change the method name to \texttt{show()}.
So your class (with its \texttt{use} statements, especially for
\texttt{App\textbackslash{}Entity\textbackslash{}Student}) looks as
follows now:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Controller}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Bundle\textbackslash{}FrameworkBundle\textbackslash{}Controller\textbackslash{}AbstractController}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Routing\textbackslash{}Annotation\textbackslash{}Route}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Entity\textbackslash{}Student}\OtherTok{;}
    
    \KeywordTok{class}\NormalTok{ StudentController }\KeywordTok{extends}\NormalTok{ AbstractController}
\NormalTok{    \{}
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/student",}\CommentTok{ name="student")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{$student}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Student}\OtherTok{();}
            \KeywordTok{$student}\NormalTok{->setId}\OtherTok{(}\DecValTok{99}\OtherTok{);}
            \KeywordTok{$student}\NormalTok{->setFirstName}\OtherTok{(}\StringTok{'matt'}\OtherTok{);}
            \KeywordTok{$student}\NormalTok{->setSurname}\OtherTok{(}\StringTok{'Smith'}\OtherTok{);}
            
            \KeywordTok{$template}\NormalTok{ = }\StringTok{'student/index.html.twig'}\OtherTok{;}
            \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
                \StringTok{'student'}\NormalTok{ => }\KeywordTok{$student}
            \OtherTok{];}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

NOTE:: Ensure your code has the appropriate \texttt{use} statement for
the \texttt{App\textbackslash{}Entity\textbackslash{}Student} class - a
nice IDE like PHPStorm will add this for you\ldots{}

\hypertarget{the-show-student-template-templatesstudentshow.html.twig}{%
\section{\texorpdfstring{The show student template
\texttt{/templates/student/show.html.twig}}{The show student template /templates/student/show.html.twig}}\label{the-show-student-template-templatesstudentshow.html.twig}}

In folder \texttt{/templates/student} create a new Twig template
\texttt{show.html.twig} containing the following:

\begin{verbatim}
    {% extends 'base.html.twig' %}

    {% block body %}
        <h1>Student SHOW page</h1>

        <p>
            id = {{ student.id }}
            <br>
            name = {{ student.firstName }} {{ student.surname }}
        </p>
    {% endblock %}
\end{verbatim}

Do the following:

\begin{itemize}
\item
  Run the web server

  \texttt{symnfony\ serve}
\item
  Visit \texttt{/student}

  \begin{itemize}
  \tightlist
  \item
    you should see our student details displayed as a nice HTML page.
  \end{itemize}
\end{itemize}

Figure \ref{student_show} shows a screenshot our student details web
page.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/f0902fccf036efafb73d57fda9a541beba454125.png}
\caption{Screenshot of student show page. \label{student_show}}
\end{figure}

\hypertarget{twig-debug-dump...-function}{%
\section{\texorpdfstring{Twig debug \texttt{dump(...)}
function}{Twig debug dump(...) function}}\label{twig-debug-dump...-function}}

A very useful feature of Twig is its \texttt{dump(...)} function. This
outputs to the web page a syntax colored dump of the variable its
passed. It's similar to the PHP \texttt{var\_dump(...)} function. Figure
\ref{twig_debug} shows a screenshot of adding the following to our
\texttt{index.html.twig} template:

\begin{verbatim}
    {% block body %}
        <h1>Student SHOW page</h1>
        <p>
            id = {{ student.id }}
            <br>
            name = {{ student.firstName }} {{ student.surname }}
        </p>
    
        {{ dump (student) }}
    {% endblock %}
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/76a4f1af025bb43ea8894fe24899f7e9550b20e3.png}
\caption{Screenshot of student show page. \label{twig_debug}}
\end{figure}

\hypertarget{creating-an-entity-repository-basic04}{%
\section{\texorpdfstring{Creating an Entity Repository
(\texttt{basic04})}{Creating an Entity Repository (basic04)}}\label{creating-an-entity-repository-basic04}}

We will now move on to work with an \textbf{array} of \texttt{Student}
objects, which we'll make easy to work with by creating a
\texttt{Repository} class. Let's create the \texttt{StudentRepository}
class to work with collections of Student objects. Create PHP class file
\texttt{StudentRepository.php} in directory \texttt{/src/Repository}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php}
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Repository}\OtherTok{;}

    \KeywordTok{use}\NormalTok{ App\textbackslash{}Entity\textbackslash{}Student}\OtherTok{;}

    \KeywordTok{class}\NormalTok{ StudentRepository}
\NormalTok{    \{}
        \KeywordTok{private} \KeywordTok{$students}\NormalTok{ = }\OtherTok{[];}

        \KeywordTok{public} \KeywordTok{function} \FunctionTok{__construct}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{$id}\NormalTok{ = }\DecValTok{1}\OtherTok{;}
            \KeywordTok{$s1}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Student}\OtherTok{();}
            \KeywordTok{$s1}\NormalTok{->setId}\OtherTok{(}\DecValTok{1}\OtherTok{);}
            \KeywordTok{$s1}\NormalTok{->setFirstName}\OtherTok{(}\StringTok{'matt'}\OtherTok{);}
            \KeywordTok{$s1}\NormalTok{->setSurname}\OtherTok{(}\StringTok{'smith'}\OtherTok{);}
            \KeywordTok{$this}\NormalTok{->students}\OtherTok{[}\KeywordTok{$id}\OtherTok{]}\NormalTok{ = }\KeywordTok{$s1}\OtherTok{;}
    
            \KeywordTok{$id}\NormalTok{ = }\DecValTok{2}\OtherTok{;}
            \KeywordTok{$s2}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Student}\OtherTok{();}
            \KeywordTok{$s2}\NormalTok{->setId}\OtherTok{(}\DecValTok{2}\OtherTok{);}
            \KeywordTok{$s2}\NormalTok{->setFirstName}\OtherTok{(}\StringTok{'joelle'}\OtherTok{);}
            \KeywordTok{$s2}\NormalTok{->setSurname}\OtherTok{(}\StringTok{'murphy'}\OtherTok{);}
            \KeywordTok{$this}\NormalTok{->students}\OtherTok{[}\KeywordTok{$id}\OtherTok{]}\NormalTok{ = }\KeywordTok{$s2}\OtherTok{;}
    
            \KeywordTok{$id}\NormalTok{ = }\DecValTok{3}\OtherTok{;}
            \KeywordTok{$s3}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Student}\OtherTok{();}
            \KeywordTok{$s3}\NormalTok{->setId}\OtherTok{(}\DecValTok{3}\OtherTok{);}
            \KeywordTok{$s3}\NormalTok{->setFirstName}\OtherTok{(}\StringTok{'frances'}\OtherTok{);}
            \KeywordTok{$s3}\NormalTok{->setSurname}\OtherTok{(}\StringTok{'mcguinness'}\OtherTok{);}
            \KeywordTok{$this}\NormalTok{->students}\OtherTok{[}\KeywordTok{$id}\OtherTok{]}\NormalTok{ = }\KeywordTok{$s3}\OtherTok{;}
\NormalTok{        \}}

        \KeywordTok{public} \KeywordTok{function}\NormalTok{ findAll}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->students}\OtherTok{;}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-student-list-controller-method}{%
\section{The student list controller
method}\label{the-student-list-controller-method}}

Let's replace the contents of our \texttt{index()} method in the
\texttt{StudentController} class, with one that will retrieve the array
of student records from an instance of \texttt{StudentRepository}, and
pass that array to our Twig template. The Twig template will loop
through and display each one.

Replace the existing method \texttt{index()} of controller class
\texttt{StudentController} with the following:

\begin{Shaded}
\begin{Highlighting}[]
    \StringTok{...} 

    \KeywordTok{class}\NormalTok{ StudentController }\KeywordTok{extends}\NormalTok{ AbstractController}
\NormalTok{    \{}
        \StringTok{...}
    
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/student",}\CommentTok{ name="student")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{$studentRepository}\NormalTok{ = }\KeywordTok{new}\NormalTok{ StudentRepository}\OtherTok{();}
            \KeywordTok{$students}\NormalTok{ = }\KeywordTok{$studentRepository}\NormalTok{->findAll}\OtherTok{();}
    
            \KeywordTok{$template}\NormalTok{ = }\StringTok{'student/index.html.twig'}\OtherTok{;}
            \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
                \StringTok{'students'}\NormalTok{ => }\KeywordTok{$students}
            \OtherTok{];}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}

So our routes remain the same, with the URL pattern \texttt{/student}
being routed to our \texttt{StudentController-\textgreater{}index()}
method:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console debug:router}

     \ExtensionTok{--------------------------}\NormalTok{ -------- -------- ------ -----------------------------------}
      \ExtensionTok{Name}\NormalTok{                       Method   Scheme   Host   Path}
     \ExtensionTok{--------------------------}\NormalTok{ -------- -------- ------ -----------------------------------}
      \ExtensionTok{_...}\NormalTok{ (lots of other debug profiler routes)}
      \ExtensionTok{homepage}\NormalTok{                   ANY      ANY      ANY    /}
      \ExtensionTok{student}\NormalTok{                    ANY      ANY      ANY    /student}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-list-student-template-templatesstudentindex.html.twig}{%
\section{\texorpdfstring{The list student template
\texttt{/templates/student/index.html.twig}}{The list student template /templates/student/index.html.twig}}\label{the-list-student-template-templatesstudentindex.html.twig}}

In directory \texttt{/templates/student} replace the contents of Twig
template \texttt{index.html.twig} with the following:

\begin{verbatim}
    {% extends 'base.html.twig' %}

    {% block body %}
        <h1>Student LIST page</h1>

        <ul>
            {% for student in students %}
                <li>
                    id = {{ student.id }}
                    <br>
                    name = {{ student.firstName }} {{ student.surname }}
                </li>
            {% endfor %}
        </ul>
    {% endblock %}
\end{verbatim}

Run the web server and visit \texttt{/student}, and you should see a
list of all student details displayed as a nice HTML page.

Figure \ref{student_list} shows a screenshot our list of students web
page.

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/76e5b763019278beefe14f1d51b591897b69e764.png}
\caption{Screenshot of student list page. \label{student_list}}
\end{figure}

\hypertarget{refactor-show-action-to-show-details-of-one-student-object-project-basic05}{%
\section{\texorpdfstring{Refactor show action to show details of one
Student object (project
\texttt{basic05})}{Refactor show action to show details of one Student object (project basic05)}}\label{refactor-show-action-to-show-details-of-one-student-object-project-basic05}}

The usual convention for CRUD is that the \textbf{show} action will
display the details of an object given its \texttt{id}. So let's write a
new \texttt{StudentController} method \texttt{show()} to do this. We'll
need to add a \texttt{findOne(...)} method to our repository class, that
returns an object given an id.

The route we'll design will be in the form \texttt{/student/\{id\}},
where \texttt{\{id\}} will be the integer \texttt{id} of the object in
the repository we wish to display. And, coincidentally, this is just the
correct syntax for routes with parameters that we write in the
annotation comments to define routes for controller methods in Symfony
\ldots{}

NOTE: We'll give this \textbf{show} route the internal name
\texttt{student\_show} - these internal route names are used when we
create links between pages in our Twig templates, and so it's important
to name them meaninfully and consistently to make later coding
straightforward.

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/student/\{id\}",}\CommentTok{ name="student_show")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ show}\OtherTok{(}\KeywordTok{$id}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$studentRepository}\NormalTok{ = }\KeywordTok{new}\NormalTok{ StudentRepository}\OtherTok{();}
        \KeywordTok{$student}\NormalTok{ = }\KeywordTok{$studentRepository}\NormalTok{->find}\OtherTok{(}\KeywordTok{$id}\OtherTok{);}

        \CommentTok{// we are assuming $student is not NULL....}

        \KeywordTok{$template}\NormalTok{ = }\StringTok{'student/show.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
            \StringTok{'student'}\NormalTok{ => }\KeywordTok{$student}
        \OtherTok{];}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

While we are at it, we'll change the route for our list action, to make
a list of students the default for a URL path starting with
\texttt{/student}:

\begin{Shaded}
\begin{Highlighting}[]
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/student",}\CommentTok{ name="student_list")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function} \KeywordTok{list}\OtherTok{()}
\NormalTok{        \{}
            \StringTok{...} \KeywordTok{as}\NormalTok{ before}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}

We can check these routes via the console:

\begin{itemize}
\tightlist
\item
  \texttt{/student/\{id\}} will invoke our \texttt{show(\$id)} method
\item
  \texttt{/student} will invoke our \texttt{list()} method
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
     \ExtensionTok{--------------------------}\NormalTok{ -------- -------- ------ -----------------------------------}
      \ExtensionTok{Name}\NormalTok{                       Method   Scheme   Host   Path}
     \ExtensionTok{--------------------------}\NormalTok{ -------- -------- ------ -----------------------------------}
      \ExtensionTok{_...}\NormalTok{ (lots of other debug profiler routes)}
      \ExtensionTok{homepage}\NormalTok{                   ANY      ANY      ANY    /}
      \ExtensionTok{student_list}\NormalTok{               ANY      ANY      ANY    /student}
      \ExtensionTok{student_show}\NormalTok{               ANY      ANY      ANY    /student/}\DataTypeTok{\{id\}}
\end{Highlighting}
\end{Shaded}

If you have issues of Symfony not finding a new route you've added via a
controller annotation comment, try the following.

It's a good idea to \textbf{CLEAR THE CACHE} when adding/changing
routes, otherwise Symfony may not recognised the new or changed routes
\ldots{} Either manually delete the \texttt{/var/cache} directory, or
run the \texttt{cache:clear} console command:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console cache:clear}

    \ExtensionTok{//}\NormalTok{ Clearing the cache for the dev environment with debug true}
\NormalTok{    [}\ExtensionTok{OK}\NormalTok{] Cache for the }\StringTok{"dev"}\NormalTok{ environment (debug=true) }\ExtensionTok{was}\NormalTok{ successfully cleared.}
\end{Highlighting}
\end{Shaded}

Symfony caches (stores) routing data and also rendered pages from Twig,
to speed up response time. But if you have changed controllers and
routes, sometimes you have to manually delete the cache to ensure all
new routes are checked against new requests.

\hypertarget{adding-a-findid-method-to-the-student-repository}{%
\section{\texorpdfstring{Adding a \texttt{find(\$id)} method to the
student
repository}{Adding a find(\$id) method to the student repository}}\label{adding-a-findid-method-to-the-student-repository}}

Let's add the find-one-by-id method to class \texttt{StudentRepository}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ find}\OtherTok{(}\KeywordTok{$id}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{if}\OtherTok{(}\FunctionTok{array_key_exists}\OtherTok{(}\KeywordTok{$id}\OtherTok{,} \KeywordTok{$this}\NormalTok{->students}\OtherTok{))}\NormalTok{\{}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->students}\OtherTok{[}\KeywordTok{$id}\OtherTok{];}
\NormalTok{        \} }\KeywordTok{else}\NormalTok{ \{}
            \KeywordTok{return} \KeywordTok{null}\OtherTok{;}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

If an object can be found with the key of \texttt{\$id} it will be
returned, otherwise \texttt{null} will be returned.

NOTE: At this time our code will fail if someone tries to show a student
with an Id that is not in our repository array \ldots{}

\hypertarget{make-each-item-in-list-a-link-to-show}{%
\section{Make each item in list a link to
show}\label{make-each-item-in-list-a-link-to-show}}

Let's link our templates together, so that we have a clickable link for
each student listed in the list template, that then makes a request to
show the details for the student with that id.

In our list template \texttt{/templates/student/index.html.twig} we can
get the id for the current student with \texttt{student.id}. The
internal name for our show route is \texttt{student\_show}. We can use
the \texttt{url(...)} Twig function to generate the URL path for a
route, and in this case an \texttt{id} parameter.

So we update \texttt{list.html.twig} to look as follows, where we add a
list \texttt{(details)} that will request a student's details to be
displayed with our show route:

\begin{verbatim}
    {% extends 'base.html.twig' %}

    {% block body %}
        <h1>Student LIST page</h1>

        <ul>
            {% for student in students %}
                <li>
                    id = {{ student.id }}
                    <br>
                    name = {{ student.firstName }} {{ student.surname }}
                    <br>
                    <a href="{{ url('student_show', {id : student.id} ) }}">(details)</a>
                </li>
            {% endfor %}
        </ul>
    {% endblock %}
\end{verbatim}

As we can see, to pass the \texttt{student.id} parameter to the
\texttt{student\_show} route we write a call to Twig function
\texttt{url(...)} in the form:

\begin{verbatim}
    url('student_show', {<name:value-parameter-list>} )
\end{verbatim}

We can represent a key-value array in Twig using the braces (curly
brackets), and colons. So the PHP associative array (map):

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$daysInMonth}\NormalTok{ = }\OtherTok{[}
        \StringTok{'jan'}\NormalTok{ => }\DecValTok{31}\OtherTok{,}
        \StringTok{'feb'}\NormalTok{ => }\DecValTok{28}
    \OtherTok{];}
\end{Highlighting}
\end{Shaded}

could be represented in Twig as:

\begin{verbatim}
    set daysInMonth = {'jan':31, 'feb':28}
\end{verbatim}

Thus we can pass an array of parameter-value pairs to a route in Twig
using the brace (curly bracket) syntax, as in:

\begin{verbatim}
    url('student_show', {id : student.id} )
\end{verbatim}

Figure \ref{list_with_links} shows a screenshot our list of students web
page, with a \texttt{(details)} hypertext link to the show page for each
individual student obbject.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/023e41aab54996f415924222c82f5ca0297f4d6a.png}
\caption{Screenshot of student list page, with links to show page for
each student object. \label{list_with_links}}
\end{figure}

\hypertarget{dealing-with-not-found-issues-project-basic06}{%
\section{\texorpdfstring{Dealing with not-found issues (project
\texttt{basic06})}{Dealing with not-found issues (project basic06)}}\label{dealing-with-not-found-issues-project-basic06}}

If we attempted to retrieve a record, but got back \texttt{null}, we
might cope with it in this way in our controller method, i.e.~by
throwing a Not-Found-Exception (which generates a 404-page in
production):

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{if} \OtherTok{(}\NormalTok{!}\KeywordTok{$student}\OtherTok{)}\NormalTok{ \{}
        \KeywordTok{throw} \KeywordTok{$this}\NormalTok{->createNotFoundException}\OtherTok{(}
            \StringTok{'No product found for id '}\NormalTok{.}\KeywordTok{$id}
        \OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Or we could simply create an error Twig page, and display that to the
user, e.g.:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ showAction}\OtherTok{(}\KeywordTok{$id}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$studentRepository}\NormalTok{ = }\KeywordTok{new}\NormalTok{ StudentRepository}\OtherTok{();}
        \KeywordTok{$student}\NormalTok{ = }\KeywordTok{$studentRepository}\NormalTok{->find}\OtherTok{(}\KeywordTok{$id}\OtherTok{);}

        \KeywordTok{$template}\NormalTok{ = }\StringTok{'student/show.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
            \StringTok{'student'}\NormalTok{ => }\KeywordTok{$student}
        \OtherTok{];}

        \KeywordTok{if} \OtherTok{(}\NormalTok{!}\KeywordTok{$student}\OtherTok{)}\NormalTok{ \{}
            \KeywordTok{$template}\NormalTok{ = }\StringTok{'error/404.html.twig'}\OtherTok{;}
\NormalTok{        \}}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

and a Twig template \texttt{/templates/error/404.html.twig} looking like
this:

\begin{verbatim}
    {% extends 'base.html.twig' %}
    
    {% block title %}ERROR PAGE{% endblock %}

    {% block body %}
        <h1>Whoops! something went wrong</h1>

        <h2>404 - no found error</h2>

        <p>
            sorry - the item/page you were looking for could not be found
        </p>
    {% endblock %}
\end{verbatim}

NOTE: We have overriden the \texttt{title} Twig block, so that the page
title is \texttt{ERROR\ PAGE}\ldots{}

Figure \ref{error404} shows a screenshot of our custom 404 error
template for when no such student can be found for the given ID.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/b66452000a3a5aa4ea5946995e99460914a2e6d5.png}
\caption{Error page for non-existant student ID = 66. \label{error404}}
\end{figure}

\part{Symfony and Databases}

\hypertarget{doctrine-the-orm}{%
\chapter{Doctrine the ORM}\label{doctrine-the-orm}}

\hypertarget{what-is-an-orm}{%
\section{What is an ORM?}\label{what-is-an-orm}}

The acronym ORM stands for:

\begin{itemize}
\tightlist
\item
  O: Object
\item
  R: Relational
\item
  M: Mapping
\end{itemize}

In a nutshell projects using an ORM mean we write code relating to
collections of related \textbf{objects}, without having to worry about
the way the data in those objects is actually represented and stored via
a database or disk filing system or whatever. This is an example of
`abstraction' - adding a `layer' between one software component and
another. DBAL is the term used for separating the database interactions
completed from other software components. DBAL stands for:

\begin{itemize}
\tightlist
\item
  DataBase
\item
  Abstraction
\item
  Layer
\end{itemize}

With ORMs we can interactive (CRUD\footnote{CRUD =
  Create-Read-Update-Delete}) with persistent object collections either
using methods of the object repositories (e.g.~\texttt{findAll()},
\texttt{findOneById()}, \texttt{delete()} etc.), or using SQL-lite
languages. For example Symfony uses the \texttt{Doctrine} ORM system,
and that offers \texttt{DQL}, the Doctrine Query Language.

You can read more about ORMs and Symfony at:

\begin{itemize}
\tightlist
\item
  \href{http://www.doctrine-project.org/projects/orm.html}{Doctrine
  project's ORM page}
\item
  \href{https://en.wikipedia.org/wiki/Object-relational_mapping}{Wikipedia's
  ORM page}
\item
  \href{https://symfony.com/doc/current/doctrine.html}{Symfony's
  Doctrine help pages}
\end{itemize}

\hypertarget{setting-the-database-connection-url-for-mysql}{%
\section{Setting the database connection URL for
MySQL}\label{setting-the-database-connection-url-for-mysql}}

NOTE: This chapter assumes you are starting from the Student basic
project from the end of the last chapter\ldots{}

Edit file \texttt{.env} to change the default database URL to one that
will connect to MySQL server running at port 3306, with username
\texttt{root} and password \texttt{pass}, and working with databse
schema \texttt{web3} (or whatever \textbf{you want to name your database
\ldots{}})

So change this line in \texttt{.env} from:

\begin{Shaded}
\begin{Highlighting}[]
    \VariableTok{DATABASE_URL=}\NormalTok{mysql://db_user:db_password}\ExtensionTok{@127.0.0.1}\NormalTok{:3306/db_name}
\end{Highlighting}
\end{Shaded}

to

\begin{Shaded}
\begin{Highlighting}[]
    \VariableTok{DATABASE_URL=}\NormalTok{mysql://root:pass}\ExtensionTok{@127.0.0.1}\NormalTok{:3306/web3}
\end{Highlighting}
\end{Shaded}

NOTE: If you prefer to parametize the database connection, use
environment variables and then \texttt{\$\{VAR\}} in your URL:

\begin{Shaded}
\begin{Highlighting}[]
    \VariableTok{DB_USER=}\NormalTok{root}
    \VariableTok{DB_PASSWORD=}\NormalTok{pass}
    \VariableTok{DB_HOST=}\NormalTok{127.0.0.1}
    \VariableTok{DB_PORT=}\NormalTok{3306}
    \VariableTok{DB_NAME=}\NormalTok{web3}
    \VariableTok{DATABASE_URL=}\NormalTok{mysql://}\VariableTok{$\{DB_USER\}}\NormalTok{:}\VariableTok{$\{DB_PASSWORD\}}\ExtensionTok{@}\VariableTok{$\{DB_HOST\}}\NormalTok{:}\VariableTok{$\{DB_PORT\}}\NormalTok{/}\VariableTok{$\{DB_NAME\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{setting-the-database-connection-url-for-sqlite}{%
\section{Setting the database connection URL for
SQLite}\label{setting-the-database-connection-url-for-sqlite}}

If you want a non-MySQL database setup for now, then just use the basic
SQLite setup:

So change this line in \texttt{.env} from:

\begin{Shaded}
\begin{Highlighting}[]
    \VariableTok{DATABASE_URL=}\NormalTok{mysql://db_user:db_password}\ExtensionTok{@127.0.0.1}\NormalTok{:3306/db_name}
\end{Highlighting}
\end{Shaded}

to

\begin{Shaded}
\begin{Highlighting}[]
    \VariableTok{DATABASE_URL=}\NormalTok{sqlite:///%kernel.project_dir%/var/data.db}
\end{Highlighting}
\end{Shaded}

This will work with SQLite database file \texttt{data.db} in directory
\texttt{/var}.

\hypertarget{quick-start}{%
\section{Quick start}\label{quick-start}}

Once you've learnt how to work with Entity classes and Doctrine, these
are the 3 commands you need to know (executed from the CLI console
\texttt{php\ bin/console\ ...}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{doctrine:database:create}
\item
  \texttt{doctrine:migrations:diff}
\item
  \texttt{doctrine:migrations:migrate} (or possibly
  \texttt{doctrine:schema:update\ -\/-force})
\item
  \texttt{doctrine:schema:validate}
\item
  \texttt{doctrine:fixtures:load}
\item
  \texttt{doctrine:query:sql}
\end{enumerate}

This should make sense by the time you've reached the end of this
database introduction.

\hypertarget{make-your-database}{%
\section{Make your database}\label{make-your-database}}

We can now use the settings in the \texttt{.env} file to connect to the
MySQL server and create our database schema:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console doctrine:database:create}
\end{Highlighting}
\end{Shaded}

\hypertarget{working-with-entity-classes}{%
\chapter{Working with Entity
classes}\label{working-with-entity-classes}}

\hypertarget{a-student-db-entity-class-project-db01}{%
\section{\texorpdfstring{A \texttt{Student} DB-entity class (project
\texttt{db01})}{A Student DB-entity class (project db01)}}\label{a-student-db-entity-class-project-db01}}

Doctrine expects to find entity classes in a directory named
\texttt{/src/Entity}, and corresponding repository classes in
\texttt{/src/Repository}. We already have our \texttt{Student} and
\texttt{StudentRepository} classes in the right places!

Although we'll have to make some changes to these classes of course.

\hypertarget{using-annotation-comments-to-declare-db-mappings}{%
\section{Using annotation comments to declare DB
mappings}\label{using-annotation-comments-to-declare-db-mappings}}

We need to tell Doctrine what table name this entity should map to, and
also confirm the data types of each field. We'll do this using
annotation comments (although this can be also be declare in separate
YAML or XML files if you prefer). We need to add a \texttt{use}
statement and we define the namespace alias \texttt{ORM} to keep our
comments simpler.

Our first comment is for the class, stating that it is an ORM entity and
mapping it to ORM repository class \texttt{StudentRepository}.

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Entity}\OtherTok{;}

    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}}\KeywordTok{ORM}\NormalTok{\textbackslash{}Mapping }\KeywordTok{as} \KeywordTok{ORM}\OtherTok{;}

    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@ORM\textbackslash{}Entity(repositoryClass="App\textbackslash{}Repository\textbackslash{}StudentRepository")}
\CommentTok{     */}
    \KeywordTok{class}\NormalTok{ Student}
\NormalTok{    \{}
\end{Highlighting}
\end{Shaded}

\hypertarget{declaring-types-for-fields}{%
\section{Declaring types for fields}\label{declaring-types-for-fields}}

We now use annotations to declare the types (and if appropriate,
lengths) of each field.

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@ORM\textbackslash{}Id}
\CommentTok{     * }\AnnotationTok{@ORM\textbackslash{}GeneratedValue}
\CommentTok{     * }\AnnotationTok{@ORM\textbackslash{}Column(type="integer")}
\CommentTok{     */}
    \KeywordTok{private} \KeywordTok{$id}\OtherTok{;}

    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@ORM\textbackslash{}Column(type="string")}
\CommentTok{     */}
    \KeywordTok{private} \KeywordTok{$firstName}\OtherTok{;}

    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@ORM\textbackslash{}Column(type="string")}
\CommentTok{     */}
    \KeywordTok{private} \KeywordTok{$surname}\OtherTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{validate-our-annotations}{%
\section{Validate our annotations}\label{validate-our-annotations}}

We can now validate these values. This command performs 2 actions, it
checks our annotation comments, it also checks whether these match with
the structure of the table the database system. Of course, since we
haven't yet told Doctrine to create the actual database schema and
tables, this second check will fail at this point in time.

\begin{verbatim}
    $ php bin/console doctrine:schema:validate
\end{verbatim}

The output should be something like this (if our comments are valid):

\begin{verbatim}
    Mapping
    -------
    [OK] The mapping files are correct.

    Database
    --------
    [ERROR] The database schema is not in sync with the current mapping file.
\end{verbatim}

\hypertarget{the-studenrepository-class-srcrepositorystudentrepository}{%
\section{\texorpdfstring{The StudenRepository class
(\texttt{/src/Repository/StudentRepository})}{The StudenRepository class (/src/Repository/StudentRepository)}}\label{the-studenrepository-class-srcrepositorystudentrepository}}

We need to change our repository class to be one that works with the
Doctrine ORM. Unless we are writing special purpose query methods, all
we really need for an ORM repository class is to ensure is subclasses
\texttt{DoctrineBundle\textbackslash{}Repository\textbackslash{}ServiceEntityRepository}
and its constructor points it to the corresponding entity class.

Change class \texttt{StudentRepository} as follows:

\begin{itemize}
\item
  remove all methods
\item
  add \texttt{use} statements for:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}Bundle\textbackslash{}DoctrineBundle\textbackslash{}Repository\textbackslash{}ServiceEntityRepository}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}Common\textbackslash{}Persistence\textbackslash{}ManagerRegistry}\OtherTok{;}      
\end{Highlighting}
\end{Shaded}
\item
  make the class extend class \texttt{ServiceEntityRepository}

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{class}\NormalTok{ StudentRepository }\KeywordTok{extends}\NormalTok{ ServiceEntityRepository}
\end{Highlighting}
\end{Shaded}
\item
  add a constructor method:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function} \FunctionTok{__construct}\OtherTok{(}\NormalTok{ManagerRegistry }\KeywordTok{$registry}\OtherTok{)}
\NormalTok{    \{}
\NormalTok{        parent::}\FunctionTok{__construct}\OtherTok{(}\KeywordTok{$registry}\OtherTok{,}\NormalTok{ Student::}\KeywordTok{class}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}
\end{itemize}

So the full listing for \texttt{StudentRepository} is now:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Repository}\OtherTok{;}

    \KeywordTok{use}\NormalTok{ App\textbackslash{}Entity\textbackslash{}Student}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}Bundle\textbackslash{}DoctrineBundle\textbackslash{}Repository\textbackslash{}ServiceEntityRepository}\OtherTok{;}
        \KeywordTok{public} \KeywordTok{function} \FunctionTok{__construct}\OtherTok{(}\NormalTok{ManagerRegistry }\KeywordTok{$registry}\OtherTok{)}

    \KeywordTok{class}\NormalTok{ StudentRepository }\KeywordTok{extends}\NormalTok{ ServiceEntityRepository}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function} \FunctionTok{__construct}\OtherTok{(}\NormalTok{ManagerRegistry }\KeywordTok{$registry}\OtherTok{)}
\NormalTok{        \{}
\NormalTok{            parent::}\FunctionTok{__construct}\OtherTok{(}\KeywordTok{$registry}\OtherTok{,}\NormalTok{ Student::}\KeywordTok{class}\OtherTok{);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{create-a-migration-a-migration-diff-file}{%
\section{\texorpdfstring{Create a migration (a migration \texttt{diff}
file)}{Create a migration (a migration diff file)}}\label{create-a-migration-a-migration-diff-file}}

We now will tell Symfony to create the a PHP class to run SQL migration
commands required to change the structure of the existing database to
match that of our Entity classes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:migration}

    \ExtensionTok{Success}\NormalTok{! }
    
    \ExtensionTok{Next}\NormalTok{: Review the new migration }\StringTok{"src/Migrations/Version20180213082441.php"}
    \ExtensionTok{Then}\NormalTok{: Run the migration with php bin/console doctrine:migrations:migrate}
    \ExtensionTok{See}\NormalTok{ https://symfony.com/doc/current/bundles/DoctrineMigrationsBundle/index.html}
\end{Highlighting}
\end{Shaded}

NOTE: This is a shorter way of writing the old \texttt{doctrine}
command: \texttt{php\ bin/console\ doctrine:migrations:diff}

A migrations SQL file should have been created in
\texttt{/src/Migrations/...php}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ DoctrineMigrations}\OtherTok{;}

    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}}\KeywordTok{DBAL}\NormalTok{\textbackslash{}Migrations\textbackslash{}AbstractMigration}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}}\KeywordTok{DBAL}\NormalTok{\textbackslash{}Schema\textbackslash{}Schema}\OtherTok{;}

    \CommentTok{/**}
\CommentTok{     * Auto-generated Migration: Please modify to your needs!}
\CommentTok{     */}
    \KeywordTok{class}\NormalTok{ Version20180213082441 }\KeywordTok{extends}\NormalTok{ AbstractMigration}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ up}\OtherTok{(}\NormalTok{Schema }\KeywordTok{$schema}\OtherTok{)}
\NormalTok{        \{}
            \CommentTok{// this up() migration is auto-generated, please modify it to your needs}
            \KeywordTok{$this}\NormalTok{->abortIf}\OtherTok{(}\KeywordTok{$this}\NormalTok{->connection->getDatabasePlatform}\OtherTok{()}\NormalTok{->getName}\OtherTok{()}\NormalTok{ !== }\StringTok{'mysql'}\OtherTok{,}
            \StringTok{'Migration can only be executed safely on }\KeywordTok{\textbackslash{}'}\StringTok{mysql}\KeywordTok{\textbackslash{}'}\StringTok{.'}\OtherTok{);}

            \KeywordTok{$this}\NormalTok{->addSql}\OtherTok{(}\StringTok{'CREATE TABLE student (id INT AUTO_INCREMENT NOT NULL,}
\StringTok{            first_name VARCHAR(255) NOT NULL, surname VARCHAR(255) NOT NULL, PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8 COLLATE}
\end{Highlighting}
\end{Shaded}

\hypertarget{run-the-migration-to-make-the-database-structure-match-the-entity-class-declarations}{%
\section{Run the migration to make the database structure match the
entity class
declarations}\label{run-the-migration-to-make-the-database-structure-match-the-entity-class-declarations}}

Run the \texttt{migrate} command to execute the created migration class
to make the database schema match the structure of your entity classes,
and enter \texttt{y} when prompted - if you are happy to go ahead and
change the database structure:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console doctrine:migrations:migrate}

        \ExtensionTok{Application}\NormalTok{ Migrations}


    \ExtensionTok{WARNING}\NormalTok{! You are about to execute a database migration that could result in}
    \ExtensionTok{schema}\NormalTok{ changes and data lost. Are you sure you wish to continue? (y/n)}\ExtensionTok{y}
    \ExtensionTok{Migrating}\NormalTok{ up to 20180201223133 from 0}

      \ExtensionTok{++}\NormalTok{ migrating 20180201223133}

         \ExtensionTok{-}\OperatorTok{>}\NormalTok{ CREATE TABLE product (id INT AUTO_INCREMENT NOT NULL,}
         \ExtensionTok{description}\NormalTok{ VARCHAR(100) }\ExtensionTok{NOT}\NormalTok{ NULL, price NUMERIC(10, 2) }\ExtensionTok{DEFAULT}\NormalTok{ NULL,}
         \ExtensionTok{PRIMARY}\NormalTok{ KEY(id)) }\ExtensionTok{DEFAULT}\NormalTok{ CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB}

      \ExtensionTok{++}\NormalTok{ migrated (0.14s)}

      \ExtensionTok{------------------------}

      \ExtensionTok{++}\NormalTok{ finished in 0.14s}
      \ExtensionTok{++}\NormalTok{ 1 migrations executed}
      \ExtensionTok{++}\NormalTok{ 1 sql queries}
\end{Highlighting}
\end{Shaded}

You can see the results of creating the database schema and creating
table(s) to match your ORM entities using a database client such as
MySQL Workbench. Figure \ref{db_schema} shows a screenshot of MySQL
Workbench showing the database's \texttt{student} table to match our
\texttt{Student} entity class.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/30c41e5c5578a73fe9d7d82f45da81b21af7455c.png}
\caption{Screenshot MySQL Workbench and generated schema and product
table. \label{db_schema}}
\end{figure}

\hypertarget{re-validiate-our-annotations}{%
\section{Re-validiate our
annotations}\label{re-validiate-our-annotations}}

We should get 2 ``ok''s if we re-validate our schema now:

\begin{verbatim}
    $ php bin/console doctrine:schema:validate
\end{verbatim}

The output should be something like this (if our comments are valid):

\begin{verbatim}
    Mapping
    -------
    [OK] The mapping files are correct.

    Database
    --------
    [OK] The database schema is in sync with the mapping files.
\end{verbatim}

\hypertarget{generating-entities-from-an-existing-database}{%
\section{Generating entities from an existing
database}\label{generating-entities-from-an-existing-database}}

Doctrine allows you to generated entities matching tables in an existing
database. Learn about that from the Symfony documentation pages:

\begin{itemize}
\tightlist
\item
  \href{https://symfony.com/doc/current/doctrine/reverse_engineering.html}{Symfony
  docs on inferring entites from existing db tables}
\end{itemize}

\hypertarget{note---use-maker-to-save-time-project-db02}{%
\section{\texorpdfstring{Note - use maker to save time (project
\texttt{db02})}{Note - use maker to save time (project db02)}}\label{note---use-maker-to-save-time-project-db02}}

We could have automatically created our Student entity and
StudentRepository classes from scratch, using the \texttt{make} package:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:entity Student}
      
       \ExtensionTok{created}\NormalTok{: src/Entity/Student.php}
       \ExtensionTok{created}\NormalTok{: src/Repository/StudentRepository.php}
       
       \ExtensionTok{Entity}\NormalTok{ generated! Now let}\StringTok{'s add some fields!}
\StringTok{       You can always add more fields later manually or by re-running this command.}
\StringTok{      }
\StringTok{       New property name (press <return> to stop adding fields):}
\StringTok{       > }

\StringTok{        Success! }
\StringTok{      }
\StringTok{       Next: When you'}\NormalTok{re ready, create a migration with make:migration}
\NormalTok{    $}
\end{Highlighting}
\end{Shaded}

In the above \texttt{\textless{}RETURN\textgreater{}} was pressed to not
add any fields automatically. The Maker bundle created 2 classes for us:

\begin{itemize}
\item
  a Student class \texttt{src/Entity/Student.php}, containing just a
  private \texttt{id} property and a public \texttt{getId()} method
\item
  and a generic StudentRepository class
  \texttt{src/Repository/StudentRepository.php}
\end{itemize}

We would then be able to manually add the \texttt{firstName} and
\texttt{surname} properties (and their annotation comments) as we did
earlier in the chapter:

\begin{Shaded}
\begin{Highlighting}[]

    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@ORM\textbackslash{}Column(type="string")}
\CommentTok{     */}
    \KeywordTok{private} \KeywordTok{$firstName}\OtherTok{;}

    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@ORM\textbackslash{}Column(type="string")}
\CommentTok{     */}
    \KeywordTok{private} \KeywordTok{$surname}\OtherTok{;}
\end{Highlighting}
\end{Shaded}

Finally we would have had to generate getters and setters for these 2
fields, and migrate to the database.

\hypertarget{use-maker-to-create-properties-annotations-and-accessor-methods}{%
\section{Use maker to create properties, annotations and accessor
methods!}\label{use-maker-to-create-properties-annotations-and-accessor-methods}}

We could automatically create our Student entity and StudentRepository
classes from scratch, using the \texttt{make} package. It will
interactively ask you about fields you wish to create, and add the
appropriate annotations and accessor (get/set) methods for you!

If you want to try this, first:

\begin{itemize}
\item
  Delete the entity class: \texttt{/src/Entity/Student.php}
\item
  Delete the repository class:
  \texttt{/src/Repository/StudentRepository.php}
\end{itemize}

Then run the CLI command \texttt{make:entity\ Student}, and at the
prompt ask it to create our \texttt{firstName} and \texttt{surname} text
properties (all entities get an auto-incremented \texttt{Id} field with
us having to ask):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:entity Student}
    
     \ExtensionTok{created}\NormalTok{: src/Entity/Student.php}
     \ExtensionTok{created}\NormalTok{: src/Repository/StudentRepository.php}
     
     \ExtensionTok{Entity}\NormalTok{ generated! Now let}\StringTok{'s add some fields!}
\StringTok{     You can always add more fields later manually or by re-running this command.}
\StringTok{    }
\StringTok{     New property name (press <return> to stop adding fields):}
\StringTok{     > firstName}
\StringTok{    }
\StringTok{     Field type (enter ? to see all types) [string]:}
\StringTok{     > }
\StringTok{    }
\StringTok{     Field length [255]:}
\StringTok{     > }
\StringTok{    }
\StringTok{     Can this field be null in the database (nullable) (yes/no) [no]:}
\StringTok{     > surnamne}
\StringTok{    }
\StringTok{     updated: src/Entity/Student.php}
\StringTok{    }
\StringTok{     Add another property? Enter the property name (or press <return> to stop adding fields):}
\StringTok{     > }
\StringTok{               }
\StringTok{      Success! }
\StringTok{    }
\StringTok{     Next: When you'}\NormalTok{re ready, create a migration with make:migration    }
\end{Highlighting}
\end{Shaded}

For each property the Maker bundle wants to know 3 things:

\begin{itemize}
\tightlist
\item
  property name (e.g.~\texttt{firstName} and \texttt{surname})
\item
  property type (default is \texttt{string})
\item
  whether \texttt{NULL} can be stored for property
\end{itemize}

For \texttt{string} properties like \texttt{firstName} we just need to
enter the property name and hit \texttt{\textless{}RETURN\textgreater{}}
for the defaults (\texttt{string}, not nullable). For other types of
field you can get a list of types by entering \texttt{?} at the prompt:.
There are quite a few of them:

\begin{Shaded}
\begin{Highlighting}[]
     \ExtensionTok{Field}\NormalTok{ type (enter ? to see all types) [}\ExtensionTok{string}\NormalTok{]:}
     \OperatorTok{>} \ExtensionTok{?}
    
    \ExtensionTok{Main}\NormalTok{ types}
      \ExtensionTok{*}\NormalTok{ string}
      \ExtensionTok{*}\NormalTok{ text}
      \ExtensionTok{*}\NormalTok{ boolean}
      \ExtensionTok{*}\NormalTok{ integer (or smallint, bigint)}
      \ExtensionTok{*}\NormalTok{ float}
    
    \ExtensionTok{Relationships}\NormalTok{ / Associations}
      \ExtensionTok{*}\NormalTok{ relation (a wizard   will help you build the relation)}
      \ExtensionTok{*}\NormalTok{ ManyToOne}
      \ExtensionTok{*}\NormalTok{ OneToMany}
      \ExtensionTok{*}\NormalTok{ ManyToMany}
      \ExtensionTok{*}\NormalTok{ OneToOne}
    
    \ExtensionTok{Array/Object}\NormalTok{ Types}
      \ExtensionTok{*}\NormalTok{ array (or simple_array)}
      \ExtensionTok{*}\NormalTok{ json}
      \ExtensionTok{*}\NormalTok{ object}
      \ExtensionTok{*}\NormalTok{ binary}
      \ExtensionTok{*}\NormalTok{ blob}
    
    \ExtensionTok{Date/Time}\NormalTok{ Types}
      \ExtensionTok{*}\NormalTok{ datetime (or datetime_immutable)}
      \ExtensionTok{*}\NormalTok{ datetimetz (or datetimetz_immutable)}
      \ExtensionTok{*}\NormalTok{ date (or date_immutable)}
      \ExtensionTok{*}\NormalTok{ time (or time_immutable)}
      \ExtensionTok{*}\NormalTok{ dateinterval}
    
    \ExtensionTok{Other}\NormalTok{ Types}
      \ExtensionTok{*}\NormalTok{ json_array}
      \ExtensionTok{*}\NormalTok{ decimal}
      \ExtensionTok{*}\NormalTok{ guid}
\end{Highlighting}
\end{Shaded}

\hypertarget{symfony-approach-to-database-crud}{%
\chapter{Symfony approach to database
CRUD}\label{symfony-approach-to-database-crud}}

\hypertarget{creating-new-student-records-project-db02}{%
\section{\texorpdfstring{Creating new student records (project
\texttt{db02})}{Creating new student records (project db02)}}\label{creating-new-student-records-project-db02}}

Let's add a new route and controller method to our
\texttt{StudentController} class. This will define the \texttt{create()}
method that receives parameter \texttt{\$firstName} and
\texttt{\$surname} extracted from the route
\texttt{/students/create/\{firstName\}/\{surname\}}. This is all done
automatically for us, through Symfony seeing the route parameters in the
\texttt{@Route(...)} annotation comment that immediately precedes the
controller method. The `signature' for our new \texttt{create(...)}
method names 2 parameters that match those in the \texttt{@Route(...)}
annotation comment \texttt{create(\$firstName,\ \$surame)}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/student/create/\{firstName\}/\{surname\}")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ create}\OtherTok{(}\KeywordTok{$firstName}\OtherTok{,} \KeywordTok{$surname}\OtherTok{)}
\end{Highlighting}
\end{Shaded}

Creating a new \texttt{Student} object is straightforward, given
\texttt{\$firstName} and \texttt{\$surname} from the URL-encoded GET
name=value pairs:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$student}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Student}\OtherTok{();}
    \KeywordTok{$student}\NormalTok{->setFirstName}\OtherTok{(}\KeywordTok{$firstName}\OtherTok{);}
    \KeywordTok{$student}\NormalTok{->setSurname}\OtherTok{(}\KeywordTok{$surname}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

Then we see the Doctrine code, to get a reference to the ORM
\texttt{EntityManager}, to tell it to store (\texttt{persist}) the
object \texttt{\$product}, and then we tell it to finalise (i.e.~write
to the database) any entities waiting to be persisted:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$em}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{();}
    \KeywordTok{$em}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$student}\OtherTok{);}
    \KeywordTok{$em}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}
\end{Highlighting}
\end{Shaded}

So the code for our create controller method is:

\begin{Shaded}
\begin{Highlighting}[]
    \StringTok{...}
    \CommentTok{// we need to add a 'use' statement so we can create a Response object...}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Response}\OtherTok{;}
    \StringTok{...}

    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/student/create/\{firstName\}/\{surname\}")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ create}\OtherTok{(}\KeywordTok{$firstName}\OtherTok{,} \KeywordTok{$surname}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$student}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Student}\OtherTok{();}
        \KeywordTok{$student}\NormalTok{->setFirstName}\OtherTok{(}\KeywordTok{$firstName}\OtherTok{);}
        \KeywordTok{$student}\NormalTok{->setSurame}\OtherTok{(}\KeywordTok{$surname}\OtherTok{);}

        \CommentTok{// entity manager}
        \KeywordTok{$em}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{();}

        \CommentTok{// tells Doctrine you want to (eventually) save the Product (no queries yet)}
        \KeywordTok{$em}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$student}\OtherTok{);}

        \CommentTok{// actually executes the queries (i.e. the INSERT query)}
        \KeywordTok{$em}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}

        \KeywordTok{return} \KeywordTok{new}\NormalTok{ Response}\OtherTok{(}\StringTok{'Created new student with id '}\NormalTok{.}\KeywordTok{$student}\NormalTok{->getId}\OtherTok{());}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

The above now means we can create new records in our database via this
new route. So to create a record with name \texttt{matt\ smith} just
visit this URL with your browser:

\begin{verbatim}
    http://localhost:8000/student/create/matt/smith
\end{verbatim}

Figure \ref{new_student} shows how a new record \texttt{matt\ smith} is
added to the database table via route
\texttt{/student/create/\{firstName\}/\{surname\}}.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/362b681e24aa9da80460f615378c7ff8663ced77.png}
\caption{Creating new student via route
\texttt{/students/create/\{firstName\}/\{surname\}}.
\label{new_student}}
\end{figure}

We can see these records in our database. Figure \ref{students_table}
shows our new \texttt{students} table created for us.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/ce432826e1e4e2f0dc4cdf1e248d79b4fbcd967f.png}
\caption{Controller created records in PHPMyAdmin.
\label{students_table}}
\end{figure}

\hypertarget{query-database-with-sql-from-cli-server}{%
\section{Query database with SQL from CLI
server}\label{query-database-with-sql-from-cli-server}}

The \texttt{doctrine:query:sql} CLI command allows us to run SQL queries
to our database directly from the CLI. Let's request all
\texttt{Product} rows from table \texttt{product}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console doctrine:query:sql }\StringTok{"select * from student"}

   \ExtensionTok{.../vendor/doctrine/common/lib/Doctrine/Common/Util}\NormalTok{/Debug.php:}\ExtensionTok{71}\NormalTok{:}
    \ExtensionTok{array}\NormalTok{ (size=1)}
      \ExtensionTok{0}\NormalTok{ =}\OperatorTok{>}
        \ExtensionTok{array}\NormalTok{ (size=3)}
          \StringTok{'id'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'1'}\NormalTok{ (length=1)}
          \StringTok{'first_name'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'matt'}\NormalTok{ (length=4)}
          \StringTok{'surname'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'smith'}\NormalTok{ (length=5)}
\end{Highlighting}
\end{Shaded}

\hypertarget{updating-the-listaction-to-use-doctrine}{%
\section{Updating the listAction() to use
Doctrine}\label{updating-the-listaction-to-use-doctrine}}

Doctrine creates repository objects for us. So we change the first line
of method \texttt{list()} to the following:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$studentRepository}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getRepository}\OtherTok{(}\StringTok{'App:Student'}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

Doctrine repositories offer us lots of useful methods, including:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{// query for a single record by its primary key (usually "id")}
    \KeywordTok{$student}\NormalTok{ = }\KeywordTok{$repository}\NormalTok{->find}\OtherTok{(}\KeywordTok{$id}\OtherTok{);}

    \CommentTok{// dynamic method names to find a single record based on a column value}
    \KeywordTok{$student}\NormalTok{ = }\KeywordTok{$repository}\NormalTok{->findOneById}\OtherTok{(}\KeywordTok{$id}\OtherTok{);}
    \KeywordTok{$student}\NormalTok{ = }\KeywordTok{$repository}\NormalTok{->findOneByFirstName}\OtherTok{(}\StringTok{'matt'}\OtherTok{);}

    \CommentTok{// find *all* products}
    \KeywordTok{$students}\NormalTok{ = }\KeywordTok{$repository}\NormalTok{->findAll}\OtherTok{();}

    \CommentTok{// dynamic method names to find a group of products based on a column value}
    \KeywordTok{$products}\NormalTok{ = }\KeywordTok{$repository}\NormalTok{->findBySurname}\OtherTok{(}\StringTok{'smith'}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

So we need to change the second line of of method \texttt{list()} to use
the \texttt{findAll()} repository method:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$students}\NormalTok{ = }\KeywordTok{$studentRepository}\NormalTok{->findAll}\OtherTok{();}
\end{Highlighting}
\end{Shaded}

Our listAction() method now looks as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ listAction}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{$studentRepository}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getRepository}\OtherTok{(}\StringTok{'App:Student'}\OtherTok{);}
        \KeywordTok{$students}\NormalTok{ = }\KeywordTok{$studentRepository}\NormalTok{->findAll}\OtherTok{();}

        \KeywordTok{$argsArray}\NormalTok{ = }\OtherTok{[}
            \StringTok{'students'}\NormalTok{ => }\KeywordTok{$students}
        \OtherTok{];}

        \KeywordTok{$templateName}\NormalTok{ = }\StringTok{'students/list'}\OtherTok{;}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$templateName}\NormalTok{ . }\StringTok{'.html.twig'}\OtherTok{,} \KeywordTok{$argsArray}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Figure \ref{student_list2} shows Twig HTML page listing all students
generated from route \texttt{/student}.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/d6c231f28f39e6b1be9d1ad08365c598d6620f5d.png}
\caption{Listing all database student records with route
\texttt{/student}. \label{student_list2}}
\end{figure}

\hypertarget{deleting-by-id}{%
\section{Deleting by id}\label{deleting-by-id}}

Let's define a delete route \texttt{/student/delete/\{id\}} and a
\texttt{delete()} controller method. This method needs to first retreive
the object (from the database) with the given ID, then ask to remove it,
then flush the changes to the database (i.e.~actually remove the record
from the database). Note in this method we need both a reference to the
entity manager \texttt{\$em} and also to the student repository object
\texttt{\$studentRepository}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/student/delete/\{id\}")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ delete}\OtherTok{(}\KeywordTok{$id}\OtherTok{)}
\NormalTok{    \{}
        \CommentTok{// entity manager}
        \KeywordTok{$em}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{();}
        \KeywordTok{$studentRepository}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getRepository}\OtherTok{(}\StringTok{'App:Student'}\OtherTok{);}

        \CommentTok{// find thge student with this ID}
        \KeywordTok{$student}\NormalTok{ = }\KeywordTok{$studentRepository}\NormalTok{->find}\OtherTok{(}\KeywordTok{$id}\OtherTok{);}

        \CommentTok{// tells Doctrine you want to (eventually) delete the Student (no queries yet)}
        \KeywordTok{$em}\NormalTok{->remove}\OtherTok{(}\KeywordTok{$student}\OtherTok{);}

        \CommentTok{// actually executes the queries (i.e. the DELETE query)}
        \KeywordTok{$em}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}

        \KeywordTok{return} \KeywordTok{new}\NormalTok{ Response}\OtherTok{(}\StringTok{'Deleted student with id '}\NormalTok{.}\KeywordTok{$id}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{updating-given-id-and-new-name}{%
\section{Updating given id and new
name}\label{updating-given-id-and-new-name}}

We can do something similar to update. In this case we need 3
parameters: the id and the new first and surname. We'll also follow the
Symfony examples (and best practice) by actually testing whether or not
we were successful retrieving a record for the given id, and if not then
throwing a `not found' exception.

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/student/update/\{id\}/\{newFirstName\}/\{newSurname\}")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ update}\OtherTok{(}\KeywordTok{$id}\OtherTok{,} \KeywordTok{$newFirstName}\OtherTok{,} \KeywordTok{$newSurname}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$em}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{();}
        \KeywordTok{$student}\NormalTok{ = }\KeywordTok{$em}\NormalTok{->getRepository}\OtherTok{(}\StringTok{'App:Student'}\OtherTok{)}\NormalTok{->find}\OtherTok{(}\KeywordTok{$id}\OtherTok{);}

        \KeywordTok{if} \OtherTok{(}\NormalTok{!}\KeywordTok{$student}\OtherTok{)}\NormalTok{ \{}
            \KeywordTok{throw} \KeywordTok{$this}\NormalTok{->createNotFoundException}\OtherTok{(}
                \StringTok{'No student found for id '}\NormalTok{.}\KeywordTok{$id}
            \OtherTok{);}
\NormalTok{        \}}

        \KeywordTok{$student}\NormalTok{->setFirstName}\OtherTok{(}\KeywordTok{$newFirstName}\OtherTok{);}
        \KeywordTok{$student}\NormalTok{->setSurname}\OtherTok{(}\KeywordTok{$newSurname}\OtherTok{);}
        \KeywordTok{$em}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'homepage'}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Until we write an error handler we'll get Symfony style exception pages,
such as shown in Figure \ref{no_student_exception} when trying to update
a non-existent student with id=99.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/853af1a5f83374e71ec3d4bc9dfa20b84e661e85.png}
\caption{Listing all database student records with route
\texttt{/students/list}. \label{no_student_exception}}
\end{figure}

Note, to illustrate a few more aspects of Symfony some of the coding in
\texttt{update()} has been written a little differently:

\begin{itemize}
\tightlist
\item
  we are getting the reference to the repository via the entity manager
  \texttt{\$em-\textgreater{}getRepository(\textquotesingle{}App:Student\textquotesingle{})}
\item
  we are `chaining' the \texttt{find(\$id)} method call onto the end of
  the code to get a reference to the repository (rather than storing the
  repository object reference and then invoking \texttt{find(\$id)}).
  This is an example of using the `fluent' interface\footnote{read about
    it at
    \href{https://en.wikipedia.org/wiki/Fluent_interface}{Wikipedia}}
  offered by Doctrine (where methods finish by returning an reference to
  their object, so that a sequence of method calls can be written in a
  single statement.
\item
  rather than returning a \texttt{Response} containing a message, this
  controller method redirect the webapp to the route named
  \texttt{homepage}
\end{itemize}

We should also add the `no student for id' test in our \texttt{delete()}
method \ldots{}

\hypertarget{updating-our-show-action}{%
\section{Updating our show action}\label{updating-our-show-action}}

We can now update our code in our \texttt{show(...)} to retrieve the
record from the database:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ show}\OtherTok{(}\KeywordTok{$id}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$em}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{();}
        \KeywordTok{$student}\NormalTok{ = }\KeywordTok{$em}\NormalTok{->getRepository}\OtherTok{(}\StringTok{'App:Student'}\OtherTok{)}\NormalTok{->find}\OtherTok{(}\KeywordTok{$id}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

So our full method for the show action looks as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/student/\{id\}",}\CommentTok{ name="student_show")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ shown}\OtherTok{(}\KeywordTok{$id}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$em}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{();}
        \KeywordTok{$student}\NormalTok{ = }\KeywordTok{$em}\NormalTok{->getRepository}\OtherTok{(}\StringTok{'App:Student'}\OtherTok{)}\NormalTok{->find}\OtherTok{(}\KeywordTok{$id}\OtherTok{);}

        \KeywordTok{$template}\NormalTok{ = }\StringTok{'student/show.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
            \StringTok{'student'}\NormalTok{ => }\KeywordTok{$student}
        \OtherTok{];}

        \KeywordTok{if} \OtherTok{(}\NormalTok{!}\KeywordTok{$student}\OtherTok{)}\NormalTok{ \{}
            \KeywordTok{$template}\NormalTok{ = }\StringTok{'error/404.html.twig'}\OtherTok{;}
\NormalTok{        \}}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

We could, if we wish, throw a 404 error exception if no student records
can be found for the given id, rather than rendering an error Twig
template:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{if} \OtherTok{(}\NormalTok{!}\KeywordTok{$student}\OtherTok{)}\NormalTok{ \{}
        \KeywordTok{throw} \KeywordTok{$this}\NormalTok{->createNotFoundException}\OtherTok{(}
            \StringTok{'No student found for id '}\NormalTok{.}\KeywordTok{$id}
        \OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{redirecting-to-show-after-createupdate}{%
\section{Redirecting to show after
create/update}\label{redirecting-to-show-after-createupdate}}

Keeping everything nice, we should avoid creating one-line and non-HTML
responses like the following in
\texttt{ProductController-\textgreater{}create(...)}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{return} \KeywordTok{new}\NormalTok{ Response}\OtherTok{(}\StringTok{'Saved new product with id '}\NormalTok{.}\KeywordTok{$product}\NormalTok{->getId}\OtherTok{());}
\end{Highlighting}
\end{Shaded}

Let's go back to the list page after a create or update action. Tell
Symfony to redirect to the \texttt{student\_show} route for

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'student_show'}\OtherTok{,} \OtherTok{[}
        \StringTok{'id'}\NormalTok{ => }\KeywordTok{$student}\NormalTok{->getId}\OtherTok{()}
    \OtherTok{]);}
\end{Highlighting}
\end{Shaded}

e.g.~refactor the \texttt{update()} method to be as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/student/update/\{id\}/\{newFirstName\}/\{newSurname\}")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ update}\OtherTok{(}\KeywordTok{$id}\OtherTok{,} \KeywordTok{$newFirstName}\OtherTok{,} \KeywordTok{$newSurname}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$em}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{();}
        \KeywordTok{$student}\NormalTok{ = }\KeywordTok{$em}\NormalTok{->getRepository}\OtherTok{(}\StringTok{'App:Student'}\OtherTok{)}\NormalTok{->find}\OtherTok{(}\KeywordTok{$id}\OtherTok{);}

        \KeywordTok{if} \OtherTok{(}\NormalTok{!}\KeywordTok{$student}\OtherTok{)}\NormalTok{ \{}
            \KeywordTok{throw} \KeywordTok{$this}\NormalTok{->createNotFoundException}\OtherTok{(}
                \StringTok{'No student found for id '}\NormalTok{.}\KeywordTok{$id}
            \OtherTok{);}
\NormalTok{        \}}

        \KeywordTok{$student}\NormalTok{->setFirstName}\OtherTok{(}\KeywordTok{$newFirstName}\OtherTok{);}
        \KeywordTok{$student}\NormalTok{->setSurname}\OtherTok{(}\KeywordTok{$newSurname}\OtherTok{);}
        \KeywordTok{$em}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'student_show'}\OtherTok{,} \OtherTok{[}
            \StringTok{'id'}\NormalTok{ => }\KeywordTok{$student}\NormalTok{->getId}\OtherTok{()}
        \OtherTok{]);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{given-id-let-doctrine-find-product-automatically-project-db03}{%
\section{\texorpdfstring{Given \texttt{id} let Doctrine find Product
automatically (project
\texttt{db03})}{Given id let Doctrine find Product automatically (project db03)}}\label{given-id-let-doctrine-find-product-automatically-project-db03}}

One of the features added when we installed the \texttt{annotations}
bundle was the \textbf{Param Converter}. Perhaps the most used param
converter is when we can substitute an entity \texttt{id} for a
reference to the entity itself.

We can simplify our \texttt{show(...)} from:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/student/\{id\}",}\CommentTok{ name="student_show")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ show}\OtherTok{(}\KeywordTok{$id}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$em}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{();}
        \KeywordTok{$student}\NormalTok{ = }\KeywordTok{$em}\NormalTok{->getRepository}\OtherTok{(}\StringTok{'App:Student'}\OtherTok{)}\NormalTok{->find}\OtherTok{(}\KeywordTok{$id}\OtherTok{);}

        \KeywordTok{$template}\NormalTok{ = }\StringTok{'student/show.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
            \StringTok{'student'}\NormalTok{ => }\KeywordTok{$student}
        \OtherTok{];}

        \KeywordTok{if} \OtherTok{(}\NormalTok{!}\KeywordTok{$student}\OtherTok{)}\NormalTok{ \{}
            \KeywordTok{$template}\NormalTok{ = }\StringTok{'error/404.html.twig'}\OtherTok{;}
\NormalTok{        \}}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

to just:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/student/\{id\}",}\CommentTok{ name="student_show")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ show}\OtherTok{(}\NormalTok{Student }\KeywordTok{$student}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$template}\NormalTok{ = }\StringTok{'student/show.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
            \StringTok{'student'}\NormalTok{ => }\KeywordTok{$student}
        \OtherTok{];}

        \KeywordTok{if} \OtherTok{(}\NormalTok{!}\KeywordTok{$student}\OtherTok{)}\NormalTok{ \{}
            \KeywordTok{$template}\NormalTok{ = }\StringTok{'error/404.html.twig'}\OtherTok{;}
\NormalTok{        \}}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

The Param-Converter will use the Doctrine ORM to go off, find the
\texttt{ProductRepository}, run a
\texttt{find(\textless{}id\textgreater{})} query, and return the
retrieved object for us!

Note - if there is no record in the database corresponding to the
\texttt{id} then a 404-not-found error page will be generated.

Learn more about the Param-Converter on the Symfony documentation pages:

\begin{itemize}
\item
  \url{https://symfony.com/doc/current/doctrine.html\#automatically-fetching-objects-paramconverter}
\item
  \url{http://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/converters.html}
\end{itemize}

Likewise for delete action:

\begin{Shaded}
\begin{Highlighting}[]
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/student/delete/\{id\}")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ delete}\OtherTok{(}\NormalTok{Student }\KeywordTok{$student}\OtherTok{)}
\NormalTok{        \{}
            \CommentTok{// entity manager}
            \KeywordTok{$em}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{();}

            \CommentTok{// store ID before deleting, so can report ID later}
            \KeywordTok{$id}\NormalTok{ = }\KeywordTok{$student}\NormalTok{->getId}\OtherTok{();}

            \CommentTok{// tells Doctrine you want to (eventually) delete the Student (no queries yet)}
            \KeywordTok{$em}\NormalTok{->remove}\OtherTok{(}\KeywordTok{$student}\OtherTok{);}

            \CommentTok{// actually executes the queries (i.e. the DELETE query)}
            \KeywordTok{$em}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}

            \KeywordTok{return} \KeywordTok{new}\NormalTok{ Response}\OtherTok{(}\StringTok{'Deleted student with id = '}\NormalTok{. }\KeywordTok{$id}\OtherTok{);}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}

Likewise for update action:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/student/update/\{id\}/\{newFirstName\}/\{newSurname\}")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ update}\OtherTok{(}\NormalTok{Student }\KeywordTok{$student}\OtherTok{,} \KeywordTok{$newFirstName}\OtherTok{,} \KeywordTok{$newSurname}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$em}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{();}

        \KeywordTok{$student}\NormalTok{->setFirstName}\OtherTok{(}\KeywordTok{$newFirstName}\OtherTok{);}
        \KeywordTok{$student}\NormalTok{->setSurname}\OtherTok{(}\KeywordTok{$newSurname}\OtherTok{);}
        \KeywordTok{$em}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'student_show'}\OtherTok{,} \OtherTok{[}
            \StringTok{'id'}\NormalTok{ => }\KeywordTok{$student}\NormalTok{->getId}\OtherTok{()}
        \OtherTok{]);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

NOTE - we will now get ParamConverter errors rather than 404 errors if
no record matches ID through \ldots{}

\hypertarget{creating-the-crud-controller-automatically-from-the-cli-project-db04}{%
\section{\texorpdfstring{Creating the CRUD controller automatically from
the CLI (project
\texttt{db04})}{Creating the CRUD controller automatically from the CLI (project db04)}}\label{creating-the-crud-controller-automatically-from-the-cli-project-db04}}

Here is something you might want to look into - automatic generation of
controllers and Twig templates (we'll look at this in more detail in a
later chapter).

NOTE: If trying out thew CRUD generation below, then make a copy of your
current project, and try this out on the copy. Then discard the copy, so
you can carry on working on your student project in the next chapter.

To try this out do the following:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Delete the \texttt{StudentController} class, since we'll be generating
  one automatically
\item
  Delete the \texttt{templates/student} directory, since we'll be
  generating those templates automatically
\item
  Then use the make crud command:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:crud Student}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

You should see the following output in the CLI:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:crud Student}
    
     \ExtensionTok{created}\NormalTok{: src/Controller/StudentController.php}
     \ExtensionTok{created}\NormalTok{: src/Form/Student1Type.php}
     \ExtensionTok{created}\NormalTok{: templates/student/_delete_form.html.twig}
     \ExtensionTok{created}\NormalTok{: templates/student/_form.html.twig}
     \ExtensionTok{created}\NormalTok{: templates/student/edit.html.twig}
     \ExtensionTok{created}\NormalTok{: templates/student/index.html.twig}
     \ExtensionTok{created}\NormalTok{: templates/student/new.html.twig}
     \ExtensionTok{created}\NormalTok{: templates/student/show.html.twig}
                   
      \ExtensionTok{Success}\NormalTok{! }
                   
     \ExtensionTok{Next}\NormalTok{: Check your new CRUD by going to /student/}
\end{Highlighting}
\end{Shaded}

You should find that you have now forms for creating and editing Student
records, and controller routes for listing and showing records, and Twig
templates to support all of this\ldots{}

NOTE: As usualy, if you get any messages about `Route not found' or
whatever, you need to delete the \texttt{/var/cache} \ldots{}

\hypertarget{fixtures---setting-up-a-database-state}{%
\chapter{\texorpdfstring{Fixtures - setting up a database state
\label{chapter_fixtures}}{Fixtures - setting up a database state }}\label{fixtures---setting-up-a-database-state}}

\hypertarget{initial-values-for-your-project-database-project-db05}{%
\section{\texorpdfstring{Initial values for your project database
(project
\texttt{db05})}{Initial values for your project database (project db05)}}\label{initial-values-for-your-project-database-project-db05}}

Fixtures play two roles:

\begin{itemize}
\tightlist
\item
  inserting initial values into your database (e.g.~the first
  \texttt{admin} user)
\item
  setting up the database to a known state for \textbf{testing} purposes
\end{itemize}

Doctrine provides a Symfony fixtures \textbf{bundle} that makes things
very straightforward.

Learn more about Symfony fixtures at:

\begin{itemize}
\tightlist
\item
  \href{https://symfony.com/doc/master/bundles/DoctrineFixturesBundle/index.html}{Symfony
  website fixtures page}
\end{itemize}

\hypertarget{installing-and-registering-the-fixtures-bundle}{%
\section{Installing and registering the fixtures
bundle}\label{installing-and-registering-the-fixtures-bundle}}

\hypertarget{install-the-bundle}{%
\subsection{Install the bundle}\label{install-the-bundle}}

Use Composer to install the bunder in the the \texttt{/vendor}
directory:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{composer}\NormalTok{ req orm-fixtures}
\end{Highlighting}
\end{Shaded}

You should now see a new directory created \texttt{/src/DataFixtures}.
Also there is a sample fixtures class provided \texttt{AppFixtures}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php}
    
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}DataFixtures}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}Bundle\textbackslash{}FixturesBundle\textbackslash{}Fixture}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}Common\textbackslash{}Persistence\textbackslash{}ObjectManager}\OtherTok{;}
    
    \KeywordTok{class}\NormalTok{ AppFixtures }\KeywordTok{extends}\NormalTok{ Fixture}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ load}\OtherTok{(}\NormalTok{ObjectManager }\KeywordTok{$manager}\OtherTok{)}
\NormalTok{        \{}
            \CommentTok{// $product = new Product();}
            \CommentTok{// $manager->persist($product);}
    
            \KeywordTok{$manager}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{writing-the-fixture-classes}{%
\section{Writing the fixture
classes}\label{writing-the-fixture-classes}}

We need to locate our fixtures in our \texttt{/src} directory, inside a
\texttt{/DataFixtures} directory. The path for our data fixtures classes
should be \texttt{/src/DataFixtures/}.

Fixture classes need to implement the interfaces, \texttt{Fixture}.

NOTE: Some fixtures will also require your class to include the
\texttt{ContainerAwareInterface}, for when our code also needs to access
the container,by implementing the \texttt{ContainerAwareInterface}.

Let's write a class to create 3 objects for entity
\texttt{App\textbackslash{}Entity\textbackslash{}Student.\ The\ class\ will\ be\ declared\ in\ file}/src/DataFixtures/StudentFixtures.php\texttt{.\ Make\ a\ copy\ of\ the\ provided}AppFixtures\texttt{class\ naming\ the\ copy}StudentFixtures`,
and change the class name inside the code.

We also need to add a \texttt{use} statement so that our class can make
use of the \texttt{Entity\textbackslash{}Student} class.

The \textbf{make} feature will create a skeleton fixture class for us.
So let's make class \texttt{StudentFixtures}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:fixtures StudentFixtures}
    
     \ExtensionTok{created}\NormalTok{: src/DataFixtures/StudentFixtures.php}
    
      \ExtensionTok{Success}\NormalTok{! }
               
     \ExtensionTok{Next}\NormalTok{: Open your new fixtures class and start customizing it.}
     \ExtensionTok{Load}\NormalTok{ your fixtures by running: php bin/console doctrine:fixtures:load}
     \ExtensionTok{Docs}\NormalTok{: https://symfony.com/doc/master/bundles/DoctrineFixturesBundle/index.html}
\end{Highlighting}
\end{Shaded}

Since we are going to be creating instance-objects of class
\texttt{Student} we need to add a \texttt{use} statement:

\begin{Shaded}
\begin{Highlighting}[]
    \StringTok{...}
    
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Entity\textbackslash{}Student}\OtherTok{;}
    
    \KeywordTok{class}\NormalTok{ StudentFixtures }\KeywordTok{extends}\NormalTok{ Fixture}
\NormalTok{    \{}
\end{Highlighting}
\end{Shaded}

Now we need to implement the details of our \texttt{load(...)} method,
that gets invoked when we are loading fixtures from the CLI. This method
creates objects for the entities we want in our database, and the saves
(persists) them to the database. Finally the \texttt{flush()} method is
invoked, forcing the database to be updated with all queued
new/changed/deleted objects:

In the code below, we create 3 \texttt{Student} objects and have them
persisted to the database.

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ load}\OtherTok{(}\NormalTok{ObjectManager }\KeywordTok{$manager}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$s1}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Student}\OtherTok{();}
        \KeywordTok{$s1}\NormalTok{->setFirstName}\OtherTok{(}\StringTok{'matt'}\OtherTok{);}
        \KeywordTok{$s1}\NormalTok{->setSurname}\OtherTok{(}\StringTok{'smith'}\OtherTok{);}
        \KeywordTok{$s2}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Student}\OtherTok{();}
        \KeywordTok{$s2}\NormalTok{->setFirstName}\OtherTok{(}\StringTok{'joe'}\OtherTok{);}
        \KeywordTok{$s2}\NormalTok{->setSurname}\OtherTok{(}\StringTok{'bloggs'}\OtherTok{);}
        \KeywordTok{$s3}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Student}\OtherTok{();}
        \KeywordTok{$s3}\NormalTok{->setFirstName}\OtherTok{(}\StringTok{'joelle'}\OtherTok{);}
        \KeywordTok{$s3}\NormalTok{->setSurname}\OtherTok{(}\StringTok{'murph'}\OtherTok{);}

        \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$s1}\OtherTok{);}
        \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$s2}\OtherTok{);}
        \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$s3}\OtherTok{);}

        \KeywordTok{$manager}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{loading-the-fixtures}{%
\section{Loading the fixtures}\label{loading-the-fixtures}}

\textbf{WARNING} Fixtures \textbf{replace} existing DB contents - so
you'll lose any previous data when you load fixtures\ldots{}

Loading fixtures involves deleting all existing database contents and
then creating the data from the fixture classes - so you'll get a
warning when loading fixtures. At the CLI type:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{php}\NormalTok{ bin/console doctrine:fixtures:load}
\end{Highlighting}
\end{Shaded}

You should then be asked to enter \texttt{y} (for YES) if you want to
continue:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console doctrine:fixtures:load}

    \ExtensionTok{Careful}\NormalTok{, database will be purged. Do you want to continue y/N ?y}
      \OperatorTok{>} \ExtensionTok{purging}\NormalTok{ database}
      \OperatorTok{>} \ExtensionTok{loading}\NormalTok{ App\textbackslash{}DataFixtures\textbackslash{}LoadStudents}
\end{Highlighting}
\end{Shaded}

Figure \ref{load_fixtures} shows an example of the CLI output when you
load fixtures (in the screenshot it was for initial user data for a
login system\ldots{})

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/037fd755ae5f5ab98381734496109ca96f310c3a.png}
\caption{Using CLI to load database fixtures. \label{load_fixtures}}
\end{figure}

Alternatively, you could execute an SQL query from the CLI using the
\texttt{doctrine:query:sql} command:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console doctrine:query:sql }\StringTok{"select * from student"}

    \ExtensionTok{/.../db06_fixtures/vendor/doctrine/common/lib/Doctrine/Common/Util}\NormalTok{/Debug.php:}\ExtensionTok{71}\NormalTok{:}
    \ExtensionTok{array}\NormalTok{ (size=3)}
      \ExtensionTok{0}\NormalTok{ =}\OperatorTok{>}
        \ExtensionTok{array}\NormalTok{ (size=3)}
          \StringTok{'id'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'13'}\NormalTok{ (length=2)}
          \StringTok{'first_name'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'matt'}\NormalTok{ (length=4)}
          \StringTok{'surname'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'smith'}\NormalTok{ (length=5)}
      \ExtensionTok{1}\NormalTok{ =}\OperatorTok{>}
        \ExtensionTok{array}\NormalTok{ (size=3)}
          \StringTok{'id'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'14'}\NormalTok{ (length=2)}
          \StringTok{'first_name'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'joe'}\NormalTok{ (length=3)}
          \StringTok{'surname'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'bloggs'}\NormalTok{ (length=6)}
      \ExtensionTok{2}\NormalTok{ =}\OperatorTok{>}
        \ExtensionTok{array}\NormalTok{ (size=3)}
          \StringTok{'id'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'15'}\NormalTok{ (length=2)}
          \StringTok{'first_name'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'joelle'}\NormalTok{ (length=6)}
          \StringTok{'surname'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'murph'}\NormalTok{ (length=5)}
\end{Highlighting}
\end{Shaded}

\hypertarget{user-faker-to-generate-plausible-test-data-project-db06}{%
\section{\texorpdfstring{User Faker to generate plausible test data
(project
\texttt{db06})}{User Faker to generate plausible test data (project db06)}}\label{user-faker-to-generate-plausible-test-data-project-db06}}

For testing purposes the \texttt{Faker} library is fantastic for
generating plausible, random data.

Let's install it and generate some random students in our Fixtures
class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  use Composer to add the Faker package to our \texttt{/vendor/}
  directory:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ req fzaninotto/faker}

    \ExtensionTok{Using}\NormalTok{ version ^1.7 for fzaninotto/faker}
    \ExtensionTok{./composer.json}\NormalTok{ has been updated}
    \ExtensionTok{Loading}\NormalTok{ composer repositories with package information}
    \ExtensionTok{...}
    \ExtensionTok{Executing}\NormalTok{ script assets:install --symlink --relative public [OK]}
\end{Highlighting}
\end{Shaded}
\item
  Add a \texttt{uses} statement in our
  \texttt{/src/DataFixtures/LoadStudents.php} class, so that we can make
  use of the \texttt{Faker} class:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{use}\NormalTok{ Faker\textbackslash{}Factory}\OtherTok{;}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  refactor our \texttt{load()} method in
  \texttt{/src/DataFixtures/LoadStudents.php} to create a Faker
  `factory', and loop to generate names for 10 male students, and insert
  them into the database:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ load}\OtherTok{(}\NormalTok{ObjectManager }\KeywordTok{$manager}\OtherTok{)}\NormalTok{ \{}
        \KeywordTok{$faker}\NormalTok{ = Factory::create}\OtherTok{();}

        \KeywordTok{$numStudents}\NormalTok{ = }\DecValTok{10}\OtherTok{;}
        \KeywordTok{for} \OtherTok{(}\KeywordTok{$i}\NormalTok{=}\DecValTok{0}\OtherTok{;} \KeywordTok{$i}\NormalTok{ < }\KeywordTok{$numStudents}\OtherTok{;} \KeywordTok{$i}\NormalTok{++}\OtherTok{)}\NormalTok{ \{}
            \KeywordTok{$firstName}\NormalTok{ = }\KeywordTok{$faker}\NormalTok{->firstNameMale}\OtherTok{;}
            \KeywordTok{$surname}\NormalTok{ = }\KeywordTok{$faker}\NormalTok{->lastName}\OtherTok{;}

            \KeywordTok{$student}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Student}\OtherTok{();}
            \KeywordTok{$student}\NormalTok{->setFirstName}\OtherTok{(}\KeywordTok{$firstName}\OtherTok{);}
            \KeywordTok{$student}\NormalTok{->setSurname}\OtherTok{(}\KeywordTok{$surname}\OtherTok{);}

            \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$student}\OtherTok{);}
\NormalTok{        \}}

        \KeywordTok{$manager}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}
\item
  use the CLI Doctrine command to run the fixtures creation method:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console doctrine:fixtures:load}
    \ExtensionTok{Careful}\NormalTok{, database will be purged. Do you want to continue y/N ?y}
      \OperatorTok{>} \ExtensionTok{purging}\NormalTok{ database}
      \OperatorTok{>} \ExtensionTok{loading}\NormalTok{ App\textbackslash{}DataFixtures\textbackslash{}LoadStudents}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

That's it - you should now have 10 `fake' students in your database.

Figure \ref{fake_students} shows a screenshot of the DB client showing
the 10 created `fake' students.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/7031b6bf5e162a6ef9ab7d3ff115b3c0a2ca96cc.png}
\caption{Ten fake students inserted into DB. \label{fake_students}}
\end{figure}

Learn more about the \texttt{Faker} class at its Github project page:

\begin{itemize}
\tightlist
\item
  \url{https://github.com/fzaninotto/Faker}
\end{itemize}

\part{Froms and form processing}

\hypertarget{diy-forms}{%
\chapter{DIY forms}\label{diy-forms}}

\hypertarget{preparation}{%
\section{Preparation}\label{preparation}}

This project assumes you are working with a copy of project
\texttt{db03} - i.e.~with a D.I.Y. controller and templates.

You can start with a copy from the book Github repositories if you wish:
-
\url{https://github.com/dr-matt-smith/php-symfony-5-book-codes-databases-03-param-converter}

\hypertarget{adding-a-form-for-new-student-creation-project-form01}{%
\section{\texorpdfstring{Adding a form for new Student creation (project
\texttt{form01})}{Adding a form for new Student creation (project form01)}}\label{adding-a-form-for-new-student-creation-project-form01}}

Let's create a DIY (Do-It-Yourself) HTML form to create a new student.
We'll need:

\begin{itemize}
\item
  a controller method (and template) to display our new student form

  \begin{itemize}
  \item
    route \texttt{/student/new}

    \begin{itemize}
    \tightlist
    \item
      with internal route name \texttt{student\_new\_form}
    \end{itemize}
  \end{itemize}
\item
  a controller method to process the submitted form data

  \begin{itemize}
  \item
    route \texttt{/student/processNewForm}

    \begin{itemize}
    \tightlist
    \item
      with internal route name \texttt{student\_process\_new\_form}
    \end{itemize}
  \end{itemize}
\end{itemize}

The form will look as show in Figure \ref{new_student_form}.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/47fb9483958661b9823335391996ce0741d76a07.png}
\caption{Form for a new student \label{new_student_form}}
\end{figure}

\hypertarget{refacfor-our-create...-method}{%
\section{\texorpdfstring{Refacfor our \texttt{create(...)}
method}{Refacfor our create(...) method}}\label{refacfor-our-create...-method}}

Since we will now be creating new Students using a form, rather than
passing the properties directly as \texttt{GET} partameters in thge URL,
let's refactor our \texttt{create(...)} in class
\texttt{StudentController} to be a private method (no route annotatiohn
comment), that accepts 2 parameters and uses them to create a new
Student obnject and store it in the database, then redirect to the list
of students page:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{private} \KeywordTok{function}\NormalTok{ create}\OtherTok{(}\KeywordTok{$firstName}\OtherTok{,} \KeywordTok{$surname}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$student}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Student}\OtherTok{();}
        \KeywordTok{$student}\NormalTok{->setFirstName}\OtherTok{(}\KeywordTok{$firstName}\OtherTok{);}
        \KeywordTok{$student}\NormalTok{->setSurname}\OtherTok{(}\KeywordTok{$surname}\OtherTok{);}
    
        \KeywordTok{$em}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{();}
        \KeywordTok{$em}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$student}\OtherTok{);}
        \KeywordTok{$em}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}
    
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'student_list'}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{twig-new-student-form}{%
\section{Twig new student form}\label{twig-new-student-form}}

Here is our new student form `/templates/student/new.html.twig':

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    \{% extends 'base.html.twig' %\}}

\NormalTok{    \{% block pageTitle %\}new student form\{% endblock %\}}

\NormalTok{    \{% block body %\}}
        \KeywordTok{<h1>}\NormalTok{Create new student}\KeywordTok{</h1>}

        \KeywordTok{<form}\OtherTok{ action=}\StringTok{"/student/processNewForm"}\OtherTok{ method=}\StringTok{"POST"}\KeywordTok{>}
\NormalTok{                First Name:}
                \KeywordTok{<input}\OtherTok{ type=}\StringTok{"text"}\OtherTok{ name=}\StringTok{"firstName"}\KeywordTok{>}
            \KeywordTok{<p>}
\NormalTok{                Surname:}
                \KeywordTok{<input}\OtherTok{ type=}\StringTok{"text"}\OtherTok{ name=}\StringTok{"surname"}\KeywordTok{>}
            \KeywordTok{<p>}
                \KeywordTok{<input}\OtherTok{ type=}\StringTok{"submit"}\OtherTok{ value=}\StringTok{"Create new student"}\KeywordTok{>}
        \KeywordTok{</form>}
\NormalTok{    \{% endblock %\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{controller-method-and-annotation-to-display-new-student-form}{%
\section{Controller method (and annotation) to display new student
form}\label{controller-method-and-annotation-to-display-new-student-form}}

Let's add a \textbf{new} action to \texttt{StudentController}.

NOTE: This should be \textbf{the FIRST} method in this class - Since we
don't want \texttt{/student/new} being treated as
\texttt{/student/\{id\ =\ \textquotesingle{}new\textquotesingle{}\}}, so
our new form action method should be placed before our show action.
\texttt{\textless{}\textless{}\textless{}\textless{}\textless{}\textless{}\textless{}\textless{}}

Here is our \texttt{StudentController} method \texttt{newForm()} to
display our Twig form:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/student/new",}\CommentTok{ name="student_new")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ newForm}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{$template}\NormalTok{ = }\StringTok{'student/new.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
        \OtherTok{];}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

We'll also add a link to this form route in our list of students page.
So we add to the end of \texttt{/templates/student/list.html.twig} the
following link:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{        (... existing Twig code to show list of students here ...)}

        \KeywordTok{<hr>}
        \KeywordTok{<a}\OtherTok{ href=}\StringTok{"\{\{ path('student_new_form')\}\}"}\KeywordTok{>}
\NormalTok{            create NEW student}
        \KeywordTok{</a>}
\NormalTok{    \{% endblock %\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{controller-method-to-process-post-form-data}{%
\section{Controller method to process POST form
data}\label{controller-method-to-process-post-form-data}}

We can access POST submitted data using the following expression:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\NormalTok{<}\KeywordTok{POST_VAR_NAME}\NormalTok{>}\OtherTok{)}
\end{Highlighting}
\end{Shaded}

So we can extract and store in \texttt{\$firstName} and
\texttt{\$surname} the POST \texttt{firstName} and \texttt{surname}
parameters by writing the following:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$firstName}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'firstName'}\OtherTok{);}
    \KeywordTok{$surname}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'surname'}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

We will need access to the HTTP request, so we must declare a method
parameter of \texttt{Request\ \$request}. Symfony will now automatically
provide this method with access to an object \texttt{\$request}, which
we can interrogate for things like the HTTP method of the request, and
any name/value variables received in the request:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ processNewFormAction}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}
\NormalTok{    \{}
\end{Highlighting}
\end{Shaded}

Note: We have not \textbf{namespaced} class \texttt{Request}, so, at the
top of our controller class declaration, we need to add an appropriate
\texttt{use} statement, so PHP knows \textbf{which} \texttt{Request}
class we are referring to. So we need to add the following before the
class declaration:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Request}\OtherTok{;}
\end{Highlighting}
\end{Shaded}

Our full listing for \texttt{StudentController} method
\texttt{processNewForm()} looks as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/student/processNewForm",}\CommentTok{ name="student_process_new_form")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ processNewForm}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}
\NormalTok{    \{}
        \CommentTok{// extract name values from POST data}
        \KeywordTok{$firstName}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'firstName'}\OtherTok{);}
        \KeywordTok{$surname}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'surname'}\OtherTok{);}

        \CommentTok{// forward this to the createAction() method}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->create}\OtherTok{(}\KeywordTok{$firstName}\OtherTok{,} \KeywordTok{$surname}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

NOTE: that we then invoke our existing \texttt{createAction(...)}
method, passing on the extracted \texttt{\$firsName} and
\texttt{\$surname} strings.

NOTE: This should be \textbf{the FIRST} method in this class (or at
least before the \textbf{show} method )- Since we don't want
\texttt{/student/processNewForm} being treated as
\texttt{/student/\{id\ =\ \textquotesingle{}new\textquotesingle{}\}}, so
our new form action method should be placed before our show action. If
you get a Param Converter exception Student object not found you put
this method \textbf{after} the show method\ldots{}
\texttt{\textless{}\textless{}\textless{}\textless{}\textless{}\textless{}\textless{}\textless{}}

\hypertarget{validating-form-data-and-displaying-temporary-flash-messages-in-twig}{%
\section{Validating form data, and displaying temporary `flash' messages
in
Twig}\label{validating-form-data-and-displaying-temporary-flash-messages-in-twig}}

What should we do if an empty name string was submitted? We need to
\textbf{validate} form data, and inform the user if there was a problem
with their data.

Symfony offers a very useful feature called the `flash bag'. Flash data
exists for just 1 request and is then deleted from the session. So we
can create an error message to be display (if present) by Twig, and we
know some future request to display the form will no have that error
message in the session any more.

\hypertarget{three-kinds-of-flash-message-notice-warning-and-error}{%
\section{Three kinds of flash message: notice, warning and
error}\label{three-kinds-of-flash-message-notice-warning-and-error}}

Typically we create 3 different kinds of flash notice:

\begin{itemize}
\tightlist
\item
  notice
\item
  warning
\item
  error
\end{itemize}

Our Twig template would style these differntly (e.g.~pink background for
errors etc.). Here is how to creater a flash message and have it stored
(for 1 request) in the session:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$this}\NormalTok{->addFlash}\OtherTok{(}
            \StringTok{'error'}\OtherTok{,}
            \StringTok{'Your changes were saved!'}
        \OtherTok{);}
\end{Highlighting}
\end{Shaded}

In Twig we can attempt to retrieve flash messages in the following way:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    \{% for flash_message in app.session.flashBag.get('notice') %\}}
        \KeywordTok{<div}\OtherTok{ class=}\StringTok{"flash-notice"}\KeywordTok{>}
\NormalTok{            \{\{ flash_message \}\}}
        \KeywordTok{</div>}
\NormalTok{    \{% endfor %\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{adding-flash-display-with-css-to-our-twig-template-project-form02}{%
\section{\texorpdfstring{Adding flash display (with CSS) to our Twig
template (project
\texttt{form02})}{Adding flash display (with CSS) to our Twig template (project form02)}}\label{adding-flash-display-with-css-to-our-twig-template-project-form02}}

First let's create a CSS stylesheet and ensure it is always loaded by
adding its import into our \texttt{base.html.twig} template.

First create the directory \texttt{css} in \texttt{/public} - remember
that \texttt{/public} is the Symfony public folder, where all public
images, CSS, javascript and basic front controllers (\texttt{app.php}
and \texttt{app\_dev.php}) are served from).

Now create CSS file \texttt{/public/css/flash.css} containing the
following:

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{.flash-error}\NormalTok{ \{}
        \KeywordTok{padding}\NormalTok{: }\DecValTok{1}\DataTypeTok{rem}\OperatorTok{;}
        \KeywordTok{margin}\NormalTok{: }\DecValTok{1}\DataTypeTok{rem}\OperatorTok{;}
        \KeywordTok{background-color}\NormalTok{: }\ConstantTok{pink}\OperatorTok{;}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Next we need to edit our \texttt{/templates/base.html.twig} so that
every page in our webapp will have imported this CSS stylesheet. Edit
the \texttt{\textless{}head\textgreater{}} element in
\texttt{base.html.twig} as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \DataTypeTok{<!DOCTYPE }\NormalTok{html}\DataTypeTok{>}
    \KeywordTok{<html>}
        \KeywordTok{<head>}
            \KeywordTok{<meta}\OtherTok{ charset=}\StringTok{"UTF-8"} \KeywordTok{/>}
            \KeywordTok{<title>}\NormalTok{MGW - \{% block pageTitle %\}\{% endblock %\}}\KeywordTok{</title>}

            \KeywordTok{<style>}
                \ImportTok{@import} \StringTok{'/css/flash.css'}\OperatorTok{;}
            \KeywordTok{</style>}
\NormalTok{            \{% block stylesheets %\}\{% endblock %\}}
        \KeywordTok{</head>}
\end{Highlighting}
\end{Shaded}

\hypertarget{adding-validation-logic-to-our-form-processing-controller-method}{%
\section{Adding validation logic to our form processing controller
method}\label{adding-validation-logic-to-our-form-processing-controller-method}}

Our form data is valid if \textbf{neither} name received was empty:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$isValid}\NormalTok{ = !}\KeywordTok{empty}\OtherTok{(}\KeywordTok{$firstName}\OtherTok{)}\NormalTok{ && !}\KeywordTok{empty}\OtherTok{(}\KeywordTok{$surname}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

Now we can add the empty string test (and flash error message) to our
\texttt{processNewFormn()} method as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ processNewForm}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}
\NormalTok{    \{}
        \CommentTok{// extract name values from POST data}
        \KeywordTok{$firstName}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'firstName'}\OtherTok{);}
        \KeywordTok{$surname}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'surname'}\OtherTok{);}

        \CommentTok{// valid if neither value is EMPTY}
        \KeywordTok{$isValid}\NormalTok{ = !}\KeywordTok{empty}\OtherTok{(}\KeywordTok{$firstName}\OtherTok{)}\NormalTok{ && !}\KeywordTok{empty}\OtherTok{(}\KeywordTok{$surname}\OtherTok{);}
        \KeywordTok{if}\OtherTok{(}\NormalTok{!}\KeywordTok{$isValid}\OtherTok{)}\NormalTok{\{}
            \KeywordTok{$this}\NormalTok{->addFlash}\OtherTok{(}
            \StringTok{'error'}\OtherTok{,}
            \StringTok{'student firstName/surname cannot be an empty string'}
        \OtherTok{);}
            \CommentTok{// forward this to the createAction() method}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->newForm}\OtherTok{();}
\NormalTok{        \}}

        \CommentTok{// forward this to the createAction() method}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->create}\OtherTok{(}\KeywordTok{$firstName}\OtherTok{,} \KeywordTok{$surname}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

So if the \texttt{\$name} we extracted from the POST data is an empty
string, then we add an \texttt{error} flash message into the session
`flash bag', and forward on processing of the request to our method to
display the new student form again.

Finally, we need to add code in our new student form Twig template to
display any error flash messages it finds. So we edit
\texttt{/templates/student/new.html.twig} as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    \{% extends '_base.html.twig' %\}}
\NormalTok{    \{% block pageTitle %\}new student form\{% endblock %\}}

\NormalTok{    \{% block body %\}}

        \KeywordTok{<h1>}\NormalTok{Create new student}\KeywordTok{</h1>}

\NormalTok{        \{% for flash_message in app.session.flashBag.get('error') %\}}
            \KeywordTok{<div}\OtherTok{ class=}\StringTok{"flash-error"}\KeywordTok{>}
\NormalTok{                \{\{ flash_message \}\}}
            \KeywordTok{</div>}
\NormalTok{        \{% endfor %\}}

\NormalTok{        (... show HTML form as before ...)}
\end{Highlighting}
\end{Shaded}

\hypertarget{postback-logic-project-form03}{%
\section{\texorpdfstring{Postback logic (project
\texttt{form03})}{Postback logic (project form03)}}\label{postback-logic-project-form03}}

A common approach (and used in CRUD auto-generated code) is to combine
the logic for displaying a form, and processing its submission, in a
single method. The logic for this is that if any of the submitted data
was invalid (or missing), then the default form processing can go back
to re-displaying the form (with an appropriate `flash' error message) to
the user.

This approach is known as a `postback' - i.e.~that the submission of the
form is POSTEd back to the same method that displayed the form.

The logic usually goes something like this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define a controller method route for both \texttt{GET} and
  \texttt{POST} HTTP methods
\item
  Attempt to find values in the \texttt{POST} request body
\item
  If the form was submitted by the \texttt{POST} method AND the data was
  all valid THEN

  \begin{itemize}
  \tightlist
  \item
    invoke the method to create the object/process the data and retuurn
    an appropriate success response
  \end{itemize}
\item
  (else) If POST submitted but NOT valid THEN

  \begin{itemize}
  \tightlist
  \item
    create an appropriate flash error message in the session
  \end{itemize}
\item
  return a response showing the form via Twig \texttt{render(...)}
  method

  \begin{itemize}
  \tightlist
  \item
    passing values, if we want a `sticky' form remembering partly valid
    form values
  \end{itemize}
\end{enumerate}

Let's name our combined show form \& process form controller method
\texttt{newAction(...)}, name its internal route as
\texttt{student\_new}, and declare that only \texttt{POST} and
\texttt{GET} HTTP requests are to be routed to this method\footnote{By
  default a controller method that does not declare any specific HTTP
  methods will be used for \textbf{any} HTTP method matching the route
  pattern. So it is good practice to start limiting our controller
  methods to only those HTTP methods that are valid for how we wish our
  web application to behave\ldots{}}:

\begin{Shaded}
\begin{Highlighting}[]

    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/student/new",}\CommentTok{ name="student_new",  methods=\{"POST", "GET"\})}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ newAction}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}
\NormalTok{    \{}
\end{Highlighting}
\end{Shaded}

Remember, we will need access to the \texttt{Request} object to get
access to the POST values, and to check with HTTP method the request was
sent via.

The simplest request will be for the new student form to be displayed,
the logic for that is from our old \texttt{newFormAction()}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{// render the form for the user}
    \KeywordTok{$template}\NormalTok{ = }\StringTok{'student/new.html.twig'}\OtherTok{;}
    \KeywordTok{$argsArray}\NormalTok{ = }\OtherTok{[}
    \OtherTok{];}

    \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$argsArray}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

The rest of the logic in this method will related to when the HTTP
request is POST-submission of the form, and its validation. We can check
whether the HTTP request was received as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$isSubmitted}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->isMethod}\OtherTok{(}\StringTok{'POST'}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

We can attempt to retrieve values from a POST submitted form as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{// attempt to find values in POST variables}
    \KeywordTok{$firstName}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'firstName'}\OtherTok{);}
    \KeywordTok{$surname}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'surname'}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

Note: If there was no named variable in the POST data, the variables
\texttt{\$firstName} and \texttt{\$surnamne} will return \texttt{null}
(and so will register as \texttt{true} when tested with
\texttt{isEmpty(...)}).

If our form validation logic is simply that neither name can be an empty
string (or null), then we can write an expression to check that neither
is empty as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$isValid}\NormalTok{ = !}\KeywordTok{empty}\OtherTok{(}\KeywordTok{$firstName}\OtherTok{)}\NormalTok{ && !}\KeywordTok{empty}\OtherTok{(}\KeywordTok{$surname}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

Our core logic for this controller is that \textbf{if} the request was
an HTTP \texttt{POST} method \textbf{and} the values received were
value, then we are happy to accept the form data and go off an create a
new object (and return an appropriate response). We can write this as
follows:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{// if SUBMITTED & VALID - go ahead and create new object}
    \KeywordTok{if} \OtherTok{(}\KeywordTok{$isSubmitted}\NormalTok{ && }\KeywordTok{$isValid}\OtherTok{)}\NormalTok{ \{}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->createAction}\OtherTok{(}\KeywordTok{$firstName}\OtherTok{,} \KeywordTok{$surname}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

NOTE: Since our method is invoking a \texttt{return}, then no further
processing of statements in the method will occur. I.e. we can locate
our logic for (re)displaying the form after this \texttt{if}-test.

If it was a \texttt{POST} submitted form but the data was \textbf{not}
valid, then we should create a `flash' error message in the session:

\begin{Shaded}
\begin{Highlighting}[]
   \KeywordTok{if} \OtherTok{(}\KeywordTok{$isSubmitted}\NormalTok{ && !}\KeywordTok{$isValid}\OtherTok{)}\NormalTok{ \{}
        \KeywordTok{$this}\NormalTok{->addFlash}\OtherTok{(}
            \StringTok{'error'}\OtherTok{,}
            \StringTok{'student firstName/surname cannot be an empty string'}
        \OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

We can now simply replace the previous 2 methods
\texttt{processNewFormAction()} and \texttt{newFormAction()} with our
new single postback method \texttt{new(...)} as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/student/new",}\CommentTok{ name="student_new_form", methods=\{"POST", "GET"\})}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function} \KeywordTok{new}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}\NormalTok{ \{}
        \CommentTok{// attempt to find values in POST variables}
        \KeywordTok{$firstName}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'firstName'}\OtherTok{);}
        \KeywordTok{$surname}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'surname'}\OtherTok{);}

        \CommentTok{// valid if neither value is EMPTY}
        \KeywordTok{$isValid}\NormalTok{ = !}\KeywordTok{empty}\OtherTok{(}\KeywordTok{$firstName}\OtherTok{)}\NormalTok{ && !}\KeywordTok{empty}\OtherTok{(}\KeywordTok{$surname}\OtherTok{);}

        \CommentTok{// was form submitted with POST method?}
        \KeywordTok{$isSubmitted}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->isMethod}\OtherTok{(}\StringTok{'POST'}\OtherTok{);}

        \CommentTok{// if SUBMITTED & VALID - go ahead and create new object}
        \KeywordTok{if} \OtherTok{(}\KeywordTok{$isSubmitted}\NormalTok{ && }\KeywordTok{$isValid}\OtherTok{)}\NormalTok{ \{}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->create}\OtherTok{(}\KeywordTok{$firstName}\OtherTok{,} \KeywordTok{$surname}\OtherTok{);}
\NormalTok{        \}}

        \KeywordTok{if} \OtherTok{(}\KeywordTok{$isSubmitted}\NormalTok{ && !}\KeywordTok{$isValid}\OtherTok{)}\NormalTok{ \{ }\KeywordTok{$this}\NormalTok{->addFlash}\OtherTok{(}
            \StringTok{'error'}\OtherTok{,}
            \StringTok{'student firstName/surname cannot be an empty string'}
        \OtherTok{);}
\NormalTok{        \}}
        \CommentTok{// render the form for the user}
        \KeywordTok{$template}\NormalTok{ = }\StringTok{'student/new.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
            \StringTok{'firstName'}\NormalTok{ => }\KeywordTok{$firstName}\OtherTok{,}
            \StringTok{'surname'}\NormalTok{ => }\KeywordTok{$surname}
        \OtherTok{];}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Finally (!) we can achieve a `sticky' form by passing any value in
\texttt{\$firstName} and \texttt{\$surname} to our Twig template in its
argument array:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$argsArray}\NormalTok{ = }\OtherTok{[}
        \StringTok{'firstName'}\NormalTok{ => }\KeywordTok{$firstName}\OtherTok{,}
        \StringTok{'surname'}\NormalTok{ => }\KeywordTok{$surname}
    \OtherTok{];}
\end{Highlighting}
\end{Shaded}

These will either be null, or have the string values from the POST
submitted form attempt. We re-display these values (if no null) by
adding \texttt{value=""} attributed in our Twig form template
\texttt{/templates/student/new.html.twig} as follows:

\begin{verbatim}
    <form action="/student/new" method="POST">
            First Name:
            <input type="text" name="firstName" value={{ firstname }}>
        <p>
            Surname:
            <input type="text" name="surname" value={{ surname }}>
        <p>
            <input type="submit" value="Create new student">
    </form>
\end{verbatim}

NOTE: We have \textbf{changed} the form action to
\texttt{"/student/new"}, so that the form POST submission will be routed
to the same method (\texttt{new()}) as the one to display the form.

\hypertarget{extra-notes}{%
\section{Extra notes}\label{extra-notes}}

Here is how to work with Enum style drop-down combo-boxes:

\begin{itemize}
\tightlist
\item
  \href{http://www.maxpou.fr/dealing-with-enum-symfony-doctrine/}{Articled
  on Symfony Enums in forms frmo Maxence POUTORD}
\end{itemize}

\hypertarget{automatic-forms-generated-from-entities}{%
\chapter{Automatic forms generated from
Entities}\label{automatic-forms-generated-from-entities}}

\hypertarget{using-the-symfony-form-generator-project-form04}{%
\section{\texorpdfstring{Using the Symfony form generator (project
\texttt{form04})}{Using the Symfony form generator (project form04)}}\label{using-the-symfony-form-generator-project-form04}}

Given an object of an Entity class, Symfony can analyse its property
names and types, and generate a form (with a little help). That's what
we'll do in this chapter.

However, first, let's simplify something for later, we'll make our
\texttt{createAction()} expect to be given a reference to a
\texttt{Student} object (rather than expect 2 string parameters
\texttt{firstName} and \texttt{surname}):

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ createAction}\OtherTok{(}\NormalTok{Student }\KeywordTok{$student}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$em}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{();}
        \KeywordTok{$em}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$student}\OtherTok{);}
        \KeywordTok{$em}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'student_list'}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-symfony-form-generator-via-twig}{%
\section{The Symfony form generator via
Twig}\label{the-symfony-form-generator-via-twig}}

In a controller we can create a \texttt{\$form} object, and pass this as
a Twig variable to the template \texttt{form}. Twig offers 4 special
functions for rendering (displaying) forms, these are:

\begin{itemize}
\tightlist
\item
  \texttt{form()} :: display the whole form (i.e.~display the whole
  thing in one line!)
\item
  \texttt{form\_start()} :: display the beginning of the form
\item
  \texttt{form\_widget()} :: display all the fields etc.
\item
  \texttt{form\_end()} :: display the end of the form
\end{itemize}

So we can simplify the \texttt{body} block of our Twig template
(\texttt{/app/Resources/views/students/new.html.twig}) for the new
\texttt{Student} form to the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    \{% block body %\}}
        \KeywordTok{<h1>}\NormalTok{Create new student}\KeywordTok{</h1>}
\NormalTok{        \{\{ form(form) \}\}}
\NormalTok{    \{% endblock %\}}
\end{Highlighting}
\end{Shaded}

That's it! No \texttt{\textless{}form\textgreater{}} element, no
\texttt{\textless{}input\textgreater{}}s, no submit button, no labels!
Even flash messages (relating to form validation errors) will be
displayed by this function Twig function (global form errors at the top,
and field specific errors by each form field).

The `magic' happens in the controller method\ldots{}

\hypertarget{updating-studentcontroller-new}{%
\section{\texorpdfstring{Updating
\texttt{StudentController-\textgreater{}new()}}{Updating StudentController-\textgreater{}new()}}\label{updating-studentcontroller-new}}

First, our controller method will need to pass a Twig variable
\texttt{form} to the \texttt{render()} method. This will be created for
us by the \texttt{createView()} method of a Symfony form object. So
\texttt{new()} will end as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$argsArray}\NormalTok{ = }\OtherTok{[}
        \StringTok{'form'}\NormalTok{ => }\KeywordTok{$form}\NormalTok{->createView}\OtherTok{(),}
    \OtherTok{];}

    \KeywordTok{$templateName}\NormalTok{ = }\StringTok{'students/new'}\OtherTok{;}
    \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$templateName}\NormalTok{ . }\StringTok{'.html.twig'}\OtherTok{,} \KeywordTok{$argsArray}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

Our method will use Symfony's FormBuilder to create the form for us,
based on an instance of class \texttt{Student}. First we create a new,
empty \texttt{Student} object, and then use Symfony's
\texttt{createFormBuilder()} method to create a form based on the Entity
class of our \texttt{\$student} object:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function} \KeywordTok{new}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}
\NormalTok{    \{}
        \CommentTok{// create a new Student object}
        \KeywordTok{$student}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Student}\OtherTok{();}

        \CommentTok{// create a form with 'firstName' and 'surname' text fields}
        \KeywordTok{$form}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->createFormBuilder}\OtherTok{(}\KeywordTok{$student}\OtherTok{)}
\NormalTok{            ->add}\OtherTok{(}\StringTok{'firstName'}\OtherTok{,}\NormalTok{ TextType::}\KeywordTok{class}\OtherTok{)}
\NormalTok{            ->add}\OtherTok{(}\StringTok{'surname'}\OtherTok{,}\NormalTok{ TextType::}\KeywordTok{class}\OtherTok{)}
\NormalTok{            ->add}\OtherTok{(}\StringTok{'save'}\OtherTok{,}\NormalTok{ SubmitType::}\KeywordTok{class}\OtherTok{,} \KeywordTok{array}\OtherTok{(}\StringTok{'label'}\NormalTok{ => }\StringTok{'Create Student'}\OtherTok{))}\NormalTok{->getForm}\OtherTok{();}
\end{Highlighting}
\end{Shaded}

Note - for the above code to work we also need to add two \texttt{use}
statements so that PHP knows about the classes \texttt{TextType} and
\texttt{SubmitType}. These can be found in the form extension Symfony
component:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Form\textbackslash{}Extension\textbackslash{}Core\textbackslash{}Type\textbackslash{}TextType}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Form\textbackslash{}Extension\textbackslash{}Core\textbackslash{}Type\textbackslash{}SubmitType}\OtherTok{;}
\end{Highlighting}
\end{Shaded}

We ask Symfony to `handle' the request for us. If the HTTP request was a
POST submission, then the submitted values will be used to populate our
\texttt{\$student} object. Otherwise, if GET method, the form will be an
empty, new form.

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{// if was POST submission, extract data and put into '$student'}
    \KeywordTok{$form}\NormalTok{->handleRequest}\OtherTok{(}\KeywordTok{$request}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

Forms have basic validation. The default for text entity properties is
\texttt{NOT\ NULL}, so both name fields will be validated this way -
both through HTML 5 validation and on the server side. If the form was
submitted (via POST) and is valid, then we'll go ahead and create a new
\texttt{Student} object as before:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{// if SUBMITTED & VALID - go ahead and create new object}
    \KeywordTok{if} \OtherTok{(}\KeywordTok{$form}\NormalTok{->isSubmitted}\OtherTok{()}\NormalTok{ && }\KeywordTok{$form}\NormalTok{->isValid}\OtherTok{())}\NormalTok{ \{}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->createAction}\OtherTok{(}\KeywordTok{$student}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

If not submitted (or not valid), then the logic falls through to
displaying the form via Twig. The full listing for our improved
\texttt{new()} method is as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/student/new",}\CommentTok{ name="student_new",  methods=\{"POST", "GET"\})}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function} \KeywordTok{new}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}
\NormalTok{    \{}
        \CommentTok{// create a task and give it some dummy data for this example}
        \KeywordTok{$student}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Student}\OtherTok{();}

        \CommentTok{// create a form with 'firstName' and 'surname' text fields}
        \KeywordTok{$form}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->createFormBuilder}\OtherTok{(}\KeywordTok{$student}\OtherTok{)}
\NormalTok{            ->add}\OtherTok{(}\StringTok{'firstName'}\OtherTok{,}\NormalTok{ TextType::}\KeywordTok{class}\OtherTok{)}
\NormalTok{            ->add}\OtherTok{(}\StringTok{'surname'}\OtherTok{,}\NormalTok{ TextType::}\KeywordTok{class}\OtherTok{)}
\NormalTok{            ->add}\OtherTok{(}\StringTok{'save'}\OtherTok{,}\NormalTok{ SubmitType::}\KeywordTok{class}\OtherTok{,} \KeywordTok{array}\OtherTok{(}\StringTok{'label'}\NormalTok{ => }\StringTok{'Create Student'}\OtherTok{))}\NormalTok{->getForm}\OtherTok{();}

        \CommentTok{// if was POST submission, extract data and put into '$student'}
        \KeywordTok{$form}\NormalTok{->handleRequest}\OtherTok{(}\KeywordTok{$request}\OtherTok{);}

        \CommentTok{// if SUBMITTED & VALID - go ahead and create new object}
        \KeywordTok{if} \OtherTok{(}\KeywordTok{$form}\NormalTok{->isSubmitted}\OtherTok{()}\NormalTok{ && }\KeywordTok{$form}\NormalTok{->isValid}\OtherTok{())}\NormalTok{ \{}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->createAction}\OtherTok{(}\KeywordTok{$student}\OtherTok{);}
\NormalTok{        \}}

        \CommentTok{// render the form for the user}
        \KeywordTok{$template}\NormalTok{ = }\StringTok{'student/new.html.twig'}\OtherTok{;}
        \KeywordTok{$argsArray}\NormalTok{ = }\OtherTok{[}
            \StringTok{'form'}\NormalTok{ => }\KeywordTok{$form}\NormalTok{->createView}\OtherTok{(),}
        \OtherTok{];}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$argsArray}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

We can see that the method does the following:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  creates a new (empty) \texttt{Student} records `\$students
\item
  creates a new form builder, passing in \texttt{\$student}, and stating
  that we want it to create a HTML form input element for the
  \texttt{name} field, and also a submit button (\texttt{SubmitType})
  with the label \texttt{Create\ Student}. We chain these method calls
  in sequence, making use of the form builder's `fluent' interface, and
  store the created form object in PHP variable \texttt{\$form}.
\item
  Finally, we create a Twig argument array, passing in the form object
  \texttt{\$form} with Twig variable name \texttt{form}, and tell Twig
  to render the template \texttt{student/new.html.twig}.
\end{enumerate}

Figure \ref{form_builder_student_form} shows a screenshot of the
resulting form.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/ed6d8371de7dcb3e493e014fbec0f0051aed1765.png}
\caption{Symfony generated new student form.
\label{form_builder_student_form}}
\end{figure}

\hypertarget{postback---form-submits-to-same-url}{%
\section{Postback - form submits to same
URL}\label{postback---form-submits-to-same-url}}

If we look at the HTML in the source of our web page (see Figure
\ref{form_html}), we can see that the form has no \texttt{action}
attribute, which means that when POST submitted, it will be submitted to
the same URL (i.e.~a our method \texttt{new()}). However, since we've
already written our logic to process a \textbf{post-back} like this,
then our code will work :-)

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/0db6711a872d0c20b95c1795724d81774c2e5c14.png}
\caption{HTML source of generated form \label{form_html}}
\end{figure}

\hypertarget{using-form-classes-project-form05}{%
\section{\texorpdfstring{Using form classes (project
\texttt{form05})}{Using form classes (project form05)}}\label{using-form-classes-project-form05}}

Although simple forms can be created inside a controller method as
above, it's good practice to create a separate from `type' class to
create each form.

Rather than write one from scratch, some of the work can be done for us
using the \textbf{maker} bundle. To create class
\texttt{/src/Form/StudentType.php} we first enter CLI command:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:form}
\end{Highlighting}
\end{Shaded}

You'll then be asked the form class name - by Symmfony convention we
just add \texttt{Type} to the Entity class name:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{The}\NormalTok{ name of the form class (e.g. VictoriousPuppyType)}\BuiltInTok{:}
    \OperatorTok{>} \ExtensionTok{Student}
\end{Highlighting}
\end{Shaded}

You'll then be asked for the Entity name, so we enter \texttt{Student}:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{The}\NormalTok{ name of Entity or fully qualified model class name that the new form will be bound to (empty for none)}\BuiltInTok{:}
    \OperatorTok{>} \ExtensionTok{Student}
\end{Highlighting}
\end{Shaded}

You'll then see output telling us that the make tool has generated Form
class \texttt{StudentType} for us in the \texttt{src/Form/} directory:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{created}\NormalTok{: src/Form/StudentType.php}

    \ExtensionTok{Success}\NormalTok{! }

    \ExtensionTok{Next}\NormalTok{: Add fields to your form and start using it.}
    \ExtensionTok{Find}\NormalTok{ the documentation at https://symfony.com/doc/current/forms.html}
\end{Highlighting}
\end{Shaded}

If we look inside \texttt{/src/Form/StudentType.php} we see a skeleton
class as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Form}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Entity\textbackslash{}Student}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Form\textbackslash{}AbstractType}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Form\textbackslash{}FormBuilderInterface}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}OptionsResolver\textbackslash{}OptionsResolver}\OtherTok{;}
    
    \KeywordTok{class}\NormalTok{ StudentType }\KeywordTok{extends}\NormalTok{ AbstractType}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ buildForm}\OtherTok{(}\NormalTok{FormBuilderInterface }\KeywordTok{$builder}\OtherTok{,} \KeywordTok{array} \KeywordTok{$options}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$builder}
\NormalTok{                ->add}\OtherTok{(}\StringTok{'firstName'}\OtherTok{)}
\NormalTok{                ->add}\OtherTok{(}\StringTok{'surname'}\OtherTok{)}
            \OtherTok{;}
\NormalTok{        \}}
    
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ configureOptions}\OtherTok{(}\NormalTok{OptionsResolver }\KeywordTok{$resolver}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$resolver}\NormalTok{->setDefaults}\OtherTok{([}
                \StringTok{'data_class'}\NormalTok{ => Student::}\KeywordTok{class}\OtherTok{,}
            \OtherTok{]);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

For the \texttt{/Form/StudentType.php} class we need to:

\begin{itemize}
\item
  add \texttt{use} statements for the \texttt{SubmitType} we want to use
  (it works out for itself the \texttt{TextType} from the Entity
  annotations)

\begin{Shaded}
\begin{Highlighting}[]
     \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Form\textbackslash{}Extension\textbackslash{}Core\textbackslash{}Type\textbackslash{}SubmitType}\OtherTok{;}
\end{Highlighting}
\end{Shaded}
\item
  write a statement to add a submit button to the form:

\begin{Shaded}
\begin{Highlighting}[]
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ buildForm}\OtherTok{(}\NormalTok{FormBuilderInterface }\KeywordTok{$builder}\OtherTok{,} \KeywordTok{array} \KeywordTok{$options}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$builder}
\NormalTok{                ->add}\OtherTok{(}\StringTok{'firstName'}\OtherTok{)}
\NormalTok{                ->add}\OtherTok{(}\StringTok{'surname'}\OtherTok{)}
\NormalTok{                ->add}\OtherTok{(}\StringTok{'save'}\OtherTok{,}\NormalTok{ SubmitType::}\KeywordTok{class}\OtherTok{,} \KeywordTok{array}\OtherTok{(}\StringTok{'label'}\NormalTok{ => }\StringTok{'Create Student'}\OtherTok{))}
            \OtherTok{;}

\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}
\end{itemize}

That's our \texttt{StudentType} form class complete.

For the \texttt{/Controller/StudentController.php} class we need to:

\begin{itemize}
\item
  remove the \texttt{use} statements for \texttt{TextType} and
  \texttt{SubmitType}
\item
  add a \texttt{use} statement for the \texttt{StudentType} class we
  have just created:

\begin{Shaded}
\begin{Highlighting}[]
     \KeywordTok{use}\NormalTok{ App\textbackslash{}Form\textbackslash{}StudentType}\OtherTok{;}
\end{Highlighting}
\end{Shaded}
\item
  simplify our controller method, which can create the form in a single
  statement:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
     \KeywordTok{$form}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->createForm}\OtherTok{(}\NormalTok{StudentType::}\KeywordTok{class}\OtherTok{,} \KeywordTok{$student}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

So our refactored \texttt{new()} controller method looks as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function} \KeywordTok{new}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$student}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Student}\OtherTok{();}

        \KeywordTok{$form}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->createForm}\OtherTok{(}\NormalTok{StudentType::}\KeywordTok{class}\OtherTok{,} \KeywordTok{$student}\OtherTok{);}

        \KeywordTok{$form}\NormalTok{->handleRequest}\OtherTok{(}\KeywordTok{$request}\OtherTok{);}

        \KeywordTok{if} \OtherTok{(}\KeywordTok{$form}\NormalTok{->isSubmitted}\OtherTok{()}\NormalTok{ && }\KeywordTok{$form}\NormalTok{->isValid}\OtherTok{())}\NormalTok{ \{}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->createAction}\OtherTok{(}\KeywordTok{$student}\OtherTok{);}
\NormalTok{        \}}

        \KeywordTok{$template}\NormalTok{ = }\StringTok{'student/new.html.twig'}\OtherTok{;}
        \KeywordTok{$argsArray}\NormalTok{ = }\OtherTok{[}
            \StringTok{'form'}\NormalTok{ => }\KeywordTok{$form}\NormalTok{->createView}\OtherTok{(),}
        \OtherTok{];}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$argsArray}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Figure \ref{html_validation} shows a screenshot of the HTML validation
from the generated form (empty values not accepted due to
=\texttt{required} attribute in the text
\texttt{\textless{}input\textgreater{}} tags).

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/ca3a96067d2a7b1d92cc60f542cb170bf7dc8563.png}
\caption{HTML validation prevening empty text submissiomns.
\label{html_validation}}
\end{figure}

\hypertarget{video-tutorials-about-symfony-forms}{%
\section{Video tutorials about Symfony
forms}\label{video-tutorials-about-symfony-forms}}

Here are some resources on this topic:

\begin{itemize}
\item
  \href{https://symfony.com/doc/current/reference/constraints/GreaterThan.html}{Example
  of a numeric `greater than' constraint in Entity class}
\item
  \href{https://codereviewvideos.com/course/beginner-s-guide-to-symfony-3-forms/video/validating-form-data-with-symfony-3}{Video:
  Code Review form validation with \texttt{@Assert}}
\end{itemize}

\hypertarget{customising-the-display-of-generated-forms}{%
\chapter{Customising the display of generated
forms}\label{customising-the-display-of-generated-forms}}

\hypertarget{first-lets-bootstrap-this-project-project-form06}{%
\section{\texorpdfstring{First let's Bootstrap this project (project
\texttt{form06})}{First let's Bootstrap this project (project form06)}}\label{first-lets-bootstrap-this-project-project-form06}}

Since the Twig Symfony component allows custom themes, of which
Bootstrap 4 is one of them, it is relatively easy to add Bootstrap to
our website.

A great advantage of adding Bootstrap via a Twig theme is that
components, such as the Form generation component, know about themes and
will use them to decorate their output. So our form fields and buttons
will make use of Bootstrap structures and CSS classes once we add this
theme.

To add Bootstrap to a Symfony project we need to do 3 things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Configure Twig to use the Bootstrap theme.
\item
  Add the Bootstrap CSS import into our base Twig template.
\item
  Add the Bootstrap JavaScript import into our base Twig template.
\end{enumerate}

Learn more about the Bootstrap 4 theme on the Symfony documentation
pages:

\begin{itemize}
\tightlist
\item
  \url{https://symfony.com/doc/current/form/bootstrap4.html}
\end{itemize}

\hypertarget{configure-twig-to-use-the-bootstrap-theme}{%
\section{Configure Twig to use the Bootstrap
theme}\label{configure-twig-to-use-the-bootstrap-theme}}

Well Symfony to generate forms using the Bootstrap theme by adding:

\begin{verbatim}
    form_themes: ['bootstrap_4_layout.html.twig']
\end{verbatim}

to \texttt{/config/packages/twig.yml} file. So this file should now look
as follows;

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{twig:}
        \FunctionTok{paths:}\AttributeTok{ }\KeywordTok{[}\StringTok{'%kernel.project_dir%/templates'}\KeywordTok{]}
        \FunctionTok{debug:}\AttributeTok{ }\StringTok{'%kernel.debug%'}
        \FunctionTok{strict_variables:}\AttributeTok{ }\StringTok{'%kernel.debug%'}
        \FunctionTok{form_themes:}\AttributeTok{ }\KeywordTok{[}\StringTok{'bootstrap_4_layout.html.twig'}\KeywordTok{]}
\end{Highlighting}
\end{Shaded}

\hypertarget{add-the-bootstrap-css-import-into-our-base-twig-template}{%
\section{Add the Bootstrap CSS import into our base Twig
template}\label{add-the-bootstrap-css-import-into-our-base-twig-template}}

The Bootstrap QuickStart tells us to copy the CSS
\texttt{\textless{}link\textgreater{}} tag from here:

\begin{itemize}
\tightlist
\item
  \url{https://getbootstrap.com/docs/4.4/getting-started/introduction/\#css}
\end{itemize}

into the CSS part of our \texttt{/templates/base.html.twig} Twig
template. Add this \texttt{\textless{}link\textgreater{}} tag just
before the \texttt{stylesheets} block:

\begin{verbatim}
    <!DOCTYPE html> <html>
    <head>
        <meta charset="UTF-8" />
        <title>MGW - {% block pageTitle %}{% endblock %}</title>
        <style>
            @import '/css/flash.css';
        </style>

    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
        
        {% block stylesheets %}{% endblock %}
        
    </head>
   ...
\end{verbatim}

\hypertarget{add-the-bootstrap-javascript-import-into-our-base-twig-template.}{%
\section{Add the Bootstrap JavaScript import into our base Twig
template.}\label{add-the-bootstrap-javascript-import-into-our-base-twig-template.}}

The Bootstrap QuickStart tells us to copy the JS
\texttt{\textless{}script\textgreater{}} tags from here:

\begin{itemize}
\tightlist
\item
  \url{https://getbootstrap.com/docs/4.4/getting-started/introduction/\#js}
\end{itemize}

into the last part of the \texttt{\textless{}body\textgreater{}} element
in \texttt{/templates/base.html.twig} Twig template. Add these
\texttt{\textless{}script\textgreater{}} tags just after the
\texttt{javascripts} block:

\begin{verbatim}
    ...
    
    <body>
    <nav>
        <ul>
            <li>
                <a href="{{ path('student_list') }}">student actions</a>
            </li>
        </ul>
    </nav>
    
        {% block body %}{% endblock %}
    
        {% block javascripts %}{% endblock %}
    
<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    
    </body>
</html>
\end{verbatim}

\hypertarget{run-site-and-see-some-bootstrap-styling}{%
\section{Run site and see some Bootstrap
styling}\label{run-site-and-see-some-bootstrap-styling}}

Figure \ref{form_bootstrap} shows a screenshot how our new Student form
looks now. We can see some basic Bootstrap styling with blue buttons,
and sans-serif fonts etc. But the text boxes go right to the left/right
edges of the browser window, with no padding etc.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/15a6d51f6220970d5520415ccb4864ae58ae9ad9.png}
\caption{Basic Bootstrap styling of generated form.
\label{form_bootstrap}}
\end{figure}

Figure \ref{form_bootstrap_source} shows the HTML source - we can see no
page/content \texttt{\textless{}div\textgreater{}} elements around the
form, which are needed as part of the guidelines of using Bootstrap.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/f9087b127b21a746a42bee0755ac2abfb144b89c.png}
\caption{Basic HTML source of generated form.
\label{form_bootstrap_source}}
\end{figure}

\hypertarget{adding-elements-for-navigation-and-page-content}{%
\section{Adding elements for navigation and page
content}\label{adding-elements-for-navigation-and-page-content}}

Let's ensure main \texttt{body} content of every page is inside a
Bootstrap 4 element.

We need to wrap a Bootstrap container and row divs around the
\texttt{body} Twig block.

Replace the existing \texttt{body} block in template
\texttt{base.html.twig} with the following:

\begin{verbatim}

    <div class="container">
        <div class="row">
            <div class="col-sm-12">

            {% block body %}{% endblock %}

            </div>
        </div>
    </div>
\end{verbatim}

When we visit the site not, as we can see in Figure
\ref{form_nice_body}, the page content is within a nicely styled
Bootstrap container, with associated margins and padding.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/b7aec3203c234fdc0b487b9331755c42a04f3b27.png}
\caption{Basic HTML source of generated form. \label{form_nice_body}}
\end{figure}

\hypertarget{add-bootstrap-navigation-bar}{%
\section{Add Bootstrap navigation
bar}\label{add-bootstrap-navigation-bar}}

Let's add a title to our navigation bar, declaring this site
\texttt{My\ Great\ Website}. This should be a link to the website root
(we can just link to \texttt{\#}).

Do the following:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add a new CSS stylesheet to make our navbar background BLACK. Create
  file \texttt{/public/css/nav.css} containing:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{   nav \{}
       \KeywordTok{background-color}\NormalTok{: }\ConstantTok{black}\OperatorTok{;}
\NormalTok{   \}}
\end{Highlighting}
\end{Shaded}
\item
  Add an \texttt{@import} statement for this stylesheet in the
  \texttt{\textless{}style\textgreater{}} element in our
  \texttt{base.html.twig} master template:

\begin{Shaded}
\begin{Highlighting}[]
   \DataTypeTok{<!DOCTYPE }\NormalTok{html}\DataTypeTok{>} \KeywordTok{<html>}
   \KeywordTok{<head>}
       \KeywordTok{<meta}\OtherTok{ charset=}\StringTok{"UTF-8"} \KeywordTok{/>}
       \KeywordTok{<title>}\NormalTok{MGW - \{% block pageTitle %\}\{% endblock %\}}\KeywordTok{</title>}
       \KeywordTok{<style>}
           \ImportTok{@import} \StringTok{'/css/flash.css'}\OperatorTok{;}
           \ImportTok{@import} \StringTok{'/css/nav.css'}\OperatorTok{;}
       \KeywordTok{</style>}

\NormalTok{       ...}
\end{Highlighting}
\end{Shaded}
\item
  Add some Bootstrap classes and a link around text
  \texttt{My\ Great\ Website\ !} in \texttt{base.html.twig}:

\begin{Shaded}
\begin{Highlighting}[]
       \KeywordTok{<nav}\OtherTok{ class=}\StringTok{"navbar navbar-expand-lg navbar-dark navbar-bg mb-5"}\KeywordTok{>}
           \KeywordTok{<a}\OtherTok{ style=}\StringTok{"margin-left: 0.1rem;"}\OtherTok{ class=}\StringTok{"navbar-brand space-brand"}\OtherTok{ href=}\StringTok{"#"}\KeywordTok{>}
\NormalTok{               My Great Website !}
           \KeywordTok{</a>}

           \KeywordTok{<ul>}
               \KeywordTok{<li>}
                   \KeywordTok{<a}\OtherTok{ href=}\StringTok{"\{\{ path('student_list') \}\}"}\KeywordTok{>}\NormalTok{student actions}\KeywordTok{</a>}
               \KeywordTok{</li>}
           \KeywordTok{</ul>}
       \KeywordTok{</nav>}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

Figure \ref{black_nav} shows our simple black navbar from our base
template.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/d0d0a0c5c02cdeae130278796b262303df02b576.png}
\caption{Black navbar for all website pages. \label{black_nav}}
\end{figure}

\hypertarget{styling-list-of-links-in-navbar}{%
\section{Styling list of links in
navbar}\label{styling-list-of-links-in-navbar}}

Let's now have links for list of students and creating a NEW student,
properly styled by our Bootstrap theme.

We need to add a Bootstrap styled unordered-list in the
\texttt{\textless{}nav\textgreater{}} element, with links to routes
\texttt{student\_list} and \texttt{student\_new}:

\begin{Shaded}
\begin{Highlighting}[]
        \KeywordTok{<nav}\OtherTok{ class=}\StringTok{"navbar navbar-expand-lg navbar-dark navbar-bg mb-5"}\KeywordTok{>}
            \KeywordTok{<a}\OtherTok{ style=}\StringTok{"margin-left: 0.1rem;"}\OtherTok{ class=}\StringTok{"navbar-brand space-brand"}\OtherTok{ href=}\StringTok{"#"}\KeywordTok{>}
\NormalTok{                My Great Website !}
            \KeywordTok{</a>}
    
            \KeywordTok{<ul}\OtherTok{ class=}\StringTok{"navbar-nav ml-auto"}\KeywordTok{>}
                \KeywordTok{<li}\OtherTok{ class=}\StringTok{"nav-item"}\KeywordTok{>}
                    \KeywordTok{<a}\OtherTok{ class=}\StringTok{"nav-link"}\OtherTok{ href=}\StringTok{"\{\{ url('student_list') \}\}"}\KeywordTok{>}
\NormalTok{                        student list}
                    \KeywordTok{</a>}
                \KeywordTok{</li>}
                \KeywordTok{<li}\OtherTok{ class=}\StringTok{"nav-item"}\KeywordTok{>}
                    \KeywordTok{<a}\OtherTok{ class=}\StringTok{"nav-link"}\OtherTok{ href=}\StringTok{"\{\{ url('student_new_form') \}\}"}\KeywordTok{>}
\NormalTok{                        Create NEW student}
                    \KeywordTok{</a>}
                \KeywordTok{</li>}
            \KeywordTok{</ul>}
     
        \KeywordTok{</nav>}
\end{Highlighting}
\end{Shaded}

Figure \ref{styled_links} shows the navbar with our 2 styled links.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/7ce4ab3158613594bcaaa31601e404c70d3d4ed4.png}
\caption{Navbar links for all website pages. \label{styled_links}}
\end{figure}

\hypertarget{adding-the-hamburger-menu-and-collapsible-links}{%
\section{Adding the hamburger-menu and collapsible
links}\label{adding-the-hamburger-menu-and-collapsible-links}}

While it looks fine in the desktop, these links are lost with a narrow
screen. Let's make them be replaced by a `hamburger-menu' when the
browser window is narrow.

We need to add a toggle drop-down button:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{<button}\OtherTok{ class=}\StringTok{"navbar-toggler"}\OtherTok{ type=}\StringTok{"button"}\OtherTok{ data-toggle=}\StringTok{"collapse"}
\OtherTok{            data-target=}\StringTok{"#navbarNavDropdown"}\OtherTok{ aria-controls=}\StringTok{"navbarNavDropdown"}
\OtherTok{            aria-expanded=}\StringTok{"false"}\OtherTok{ aria-label=}\StringTok{"Toggle navigation"}\KeywordTok{>}
        \KeywordTok{<span}\OtherTok{ class=}\StringTok{"navbar-toggler-icon"}\KeywordTok{></span>}
    \KeywordTok{</button>}
\end{Highlighting}
\end{Shaded}

We also need to wrap a collapse \texttt{\textless{}div\textgreater{}}
around our unordered list of links, with id of
\texttt{navbarNavDropdown}, so that it's this list that is replaced by
the hamburger-menu:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{<div}\OtherTok{ class=}\StringTok{"collapse navbar-collapse"}\OtherTok{ id=}\StringTok{"navbarNavDropdown"}\KeywordTok{>}
        \KeywordTok{<ul}\OtherTok{ class=}\StringTok{"navbar-nav ml-auto"}\KeywordTok{>}
            \KeywordTok{<li>}\NormalTok{...}\KeywordTok{</li>}
            \KeywordTok{<li>}\NormalTok{...}\KeywordTok{</li>}
        \KeywordTok{</ul>}
    \KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

So our complete \texttt{\textless{}nav\textgreater{}} element now looks
as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{<nav}\OtherTok{ class=}\StringTok{"navbar navbar-expand-lg navbar-dark navbar-bg mb-5"}\KeywordTok{>}
        \KeywordTok{<a}\OtherTok{ style=}\StringTok{"margin-left: 0.1rem;"}\OtherTok{ class=}\StringTok{"navbar-brand space-brand"}\OtherTok{ href=}\StringTok{"#"}\KeywordTok{>}
\NormalTok{            My Great Website !}
        \KeywordTok{</a>}
        \KeywordTok{<button}\OtherTok{ class=}\StringTok{"navbar-toggler"}\OtherTok{ type=}\StringTok{"button"}\OtherTok{ data-toggle=}\StringTok{"collapse"}\OtherTok{ data-target=}\StringTok{"#navbarNavDropdown"}\OtherTok{ aria-controls=}\StringTok{"navbarNavDropdown"}\OtherTok{ aria-expanded=}\StringTok{"false"}\OtherTok{ aria-label=}\StringTok{"Toggle navigation"}\KeywordTok{>}
            \KeywordTok{<span}\OtherTok{ class=}\StringTok{"navbar-toggler-icon"}\KeywordTok{></span>}
        \KeywordTok{</button>}

        \KeywordTok{<div}\OtherTok{ class=}\StringTok{"collapse navbar-collapse"}\OtherTok{ id=}\StringTok{"navbarNavDropdown"}\KeywordTok{>}
            \KeywordTok{<ul}\OtherTok{ class=}\StringTok{"navbar-nav ml-auto"}\KeywordTok{>}
                \KeywordTok{<li}\OtherTok{ class=}\StringTok{"nav-item"}\KeywordTok{>}
                    \KeywordTok{<a}\OtherTok{ class=}\StringTok{"nav-link"}\OtherTok{ href=}\StringTok{"\{\{ url('student_list') \}\}"}\KeywordTok{>}\NormalTok{ student list}
                    \KeywordTok{</a>}
                \KeywordTok{</li>}
                \KeywordTok{<li}\OtherTok{ class=}\StringTok{"nav-item"}\KeywordTok{>}
                    \KeywordTok{<a}\OtherTok{ class=}\StringTok{"nav-link"}\OtherTok{ href=}\StringTok{"\{\{ url('student_new_form') \}\}"}\KeywordTok{>}
\NormalTok{                        Create NEW student}
                    \KeywordTok{</a>}
                \KeywordTok{</li>}
            \KeywordTok{</ul>}
        \KeywordTok{</div>}
    \KeywordTok{</nav>}
\end{Highlighting}
\end{Shaded}

Figure \ref{black_nav} shows our simple black navbar from our base
template.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/5ea70cd464c7a89a545b4379c487d35b9097eec5.png}
\caption{Animated hamburger links for narrow browser window.
\label{hamburger}}
\end{figure}

\hypertarget{customizing-display-of-symfony-forms}{%
\chapter{Customizing display of Symfony
forms}\label{customizing-display-of-symfony-forms}}

\hypertarget{understanding-the-3-parts-of-a-form-project-form07}{%
\section{\texorpdfstring{Understanding the 3 parts of a form (project
\texttt{form07})}{Understanding the 3 parts of a form (project form07)}}\label{understanding-the-3-parts-of-a-form-project-form07}}

In a controller we create a \texttt{\$form} object, and pass this as a
Twig variable to the template \texttt{form}. Twig renders the form in 3
parts:

\begin{itemize}
\tightlist
\item
  the opening \texttt{\textless{}form\textgreater{}} tag
\item
  the sequence of form fields (with labels, errors and input elements)
\item
  the closing \texttt{\textless{}/form\textgreater{}} tag
\end{itemize}

This can all be done in one go (using Symfony/Twig defaults) with the
Twig \texttt{form()} function, or we can use Twigs 3 form functions for
rendering (displaying) each part of a form, these are:

\begin{itemize}
\tightlist
\item
  \texttt{form\_start()}
\item
  \texttt{form\_widget()}
\item
  \texttt{form\_end()}
\end{itemize}

So we could write the \texttt{body} block of our Twig template
(\texttt{/app/Resources/views/students/new.html.twig}) for the new
\texttt{Student} form to the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    \{% block body %\}}
        \KeywordTok{<h1>}\NormalTok{Create new student}\KeywordTok{</h1>}
\NormalTok{        \{\{ form_start(form) \}\}}
\NormalTok{        \{\{ form_widget(form) \}\}}
\NormalTok{        \{\{ form_end(form) \}\}}
\NormalTok{    \{% endblock %\}}
\end{Highlighting}
\end{Shaded}

Although since we're not adding anything between these 3 Twig functions'
output, the result will be the same form as before.

\hypertarget{using-a-twig-form-theme-template}{%
\section{Using a Twig form-theme
template}\label{using-a-twig-form-theme-template}}

Symfony provides several useful Twig templates for common form layouts.

These include:

\begin{itemize}
\tightlist
\item
  wrapping each form field in a \texttt{\textless{}div\textgreater{}}

  \begin{itemize}
  \tightlist
  \item
    form\_div\_layout.html.twig
  \end{itemize}
\item
  put form inside a table, and each field inside a table row
  \texttt{\textless{}tr\textgreater{}} element

  \begin{itemize}
  \tightlist
  \item
    form\_table\_layout.html.twig
  \end{itemize}
\item
  Boostrap CSS framework div's and CSS classes

  \begin{itemize}
  \tightlist
  \item
    bootstrap\_4\_layout.html.twig
  \end{itemize}
\end{itemize}

For example, to use the \texttt{div} layout we can declare this template
be used for all forms in the \texttt{/config/packages/twig.yml} file as
follows:

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{twig:}
        \FunctionTok{paths:}\AttributeTok{ }\KeywordTok{[}\StringTok{'%kernel.project_dir%/templates'}\KeywordTok{]}
        \FunctionTok{debug:}\AttributeTok{ }\StringTok{'%kernel.debug%'}
        \FunctionTok{strict_variables:}\AttributeTok{ }\StringTok{'%kernel.debug%'}
        \FunctionTok{form_themes:}\AttributeTok{ }\KeywordTok{[}\StringTok{'bootstrap_4_layout.html.twig'}\KeywordTok{]}
\end{Highlighting}
\end{Shaded}

\hypertarget{diy-do-it-yourself-form-display-customisations}{%
\section{DIY (Do-It-Yourself) form display
customisations}\label{diy-do-it-yourself-form-display-customisations}}

Each form field can be rendered all in one go in the following way:

\begin{verbatim}
    {{ form_row(form.<FIELD_NAME>) }}
\end{verbatim}

For example, if the form has a field \texttt{name}:

\begin{verbatim}
    {{ form_row(form.name) }}
\end{verbatim}

So we could display our new student form this way:

\begin{verbatim}
    {% block body %}
        <h1>Create new student</h1>
        {{ form_start(form) }}

        {{ form_row(form.firstName) }}
        {{ form_row(form.surname) }}
        {{ form_row(form.save) }}

        {{ form_end(form) }}
    {% endblock %}
\end{verbatim}

\hypertarget{customising-display-of-parts-of-each-form-field}{%
\section{Customising display of parts of each form
field}\label{customising-display-of-parts-of-each-form-field}}

Alternatively, each form field can have its 3 constituent parts rendered
separately:

\begin{itemize}
\tightlist
\item
  label (the text label seen by the user)
\item
  errors (any validation error messages)
\item
  widget (the form input element itself)
\end{itemize}

For example:

\begin{verbatim}
    <div>
        {{ form_label(form.firstName) }}

        <div class="errors">
        {{ form_errors(form.firstName) }}
        </div>

        {{ form_widget(form.firstName) }}
    </div>
\end{verbatim}

So we could display our new student form this way:

\begin{verbatim}
    {% block body %}
        <h1>Create new student</h1>
        {{ form_start(form) }}

   <div class="form-group">
        <div class="errors">
        {{ form_errors(form.firstName) }}
        </div>

        {{ form_label(form.firstName) }}

        {{ form_widget(form.firstName) }}
    </div>

   <div class="form-group">
        <div class="errors">
        {{ form_errors(form.surname) }}
        </div>

        {{ form_label(form.surname) }}

        {{ form_widget(form.surname) }}
    </div>

   <div class="form-group">
        {{ form_row(form.save) }}
    </div>

        {{ form_end(form) }}
    {% endblock %}
\end{verbatim}

The above would output the following HTML for the \texttt{firstName}
property (if the errors list was empty):

\begin{Shaded}
\begin{Highlighting}[]

   \KeywordTok{<div}\OtherTok{ class=}\StringTok{"form-group"}\KeywordTok{>}
    \KeywordTok{<div}\OtherTok{ class=}\StringTok{"errors"}\KeywordTok{>}
        
    \KeywordTok{</div>}

    \KeywordTok{<label}\OtherTok{ for=}\StringTok{"student_firstName"}\OtherTok{ class=}\StringTok{"required"}\KeywordTok{>}\NormalTok{First name}\KeywordTok{</label>}

    \KeywordTok{<input}\OtherTok{ type=}\StringTok{"text"}\OtherTok{ id=}\StringTok{"student_firstName"}\OtherTok{ name=}\StringTok{"student[firstName]"}\OtherTok{ required=}\StringTok{"required"}\OtherTok{ class=}\StringTok{"form-control"} \KeywordTok{/>}
    \KeywordTok{</div>}
\end{Highlighting}
\end{Shaded}

Learn more at:

\begin{itemize}
\tightlist
\item
  \href{https://symfony.com/doc/current/form/form_customization.html}{The
  Symfony form customisation page}
\end{itemize}

\hypertarget{specifying-a-forms-method-and-action}{%
\section{\texorpdfstring{Specifying a form's \textbf{method} and
\textbf{action}}{Specifying a form's method and action}}\label{specifying-a-forms-method-and-action}}

While Symfony forms default to \texttt{POST} submission and a postback
to the same URL, it is possible to specify the method and action of a
form created with Symfony's form builder. For example:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$formBuilder}\NormalTok{ = }\KeywordTok{$formFactory}\NormalTok{->createBuilder}\OtherTok{(}\NormalTok{FormType::}\KeywordTok{class}\OtherTok{,} \KeywordTok{null}\OtherTok{,} \KeywordTok{array}\OtherTok{(}
        \StringTok{'action'}\NormalTok{ => }\StringTok{'/search'}\OtherTok{,}
        \StringTok{'method'}\NormalTok{ => }\StringTok{'GET'}\OtherTok{,}
    \OtherTok{));}
\end{Highlighting}
\end{Shaded}

Learn more at:

\begin{itemize}
\tightlist
\item
  \href{https://symfony.com/doc/current/components/form.html}{Introduction
  to the Form component}
\end{itemize}

\part{Custom Repository Queries with forms}

\hypertarget{custom-database-queries}{%
\chapter{Custom database queries}\label{custom-database-queries}}

\hypertarget{search-for-exact-property-value-project-query01}{%
\section{\texorpdfstring{Search for exact property value (project
\texttt{query01})}{Search for exact property value (project query01)}}\label{search-for-exact-property-value-project-query01}}

Let's create a simple database schema for hardware products, and then
write some forms to query this database.

Use \texttt{make:entity} to create a new Entity class Product, with the
following properties:

\begin{itemize}
\tightlist
\item
  description: String
\item
  price: Float
\item
  category: String
\end{itemize}

Use \texttt{make:crud} to generate the CRUD pages for Product entities.

\hypertarget{fixtures}{%
\section{Fixtures}\label{fixtures}}

NOTE: You may need to add the ORM Fixtures library to this project:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{composer}\NormalTok{ req orm-fixtures --dev}
\end{Highlighting}
\end{Shaded}

Use \texttt{make:fixtures\ ProductFixtures} to create a fixtures class,
and write fixtures to enter the following initial data:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$p1}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Product}\OtherTok{();}
    \KeywordTok{$p1}\NormalTok{->setDescription}\OtherTok{(}\StringTok{'bag of nails'}\OtherTok{);}
    \KeywordTok{$p1}\NormalTok{->setPrice}\OtherTok{(}\FloatTok{5.00}\OtherTok{);}
    \KeywordTok{$p1}\NormalTok{->setCategory}\OtherTok{(}\StringTok{'hardware'}\OtherTok{);}
    \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$p1}\OtherTok{);}
    
    \KeywordTok{$p2}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Product}\OtherTok{();}
    \KeywordTok{$p2}\NormalTok{->setDescription}\OtherTok{(}\StringTok{'sledge hammer'}\OtherTok{);}
    \KeywordTok{$p2}\NormalTok{->setPrice}\OtherTok{(}\FloatTok{10.00}\OtherTok{);}
    \KeywordTok{$p2}\NormalTok{->setCategory}\OtherTok{(}\StringTok{'tools'}\OtherTok{);}
    \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$p2}\OtherTok{);}
    
    \KeywordTok{$p3}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Product}\OtherTok{();}
    \KeywordTok{$p3}\NormalTok{->setDescription}\OtherTok{(}\StringTok{'small bag of washers'}\OtherTok{);}
    \KeywordTok{$p3}\NormalTok{->setPrice}\OtherTok{(}\FloatTok{3.00}\OtherTok{);}
    \KeywordTok{$p3}\NormalTok{->setCategory}\OtherTok{(}\StringTok{'hardware'}\OtherTok{);}
    \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$p3}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

Now migrate your updated Entity structure to the database and load those
fixtures. Figure \ref{query1} shows the list of products you should
visiting the \texttt{/product} route.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/269f5b90ef563d270e48d48cca61d6c2b172ee39.png}
\caption{Animated hamburger links for narrow browser window.
\label{query1}}
\end{figure}

\hypertarget{add-new-route-and-controller-method-for-category-search}{%
\section{Add new route and controller method for category
search}\label{add-new-route-and-controller-method-for-category-search}}

Add a new method to the \texttt{ProductController} that has the URL
route pattern \texttt{/product/category/\{category\}}. We'll name this
method \texttt{categorySearch(...)} and it will allow us to refine the
list of products to only those with the given \texttt{Category} string:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/category/\{category\}",}\CommentTok{ name="product_search", methods=\{"GET"\})}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ search}\OtherTok{(}\KeywordTok{$category}\OtherTok{)}\NormalTok{: Response}
\NormalTok{    \{}

        \KeywordTok{$productRepository}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getRepository}\OtherTok{(}\StringTok{'App:Product'}\OtherTok{);}
        \KeywordTok{$products}\NormalTok{ =  }\KeywordTok{$productRepository}\NormalTok{->findByCategory}\OtherTok{(}\KeywordTok{$category}\OtherTok{);}

        \KeywordTok{$template}\NormalTok{ = }\StringTok{'product/index.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
            \StringTok{'products'}\NormalTok{ => }\KeywordTok{$products}\OtherTok{,}
            \StringTok{'category'}\NormalTok{ => }\KeywordTok{$category}
        \OtherTok{];}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

First, we are getting a string from the URL that follows
\texttt{/product/category/}. \textbf{All} routes defined in the CRUD
generated \texttt{ProductController} are prefixed with
\texttt{/product}, due to the annoation comment that is declared
\textbf{before} the class declaration:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/product")}
\CommentTok{     */}
    \KeywordTok{class}\NormalTok{ ProductController }\KeywordTok{extends}\NormalTok{ AbstractController}
\NormalTok{    \{}
        \StringTok{...}\NormalTok{ controller methods here }\StringTok{...}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Whatever appears \textbf{after} \texttt{/product/category/} in the URL
will be put into variabled \texttt{\$category} by the Symfony routing
system, because of the \texttt{Route} anntation comment:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/category/\{category\}",}\CommentTok{ name="product_search", methods=\{"GET"\})}
\CommentTok{     */}
\end{Highlighting}
\end{Shaded}

We get a reference to an object that is an instance of the
\texttt{ProductRepository} from this line:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$productRepository}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getRepository}\OtherTok{(}\StringTok{'App:Product'}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

We could get an array \texttt{products} of \textbf{all} \texttt{Product}
objects from the database by writing:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$products}\NormalTok{ =  }\KeywordTok{$productRepository}\NormalTok{->findByCategory}\OtherTok{(}\KeywordTok{$category}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

But Doctrine repository classes also give us free \textbf{helper}
methods, that provide \texttt{findBy} and \texttt{findOneBy} methods for
the properties of an Entity class. Since Entity class \texttt{Product}
has a property \texttt{name}, then we get for free the Doctrine query
method \texttt{findByName(...)} to which we can pass a value of
\texttt{name} to search for. So we can get the array of \texttt{Product}
objects whose \texttt{name} property matches the paramegter
\texttt{category} as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$products}\NormalTok{ =  }\KeywordTok{$productRepository}\NormalTok{->findByCategory}\OtherTok{(}\KeywordTok{$category}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

Finally, we'll pass both the \texttt{\$products} array, and the text
string \texttt{\$category} as variables to the \texttt{index} list
Products Twig template:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$template}\NormalTok{ = }\StringTok{'product/index.html.twig'}\OtherTok{;}
    \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
        \StringTok{'products'}\NormalTok{ => }\KeywordTok{$products}\OtherTok{,}
        \StringTok{'category'}\NormalTok{ => }\KeywordTok{$category}
    \OtherTok{];}

    \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

\hypertarget{aside-how-to-the-free-helper-doctrine-methods-work}{%
\section{Aside: How to the free `helper' Doctrine methods
work?}\label{aside-how-to-the-free-helper-doctrine-methods-work}}

PHP offers a runtime code reflection (or interpreter pre-processing if
you prefer), that can intercept calls to non-existent methods of a
class. We use the special \textbf{magic} PHP method
\texttt{\_\_call(...)} which expects 2 parameters, one for the
non-existent method name, and one as an array of argument values passed
to the non-existent method:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function} \FunctionTok{__call}\OtherTok{(}\KeywordTok{$methodName}\OtherTok{,} \KeywordTok{$arguments}\OtherTok{)}
\NormalTok{    \{}
        \StringTok{...} \KeywordTok{do}\NormalTok{ something with }\KeywordTok{$methodName} \KeywordTok{and} \KeywordTok{$arguments}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Here is a simple class (put it in
\texttt{/src/Util/ExampleRepository.php} in you want to try this) that
demonsrtates how Doctrine uses `\_\_call' to identify which Entity
property we are trying to query by:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php}
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Util}\OtherTok{;}
    
    \CommentTok{/*}
\CommentTok{     * class to demonstrate how __call can be used by Doctrine repositories ...}
\CommentTok{     */}
    \KeywordTok{class}\NormalTok{ ExampleRepository}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ findAll}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{return} \StringTok{'you called method findAll()'}\OtherTok{;}
\NormalTok{        \}}
    
        \KeywordTok{public} \KeywordTok{function} \FunctionTok{__call}\OtherTok{(}\KeywordTok{$methodName}\OtherTok{,} \KeywordTok{$arguments}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$html}\NormalTok{ = }\StringTok{''}\OtherTok{;}
            \KeywordTok{$argsString}\NormalTok{ = }\FunctionTok{implode}\OtherTok{(}\StringTok{', '}\OtherTok{,} \KeywordTok{$arguments}\OtherTok{)}\NormalTok{ . }\StringTok{"}\KeywordTok{\textbackslash{}n}\StringTok{"}\OtherTok{;}
    
            \KeywordTok{$html}\NormalTok{ .= }\StringTok{"you called method }\KeywordTok{$methodName\textbackslash{}n}\StringTok{"}\OtherTok{;}
            \KeywordTok{$html}\NormalTok{ .= }\StringTok{"with arguments: }\KeywordTok{$argsString\textbackslash{}n}\StringTok{"}\OtherTok{;}
    
            \KeywordTok{$result}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->startsWithFindBy}\OtherTok{(}\KeywordTok{$methodName}\OtherTok{);}
            \KeywordTok{if}\OtherTok{(}\KeywordTok{$result}\OtherTok{)}\NormalTok{\{}
                \KeywordTok{$html}\NormalTok{ .= }\StringTok{"since the method called started with 'findBy'"}
\NormalTok{                . }\StringTok{"}\KeywordTok{\textbackslash{}n}\StringTok{ it looks like you were searching by property '}\KeywordTok{$result}\StringTok{'}\KeywordTok{\textbackslash{}n}\StringTok{"}\OtherTok{;}
\NormalTok{            \}}
    
            \KeywordTok{return} \KeywordTok{$html}\OtherTok{;}
\NormalTok{        \}}
    
        \KeywordTok{private} \KeywordTok{function}\NormalTok{ startsWithFindBy}\OtherTok{(}\KeywordTok{$name}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$needle}\NormalTok{ = }\StringTok{'findBy'}\OtherTok{;}
            \KeywordTok{$pos}\NormalTok{ = }\FunctionTok{strpos}\OtherTok{(}\KeywordTok{$name}\OtherTok{,} \KeywordTok{$needle}\OtherTok{);}
    
            \CommentTok{// since 0 would evaluate to FALSE, must use !== not simply !=}
            \KeywordTok{if} \OtherTok{((}\KeywordTok{$pos}\NormalTok{ !== }\KeywordTok{false}\OtherTok{)}\NormalTok{ && }\OtherTok{(}\KeywordTok{$pos}\NormalTok{ == }\DecValTok{0}\OtherTok{))}\NormalTok{\{}
                \KeywordTok{return} \FunctionTok{substr}\OtherTok{(}\KeywordTok{$name}\OtherTok{,} \FunctionTok{strlen}\OtherTok{(}\KeywordTok{$needle}\OtherTok{));} \CommentTok{// text AFTER findBy}
\NormalTok{            \}}
    
            \KeywordTok{return} \KeywordTok{false}\OtherTok{;}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

You could add a new method to the \texttt{DefaultController} class to
see this in action as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/call",}\CommentTok{ name="call")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ call}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// illustrate how __call workds}
        \KeywordTok{$exampleRepository}\NormalTok{ = }\KeywordTok{new}\NormalTok{ ExampleRepository}\OtherTok{();}

        \KeywordTok{$html}\NormalTok{ = }\StringTok{"<pre>"}\OtherTok{;}
        \KeywordTok{$html}\NormalTok{ .=  }\StringTok{"----- calling findAll() -----}\KeywordTok{\textbackslash{}n}\StringTok{"}\OtherTok{;}
        \KeywordTok{$html}\NormalTok{ .= }\KeywordTok{$exampleRepository}\NormalTok{->findAll}\OtherTok{();}

        \KeywordTok{$html}\NormalTok{ .=  }\StringTok{"}\KeywordTok{\textbackslash{}n\textbackslash{}n}\StringTok{----- calling findAllByProperty() -----}\KeywordTok{\textbackslash{}n}\StringTok{"}\OtherTok{;}
        \KeywordTok{$html}\NormalTok{ .= }\KeywordTok{$exampleRepository}\NormalTok{->findByName}\OtherTok{(}\StringTok{'matt'}\OtherTok{,} \StringTok{'smith'}\OtherTok{);}

        \KeywordTok{$html}\NormalTok{ .=  }\StringTok{"}\KeywordTok{\textbackslash{}n}\StringTok{----- calling badMethodName() -----}\KeywordTok{\textbackslash{}n}\StringTok{"}\OtherTok{;}
        \KeywordTok{$html}\NormalTok{ .= }\KeywordTok{$exampleRepository}\NormalTok{->badMethodName}\OtherTok{(}\StringTok{'matt'}\OtherTok{,} \StringTok{'smith'}\OtherTok{);}

        \KeywordTok{return} \KeywordTok{new}\NormalTok{ Response}\OtherTok{(}\KeywordTok{$html}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

See Figure \ref{query2} shows the \texttt{ExampleRepository} output you
should visiting the \texttt{/call} route. We can see that:

\begin{itemize}
\item
  a call to \texttt{findAll()} works fine, since that is a defined
  public method of the class
\item
  a call to \texttt{findByName(...)} would work fine, since we can use
  \texttt{\_\_call(...)} to identify that this was a call to a helper
  \texttt{findBy\textless{}property\textgreater{}(...)} method

  \begin{itemize}
  \tightlist
  \item
    and we could add logic to check that this is a property of the
    Entity class and build an appropriate query from the arguments
  \end{itemize}
\item
  a call to \texttt{badMethodName(...)} is caught by
  \texttt{\_\_call(...)}, but fails our test for starting with
  \texttt{findBy}, and so we can ignore it

  \begin{itemize}
  \tightlist
  \item
    or log error or throw Exception or whatever our program spec says to
    do in these cases\ldots{}
  \end{itemize}
\end{itemize}

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/6ede346171ac54e4c3de8392100951d14bee3666.png}
\caption{Output from our ExampleRepository \texttt{\_\_call} demo.
\label{query2}}
\end{figure}

\hypertarget{testing-our-search-by-category}{%
\section{Testing our search by
category}\label{testing-our-search-by-category}}

If we now visit \texttt{/products/category/tools} we should see a list
of only those Products with category = \texttt{tools}. See Figure
\ref{query3} for a screenshot of this.

Likewise, for \texttt{/products/category/hardware} - see Figure
\ref{query4}.

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/9514eae2fe53ea5066a6bfb263d5fac802af022a.png}
\caption{Only \texttt{tools} Products. \label{query3}}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/7a346ce12ff5373b1976ddd46a0c555b94f421c1.png}
\caption{Only \texttt{hardware} Products. \label{query4}}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/f58a05139ec5ba921032e06d20b97101894c9079.png}
\caption{Only \texttt{abc} Products (i.e none!). \label{query5}}
\end{figure}

If we try to search with a value that does not appear as the
\texttt{category} String property for any Products, no products will be
listed. See Figure \ref{query5}.

\hypertarget{custom-database-queries-1}{%
\chapter{Custom database queries}\label{custom-database-queries-1}}

\hypertarget{search-form-for-exact-property-value-project-query02}{%
\section{\texorpdfstring{Search Form for exact property value (project
\texttt{query02})}{Search Form for exact property value (project query02)}}\label{search-form-for-exact-property-value-project-query02}}

Searching by having to type values in the URL isn't ideal. So let's add
an HTML form in the list of projects page, allowing users to enter the
category that way. Figure \ref{query6}illustrates what we are going to
create.

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/47650a0958b4a5fc995d0cc457a8d66e72541eae.png}
\caption{Form to search for category. \label{query6}}
\end{figure}

\hypertarget{the-form-in-twig-template}{%
\section{The form in Twig template}\label{the-form-in-twig-template}}

Let's write the HTML code for the submission form for the Products list
Twig template in \texttt{/templates/product/index.html.twig}.

At present we have a table \texttt{\textless{}thead\textgreater{}} with
a row of column headers, and then a loop for each Product:

\begin{verbatim}
    {% extends 'base.html.twig' %}
    
    {% block title %}Product index{% endblock %}
    
    {% block body %}
        <h1>Product index</h1>
    
        <table class="table">
            <thead>
                <tr>
                    <th>Id</th>
                    <th>Description</th>
                    <th>Price</th>
                    <th>Category</th>
                    <th>actions</th>
                </tr>
            </thead>
            <tbody>

    <<<< TABLE ROW WITH FORM TO GO HERE >>>>
    
            {% for product in products %}
                <tr>
                    <td>{{ product.id }}</td>    
\end{verbatim}

We need to add a new table row between the table headers and the loop of
Products:

\begin{verbatim}
    <tr>
        <th></th>
        <th></th>
        <th></th>
        <th>
            <form action="{{ url('search_category') }}" method="post">
                <input name="category">
                <input type="submit">
            </form>
        </th>
        <th></th>
    </tr>

    {% for product in products %}
        <tr>
            ... as before
\end{verbatim}

The row has empty cells, except for the 4th cell (the Category column),
where we create a simple form. The form has:

\begin{itemize}
\item
  a method of \texttt{post}
\item
  an action of
  \texttt{url(\textquotesingle{}search\_category\textquotesingle{})}

  \begin{itemize}
  \tightlist
  \item
    we'll have to create this new route in the
    \texttt{ProductController} to process submission of this form
  \end{itemize}
\item
  a text box named \texttt{category}

  \begin{itemize}
  \item
    since this text box will appear in the Categorty column, we don't
    need to give a text prompt
  \item
    the HTML default \texttt{\textless{}input\textgreater{}} type is
    \texttt{text}, so we don't need to specify this either
  \end{itemize}
\item
  a Submit button
\end{itemize}

\hypertarget{controller-method-to-process-form-submission}{%
\section{Controller method to process form
submission}\label{controller-method-to-process-form-submission}}

Here is the new method in \texttt{ProductController} to process
submission of this form - implementing the route
\texttt{search\_category}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/searchCategory",}\CommentTok{ name="search_category", methods=\{"POST"\})}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ searchCategory}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}\NormalTok{: Response}
\NormalTok{    \{}
        \KeywordTok{$category}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'category'}\OtherTok{);}

        \KeywordTok{if}\OtherTok{(}\KeywordTok{empty}\OtherTok{(}\KeywordTok{$category}\OtherTok{))}\NormalTok{\{}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'product_index'}\OtherTok{);}
\NormalTok{        \}}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'product_search'}\OtherTok{,} \OtherTok{[}\StringTok{'category'}\NormalTok{ => }\KeywordTok{$category}\OtherTok{]);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

The annotation comments specify the URL route \texttt{/searchCategory},
the internal route name \texttt{search\_category}, and that we expect
the request to be submitted using the \texttt{POST} method:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/searchCategory",}\CommentTok{ name="search_category", methods=\{"POST"\})}
\CommentTok{     */}
\end{Highlighting}
\end{Shaded}

We need to extract the \texttt{category} variable submitted in the HTTP
Request, so we need access to the Symfony \texttt{Request} object. The
simnplest way to get a reference to this object is via the Symfony
\textbf{param converter}, by adding \texttt{(Request\ \$request)} as a
method parameter. This means we now have Request object variable
\texttt{\$request} available to use in our method:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ searchCategory}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}\NormalTok{: Response}
\end{Highlighting}
\end{Shaded}

We can retrieve a value from the submitted \texttt{POST} variables int
the request using the \texttt{get-\textgreater{}} method naming the
variable \texttt{category}. NOTE: In this instance \texttt{get} is a
\textbf{getter} (accessor method) - not to be confused with the HTTP
\texttt{GET} Request method\ldots{}

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{$category}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'category'}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

Finally, we can do some logic based on the value of form submitted
variable \texttt{\$category}. If this variable is an emptuy string,
let's just redirect Symfonhy to run the method to list all products,
route \texttt{product\_index}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{if}\OtherTok{(}\KeywordTok{empty}\OtherTok{(}\KeywordTok{$category}\OtherTok{))}\NormalTok{\{}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'product_index'}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

If \texttt{\$category} was \textbf{not} empty then we can redirect to
our category search route, passing the value to this route:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'product_search'}\OtherTok{,} \OtherTok{[}\StringTok{'category'}\NormalTok{ => }\KeywordTok{$category}\OtherTok{]);}
\end{Highlighting}
\end{Shaded}

\hypertarget{getting-rid-of-the-url-search-route}{%
\section{Getting rid of the URL search
route}\label{getting-rid-of-the-url-search-route}}

If we no longer wanted the URL search route, we could replace the final
statement in our \texttt{searchCategory(...)} method to the following
(and remove method \texttt{search(...)} altogether):

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/searchCategory",}\CommentTok{ name="search_category", methods=\{"POST"\})}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ searchCategory}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}\NormalTok{: Response}
\NormalTok{    \{}
        \KeywordTok{$category}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'category'}\OtherTok{);}

        \KeywordTok{if}\OtherTok{(}\KeywordTok{empty}\OtherTok{(}\KeywordTok{$category}\OtherTok{))}\NormalTok{\{}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'product_index'}\OtherTok{);}
\NormalTok{        \}}
    
        \CommentTok{// if get here, not empty - so use value to search...}
        \KeywordTok{$productRepository}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getRepository}\OtherTok{(}\StringTok{'App:Product'}\OtherTok{);}
        \KeywordTok{$products}\NormalTok{ =  }\KeywordTok{$productRepository}\NormalTok{->findByCategory}\OtherTok{(}\KeywordTok{$category}\OtherTok{);}

        \KeywordTok{$template}\NormalTok{ = }\StringTok{'product/index.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
            \StringTok{'products'}\NormalTok{ => }\KeywordTok{$products}\OtherTok{,}
            \StringTok{'category'}\NormalTok{ => }\KeywordTok{$category}
        \OtherTok{];}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{wildcard-vs.-exact-match-queries}{%
\chapter{Wildcard vs.~exact match
queries}\label{wildcard-vs.-exact-match-queries}}

\hypertarget{search-form-for-partial-description-match-project-query03}{%
\section{\texorpdfstring{Search Form for partial description match
(project
\texttt{query03})}{Search Form for partial description match (project query03)}}\label{search-form-for-partial-description-match-project-query03}}

Let's add a query form in the \textbf{description} column, so we need to
edit Twig template \texttt{/templates/product/index.html.twig}.

So we add a new search form in the second table header row, for internal
route name \texttt{search\_description}, and passing form variable
\texttt{keyword}:

\begin{verbatim}
    <tr>
        <th></th>
        <th>
            <form action="{{ url('search_description') }}" method="post">
                <input name="keyword">
                <input type="submit">
            </form>
        </th>
        <th></th>
        <th>
            <form action="{{ url('search_category') }}" method="post">
                <input name="category">
                <input type="submit">
            </form>
        </th>
        <th></th>
    </tr>
\end{verbatim}

Let's write the controller method to process our keyword form submission
- edit \texttt{/src/ProductController.php} and add a new method:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/searchDescription",}\CommentTok{ name="search_description", methods=\{"POST"\})}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ searchDescription}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}\NormalTok{: Response}
\NormalTok{    \{}
        \KeywordTok{$keyword}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'keyword'}\OtherTok{);}

        \KeywordTok{if}\OtherTok{(}\KeywordTok{empty}\OtherTok{(}\KeywordTok{$keyword}\OtherTok{))}\NormalTok{\{}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'product_index'}\OtherTok{);}
\NormalTok{        \}}

        \CommentTok{// if get here, not empty - so use value to search...}
        \KeywordTok{$productRepository}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getRepository}\OtherTok{(}\StringTok{'App:Product'}\OtherTok{);}
        \KeywordTok{$products}\NormalTok{ =  }\KeywordTok{$productRepository}\NormalTok{->findByDescription}\OtherTok{(}\KeywordTok{$keyword}\OtherTok{);}

        \KeywordTok{$template}\NormalTok{ = }\StringTok{'product/index.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
            \StringTok{'products'}\NormalTok{ => }\KeywordTok{$products}\OtherTok{,}
            \StringTok{'keyword'}\NormalTok{ => }\KeywordTok{$keyword}
        \OtherTok{];}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

The above is just like our category search - but does only work for an
exact match of \texttt{keyword} with the value of the
\texttt{description} property.

What we want is to implement something similar the SQL
\texttt{LIKE\ "\%wildcard\%"} query, where a word \textbf{anywhere} in
the text of the \texttt{description} property will be matched.

\hypertarget{custom-queries-in-our-repository-class}{%
\section{Custom queries in our Repository
class}\label{custom-queries-in-our-repository-class}}

The solution is to write a custom query method
\texttt{findByLikeDescription(\$keyword)} in our
\texttt{ProductRepository} class as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \StringTok{...}

    \KeywordTok{class}\NormalTok{ ProductRepository }\KeywordTok{extends}\NormalTok{ ServiceEntityRepository}
\NormalTok{    \{}
        \StringTok{...}

        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@return}\CommentTok{ Product[] Returns an array of Drill objects}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ findByLikeDescription}\OtherTok{(}\KeywordTok{$keyword}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->createQueryBuilder}\OtherTok{(}\StringTok{'p'}\OtherTok{)}
\NormalTok{                ->andWhere}\OtherTok{(}\StringTok{'p.description LIKE :keyword'}\OtherTok{)}
\NormalTok{                ->setParameter}\OtherTok{(}\StringTok{'keyword'}\OtherTok{,} \StringTok{"%}\KeywordTok{$keyword}\StringTok{%"}\OtherTok{)}
\NormalTok{                ->getQuery}\OtherTok{()}
\NormalTok{                ->getResult}\OtherTok{()}
                \OtherTok{;}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

We can now use this method in our \texttt{ProductController} controller
method \texttt{searchDescription(..)}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{// if get here, not empty - so use value to search...}
    \KeywordTok{$productRepository}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getRepository}\OtherTok{(}\StringTok{'App:Product'}\OtherTok{);}

    \KeywordTok{$products}\NormalTok{ =  }\KeywordTok{$productRepository}\NormalTok{->findByLikeDescription}\OtherTok{(}\KeywordTok{$keyword}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

See Figure \ref{query7} illustrates a wildcard search for any
\texttt{Product} with description containing texgt \texttt{bag}.

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/8fc967e92395014712f6bdca2d15969781702e4c.png}
\caption{Form to wildcard search for description. \label{query7}}
\end{figure}

\hypertarget{making-wildcard-a-sticky-form}{%
\section{\texorpdfstring{Making wildcard a \textbf{sticky}
form}{Making wildcard a sticky form}}\label{making-wildcard-a-sticky-form}}

You may have noticed that in \texttt{ProductController} method
\texttt{searchDescription(...)} we are passing the value of
\texttt{\$keyword} as well as the array \texttt{\$products} to our Twig
template.

This means that when the Product index page is called from our search
method there will be an extra Twig variable \texttt{keyword} defined,
which we can detect and use as a default value for our search form - so
the user can \textbf{see} the wildcard value for which we are seeing a
list of products:

\begin{verbatim}
    <form action="{{ url('search_description') }}" method="post">
        <input name="keyword"
               {% if keyword is defined %}
               value="{{ keyword }}"
               {% endif %}
        >
        <input type="submit">
    </form>
\end{verbatim}

If there is no \texttt{keyword} Twig variable (it is not defined), then
we don't add a \texttt{value} attribute to this form input.

NOTE: There is a difference between a variable existing and containing
\texttt{NULL} versus no such variable being defined at all - ensure you
write the correct test in Twig to distinguish between these
differences\ldots{}

\part{Symfony code generation}

\hypertarget{crud-controller-and-templates-generation}{%
\chapter{CRUD controller and templates
generation}\label{crud-controller-and-templates-generation}}

\hypertarget{symfonys-crud-generator-project-crud-01}{%
\section{\texorpdfstring{Symfony's CRUD generator (project
\texttt{crud-01})}{Symfony's CRUD generator (project crud-01)}}\label{symfonys-crud-generator-project-crud-01}}

After a delay (and a contribution from me about the sequence of methods
in generated controllers - new before show), Symfony 4 now has a
powerful CRUD generator. Given just an Entity class, the maker-bunder
can now generate for you:

\begin{itemize}
\item
  controller class, for CRUD routes (list / show / new / edit / delete)
\item
  Form class for the entity
\item
  templates for: list / show / new / edit / delete
\end{itemize}

\hypertarget{what-you-need-to-add-to-your-project}{%
\section{What you need to add to your
project}\label{what-you-need-to-add-to-your-project}}

The CRUD maker code needs you to have added 3 other libraries:

\begin{itemize}
\item
  security-csrf
\item
  form
\item
  validator
\end{itemize}

So first, require these into your Symfony project, and then require in
\texttt{make} if you haven't already done so:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ req security-csrf form validator}
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ req make }
\end{Highlighting}
\end{Shaded}

\hypertarget{generating-new-entity-class-category}{%
\section{\texorpdfstring{Generating new Entity class
\texttt{Category}}{Generating new Entity class Category}}\label{generating-new-entity-class-category}}

Generate a new Entity class with a single field \texttt{name} - use
\texttt{make:entity\ Category}, and add field \texttt{name} with
defaults of string, length, and not null.

You should now have a basic entity:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@ORM\textbackslash{}Entity(repositoryClass="App\textbackslash{}Repository\textbackslash{}CategoryRepository")}
\CommentTok{     */}
    \KeywordTok{class}\NormalTok{ Category}
\NormalTok{    \{}
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@ORM\textbackslash{}Id()}
\CommentTok{         * }\AnnotationTok{@ORM\textbackslash{}GeneratedValue()}
\CommentTok{         * }\AnnotationTok{@ORM\textbackslash{}Column(type="integer")}
\CommentTok{         */}
        \KeywordTok{private} \KeywordTok{$id}\OtherTok{;}
    
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@ORM\textbackslash{}Column(type="string",}\CommentTok{ length=255)}
\CommentTok{         */}
        \KeywordTok{private} \KeywordTok{$name}\OtherTok{;}
        
        \StringTok{...}\NormalTok{ getters }\KeywordTok{and}\NormalTok{ setters }
\end{Highlighting}
\end{Shaded}

Migrate this to your database with
\texttt{doctrine:migrations:diff/migrate}.

\hypertarget{generating-crud-for-a-new-entity-class}{%
\section{Generating CRUD for a new Entity
class}\label{generating-crud-for-a-new-entity-class}}

Let's create a new Entity class

You can now create Symfony CRUD for a given entity as follows (in this
example the \texttt{Category} entity is used):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:crud Category}
    
    \ExtensionTok{created}\NormalTok{: src/Controller/CategoryController.php}
    \ExtensionTok{created}\NormalTok{: src/Form/CategoryType.php}
    \ExtensionTok{created}\NormalTok{: templates/category/_delete_form.html.twig}
    \ExtensionTok{created}\NormalTok{: templates/category/_form.html.twig}
    \ExtensionTok{created}\NormalTok{: templates/category/edit.html.twig}
    \ExtensionTok{created}\NormalTok{: templates/category/index.html.twig}
    \ExtensionTok{created}\NormalTok{: templates/category/new.html.twig}
    \ExtensionTok{created}\NormalTok{: templates/category/show.html.twig}
                   
    \ExtensionTok{Success}\NormalTok{! }
       
    \ExtensionTok{Next}\NormalTok{: Check your new CRUD by going to /category/}
\end{Highlighting}
\end{Shaded}

With the single command above Symfony will generate a CRUD controller
(\texttt{CategoryController}) and also create a directory containing
Twig templates (\texttt{/templates/category/index.html.twig} etc.). The
list of new files is:

\begin{verbatim}
    /src/Controller/CategoryController.php

    /src/Form/CategoryType.php

    /templates/category/_form.html.twig
    /templates/category/_delete_form.html.twig
    /templates/category/edit.html.twig
    /templates/category/index.html.twig
    /templates/category/new.html.twig
    /templates/category/show.html.twig
\end{verbatim}

The list of new (annotation-defined routes):

\begin{verbatim}
    /category --> CategoryController->indedxAction()
    /category/new --> CategoryController->newAction()
    /category/show/{id} --> CategoryController->showAction(Category $category)
    /category/delete/{id} --> CategoryController->deleteAction(Category $category)
\end{verbatim}

\hypertarget{the-generated-routes}{%
\section{The generated routes}\label{the-generated-routes}}

Let's see the new routes generated magically for us:

\begin{Shaded}
\begin{Highlighting}[]
     \ExtensionTok{--------------------------}\NormalTok{ ---------- -------- ------ ---------------------------------------}
      \ExtensionTok{Name}\NormalTok{                       Method     Scheme   Host   Path}
     \ExtensionTok{--------------------------}\NormalTok{ ---------- -------- ------ ---------------------------------------}
      \ExtensionTok{category_index}\NormalTok{             ANY        ANY      ANY    /category/}
      \ExtensionTok{category_new}\NormalTok{               GET}\KeywordTok{|}\ExtensionTok{POST}\NormalTok{   ANY      ANY    /category/new}
      \ExtensionTok{category_show}\NormalTok{              GET        ANY      ANY    /category/}\DataTypeTok{\{id\}}
      \ExtensionTok{category_edit}\NormalTok{              GET}\KeywordTok{|}\ExtensionTok{POST}\NormalTok{   ANY      ANY    /category/}\DataTypeTok{\{id\}}\NormalTok{/edit}
      \ExtensionTok{category_delete}\NormalTok{            DELETE     ANY      ANY    /category/}\DataTypeTok{\{id\}}
      \ExtensionTok{...}
\end{Highlighting}
\end{Shaded}

NOTE: The \textbf{sequence} of these routes is important (this was the
error I fixed for this project). a \texttt{GET} requrest with a URL
looking like this: \texttt{/category/1} should be matched to the show
action, i.e.~\texttt{/category/\{id\ =\ 1\}}. But a URL like this
\texttt{/category/new} we want to match with the action. If the show
route attempts to match \textbf{before} the new route, then
\texttt{/category/new} is matched to the show route as
\texttt{/category/\{id\ =\ new\}}, which will then throw a 404 error,
since \texttt{new} is not a valid \texttt{id} for a database
\texttt{Category} object.

Once solution is to ensure the new action method appears \textbf{before}
the show action method in our controller class. If you don't like this
solution (I'm not sure myself), then another solution is to design URL
routes that cannot get mixed up like this - but that means adding
\textbf{verbs} for every every route. E.g. our category routes could be
defined as follows:

\begin{Shaded}
\begin{Highlighting}[]
     \ExtensionTok{--------------------------}\NormalTok{ ---------- -------- ------ ---------------------------------------}
      \ExtensionTok{Name}\NormalTok{                       Method     Scheme   Host   Path}
     \ExtensionTok{--------------------------}\NormalTok{ ---------- -------- ------ ---------------------------------------}
      \ExtensionTok{category_index}\NormalTok{             ANY        ANY      ANY    /category/list}
      \ExtensionTok{category_new}\NormalTok{               GET}\KeywordTok{|}\ExtensionTok{POST}\NormalTok{   ANY      ANY    /category/new}
      \ExtensionTok{category_show}\NormalTok{              GET        ANY      ANY    /category/show/}\DataTypeTok{\{id\}}
      \ExtensionTok{category_edit}\NormalTok{              GET}\KeywordTok{|}\ExtensionTok{POST}\NormalTok{   ANY      ANY    /category/edit/}\DataTypeTok{\{id\}}
      \ExtensionTok{category_delete}\NormalTok{            DELETE     ANY      ANY    /category/delete/}\DataTypeTok{\{id\}}
      \ExtensionTok{...}
\end{Highlighting}
\end{Shaded}

So, for each request, the entity \texttt{category} is followed by its
action verb (\texttt{list}, \texttt{show}, \texttt{new} etc.), and then
finally, if required an \texttt{\{id\}} parameter. This approach has the
advantage of being simple and unambiguous (the sequence of methods in
our controller class no longer matters), But (a) it breaks with common
conventions in routes in Symfony projects, and (b) it means the URLs are
getting longer, and simple, short URLs are one aim (benefit!) of a well
designed web framework.

But for \textbf{your} personal projects, choose a route pattern scheme
that \textbf{you} prefer, so this \textbf{verb} approach might be
something you are happier with. It would also mean you could use
\texttt{GET} metod for \textbf{delete} requests, rather than emulating a
\texttt{DELETE} HTTP request \ldots{}

\hypertarget{the-generated-crud-controller}{%
\section{The generated CRUD
controller}\label{the-generated-crud-controller}}

A controller class was geneated for Category objects in
\texttt{/src/Controller/CategoryController.php}. Let's first look at the
namespaces and class declaration line:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Controller}\OtherTok{;}

    \KeywordTok{use}\NormalTok{ App\textbackslash{}Entity\textbackslash{}Category}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Form\textbackslash{}CategoryType}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Repository\textbackslash{}CategoryRepository}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Bundle\textbackslash{}FrameworkBundle\textbackslash{}Controller\textbackslash{}AbstractController}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Request}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Response}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Routing\textbackslash{}Annotation\textbackslash{}Route}\OtherTok{;}

    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/category")}
\CommentTok{     */}
    \KeywordTok{class}\NormalTok{ CategoryController }\KeywordTok{extends}\NormalTok{ Controller}
\end{Highlighting}
\end{Shaded}

Above we see a set of \texttt{use} statements, and then an interesting
class comment. The \texttt{@Route} annotation comment declares a route
`prefix' which will at the beginning of any \texttt{@Route} annotations
for individual controller methods. So, for example, the new action will
have the route \texttt{/category/new}.

If we look in directory \texttt{/templates/category/} we'll see the
following generated main templates:

\begin{verbatim}
    edit.html.twig
    index.html.twig
    new.html.twig
    show.html.twig
\end{verbatim}

and the 2 partial templates (that are included in other pages):

\begin{verbatim}
    _form.html.twig
    _delete_form.html.twig
\end{verbatim}

Note that all these generated templates extend Twig class
\texttt{base.html.twig}.

\hypertarget{the-generated-index-a.k.a.-list-controller-method}{%
\section{The generated index (a.k.a. list) controller
method}\label{the-generated-index-a.k.a.-list-controller-method}}

Below we can see the code for \texttt{indexAction()} that retrieves and
then passes an array of \texttt{Category} objects to template
`category/index.html.twig.

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/",}\CommentTok{ name="category_index", methods=\{"GET"\})}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{(}\NormalTok{CategoryRepository }\KeywordTok{$categoryRepository}\OtherTok{)}\NormalTok{: Response}
\NormalTok{    \{}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\StringTok{'category/index.html.twig'}\OtherTok{,} \OtherTok{[}
            \StringTok{'categories'}\NormalTok{ => }\KeywordTok{$categoryRepository}\NormalTok{->findAll}\OtherTok{(),}
        \OtherTok{]);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Note how this uses the `magic' of the Param Converter to get a reference
to the \texttt{StudentRepository} as a method parameter. This makes it a
one-liner to \texttt{findAll()} objects in the database and pass them on
to the Twig template.

If you prefer, you can re-write the last statement in the more familiar
form:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$argsArray}\NormalTok{ = }\OtherTok{[}
        \StringTok{'categories'}\NormalTok{ => }\KeywordTok{$categoryRepository}\NormalTok{->findAll}\OtherTok{()}
    \OtherTok{];}

    \KeywordTok{$template}\NormalTok{ = }\StringTok{'category/index.html.twig'}\OtherTok{;}
    \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$argsArray}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

Twig template \texttt{category/index.html.twig} loops through array
\texttt{categories}, wrapping HTML table row tags around each entity's
content:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    \{% for category in categories %\}}
        \KeywordTok{<tr>}
            \KeywordTok{<td>}\NormalTok{\{\{ category.id \}\}}\KeywordTok{</td>}
            \KeywordTok{<td>}\NormalTok{\{\{ category.name \}\}}\KeywordTok{</td>}
            \KeywordTok{<td>}
                \KeywordTok{<a}\OtherTok{ href=}\StringTok{"\{\{ path('category_show', \{'id': category.id\}) \}\}"}\KeywordTok{>}\NormalTok{show}\KeywordTok{</a>}
                \KeywordTok{<a}\OtherTok{ href=}\StringTok{"\{\{ path('category_edit', \{'id': category.id\}) \}\}"}\KeywordTok{>}\NormalTok{edit}\KeywordTok{</a>}
            \KeywordTok{</td>}
        \KeywordTok{</tr>}
\NormalTok{    \{% else %\}}
        \KeywordTok{<tr>}
            \KeywordTok{<td}\OtherTok{ colspan=}\StringTok{"3"}\KeywordTok{>}\NormalTok{no records found}\KeywordTok{</td>}
        \KeywordTok{</tr>}
\NormalTok{    \{% endfor %\}}
\end{Highlighting}
\end{Shaded}

Let's create a CSS file for table borders and padding in a new file
\texttt{/public/css/table.css};

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    table}\OperatorTok{,}\NormalTok{ tr}\OperatorTok{,}\NormalTok{ td}\OperatorTok{,}\NormalTok{ th \{}
        \KeywordTok{border}\NormalTok{: }\DecValTok{0.1}\DataTypeTok{rem} \DecValTok{solid} \ConstantTok{black}\OperatorTok{;}
        \KeywordTok{padding}\NormalTok{: }\DecValTok{0.5}\DataTypeTok{rem}\OperatorTok{;}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Remember in \texttt{/templates/base.html.twig} there is a block for
style sheets:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{<head>}
        \KeywordTok{<meta}\OtherTok{ charset=}\StringTok{"UTF-8"}\KeywordTok{>}
        \KeywordTok{<title>}\NormalTok{\{% block title %\}Welcome!\{% endblock %\}}\KeywordTok{</title>}
\NormalTok{        \{% block stylesheets %\}\{% endblock %\}}
    \KeywordTok{</head>}
\end{Highlighting}
\end{Shaded}

So now we can edit template \texttt{category/index.html.twig} to add a
stylesheet block import of this CSS stylesheet:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    \{% block stylesheets %\}}
        \KeywordTok{<style>}
            \ImportTok{@import} \StringTok{'/css/table.css'}\OperatorTok{;}
        \KeywordTok{</style>}
\NormalTok{    \{% endblock %\}}
\end{Highlighting}
\end{Shaded}

Figure \ref{category_index} shows a screenshot of how our list of
categories looks,rendered by the \texttt{categories/index.html.twig}
template.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/7fa5d9dcad73af22289403074f4721ab58701320.png}
\caption{List of categories in HTML table. \label{category_index}}
\end{figure}

\hypertarget{the-generated-new-method}{%
\section{\texorpdfstring{The generated \texttt{new()}
method}{The generated new() method}}\label{the-generated-new-method}}

The method and Twig template for a new \texttt{Category} work just as
you might expect. For \texttt{GET} requests (and invalid \texttt{POST}
submissions) a form will be displayed. Upon valid \texttt{POST}
submission the \texttt{\$category} object populated swith the form data
will be persisted to the database, and then the user will be redirected
to the \texttt{edit} action form for the newly created entity.

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/new",}\CommentTok{ name="category_new", methods=\{"GET","POST"\})}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function} \KeywordTok{new}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}\NormalTok{: Response}
\NormalTok{    \{}
        \KeywordTok{$category}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Category}\OtherTok{();}
        \KeywordTok{$form}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->createForm}\OtherTok{(}\NormalTok{CategoryType::}\KeywordTok{class}\OtherTok{,} \KeywordTok{$category}\OtherTok{);}
        \KeywordTok{$form}\NormalTok{->handleRequest}\OtherTok{(}\KeywordTok{$request}\OtherTok{);}

        \KeywordTok{if} \OtherTok{(}\KeywordTok{$form}\NormalTok{->isSubmitted}\OtherTok{()}\NormalTok{ && }\KeywordTok{$form}\NormalTok{->isValid}\OtherTok{())}\NormalTok{ \{}
            \KeywordTok{$entityManager}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{();}
            \KeywordTok{$entityManager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$category}\OtherTok{);}
            \KeywordTok{$entityManager}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}

            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'category_index'}\OtherTok{);}
\NormalTok{        \}}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\StringTok{'category/new.html.twig'}\OtherTok{,} \OtherTok{[}
            \StringTok{'category'}\NormalTok{ => }\KeywordTok{$category}\OtherTok{,}
            \StringTok{'form'}\NormalTok{ => }\KeywordTok{$form}\NormalTok{->createView}\OtherTok{(),}
        \OtherTok{]);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Note that it redirects to the edit method (\texttt{category\_index})
after a successful object creation and saving to the database.

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'category_show'}\OtherTok{,} \OtherTok{[}\StringTok{'id'}\NormalTok{ => }\KeywordTok{$category}\NormalTok{->getId}\OtherTok{()]);}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-generated-show-method}{%
\section{\texorpdfstring{The generated \texttt{show()}
method}{The generated show() method}}\label{the-generated-show-method}}

Initially, the generated `show' method looks just as we might write
ourselves:

\begin{Shaded}
\begin{Highlighting}[]
   \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/\{id\}",}\CommentTok{ name="category_show", methods=\{"GET"\})}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ show}\OtherTok{(}\NormalTok{Category }\KeywordTok{$category}\OtherTok{)}\NormalTok{: Response}
\NormalTok{    \{}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\StringTok{'category/show.html.twig'}\OtherTok{,} \OtherTok{[}
            \StringTok{'category'}\NormalTok{ => }\KeywordTok{$category}\OtherTok{,}
        \OtherTok{]);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

But looking closely, we see that while the route specifies parameter
\texttt{\{id\}}, the method declaration species a parameter of
\texttt{Category\ \$category}. Also the code in the method makes no
reference to the \texttt{Category} entity repository. So by some
\textbf{magic} the numeric `id' in the request path has used to retrieve
the corresponding \texttt{Category} record from the database!

This magic is the work of the Symfony `Param Converter'. Also, of
course, if there is no record found in table \texttt{category} that
corresponds to the received `id', then a 404 not-found-exception will be
thrown.

Learn more about the `param converter' at the Symfony documentation
pages:

\begin{itemize}
\tightlist
\item
  \url{https://symfony.com/doc/current/best_practices/controllers.html\#using-the-paramconverter}
\end{itemize}

\hypertarget{the-generated-edit-method}{%
\section{\texorpdfstring{The generated \texttt{edit()}
method}{The generated edit() method}}\label{the-generated-edit-method}}

The `edit' generated method is as you might expect. The edit method
creates a form, and also include code to process valid submission of the
edited entity.

Note that it redirects to itself upon successful save of edits. You
could change this to redirect to the show route as described above for
the new action.

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/\{id\}/edit",}\CommentTok{ name="category_edit", methods=\{"GET","POST"\})}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ edit}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{,}\NormalTok{ Category }\KeywordTok{$category}\OtherTok{)}\NormalTok{: Response}
\NormalTok{    \{}
        \KeywordTok{$form}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->createForm}\OtherTok{(}\NormalTok{CategoryType::}\KeywordTok{class}\OtherTok{,} \KeywordTok{$category}\OtherTok{);}
        \KeywordTok{$form}\NormalTok{->handleRequest}\OtherTok{(}\KeywordTok{$request}\OtherTok{);}

        \KeywordTok{if} \OtherTok{(}\KeywordTok{$form}\NormalTok{->isSubmitted}\OtherTok{()}\NormalTok{ && }\KeywordTok{$form}\NormalTok{->isValid}\OtherTok{())}\NormalTok{ \{}
            \KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{()}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}

            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'category_index'}\OtherTok{,} \OtherTok{[}
                \StringTok{'id'}\NormalTok{ => }\KeywordTok{$category}\NormalTok{->getId}\OtherTok{(),}
            \OtherTok{]);}
\NormalTok{        \}}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\StringTok{'category/edit.html.twig'}\OtherTok{,} \OtherTok{[}
            \StringTok{'category'}\NormalTok{ => }\KeywordTok{$category}\OtherTok{,}
            \StringTok{'form'}\NormalTok{ => }\KeywordTok{$form}\NormalTok{->createView}\OtherTok{(),}
        \OtherTok{]);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-generated-delete-method}{%
\section{\texorpdfstring{The generated \texttt{delete()}
method}{The generated delete() method}}\label{the-generated-delete-method}}

The `delete' method deletes the entity and redirects back to the list of
categories for the `index' action. Notice that an annotation comment
states that this controller method is in response to \texttt{DELETE}
method requests (more about this below).

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/\{id\}",}\CommentTok{ name="category_delete", methods=\{"DELETE"\})}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ delete}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{,}\NormalTok{ Category }\KeywordTok{$category}\OtherTok{)}\NormalTok{: Response}
\NormalTok{    \{}
        \KeywordTok{if} \OtherTok{(}\KeywordTok{$this}\NormalTok{->isCsrfTokenValid}\OtherTok{(}\StringTok{'delete'}\NormalTok{.}\KeywordTok{$category}\NormalTok{->getId}\OtherTok{(),} \KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'_token'}\OtherTok{)))}\NormalTok{ \{}
            \KeywordTok{$entityManager}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{();}
            \KeywordTok{$entityManager}\NormalTok{->remove}\OtherTok{(}\KeywordTok{$category}\OtherTok{);}
            \KeywordTok{$entityManager}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}
\NormalTok{        \}}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'category_index'}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

The delete form is reached via a Twig include from the edit template
(\texttt{templates/category/edit.html.twig}):

\begin{verbatim}
    {% extends 'base.html.twig' %}
    
    {% block title %}Edit Category{% endblock %}
    
    {% block body %}
        <h1>Edit Category</h1>
    
        {{ include('category/_form.html.twig', {'button_label': 'Update'}) }}
    
        <a href="{{ path('category_index') }}">back to list</a>
    
        {{ include('category/_delete_form.html.twig') }}
    {% endblock %}
\end{verbatim}

If we actually look at the HTML source of this
\texttt{\_delete\_form.html.twig} button-form, we can see that it is
actually submitted with the HTTP \texttt{post} action, along with a
hidden form field named \texttt{\_method} with the value
\texttt{DELETE}. This kind of approach means we can write our
controllers as if they are responding to the full range of HTTP methods
(\texttt{GET}, \texttt{POST}, \texttt{PUT}, \texttt{DELETE} and perhaps
\texttt{PATCH}).

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{<form}\OtherTok{ method=}\StringTok{"post"}\OtherTok{ action=}\StringTok{"\{\{ path('category_delete', \{'id': category.id\}) \}\}"}\OtherTok{ onsubmit=}\StringTok{"return confirm('Are you sure you want to delete this item?');"}\KeywordTok{>}
        \KeywordTok{<input}\OtherTok{ type=}\StringTok{"hidden"}\OtherTok{ name=}\StringTok{"_method"}\OtherTok{ value=}\StringTok{"DELETE"}\KeywordTok{>}
        \KeywordTok{<input}\OtherTok{ type=}\StringTok{"hidden"}\OtherTok{ name=}\StringTok{"_token"}\OtherTok{ value=}\StringTok{"\{\{ csrf_token('delete' ~ category.id) \}\}"}\KeywordTok{>}
        \KeywordTok{<button}\OtherTok{ class=}\StringTok{"btn"}\KeywordTok{>}\NormalTok{Delete}\KeywordTok{</button>}
    \KeywordTok{</form>}
\end{Highlighting}
\end{Shaded}

\part{Sessions}

\hypertarget{introduction-to-symfony-sessions}{%
\chapter{Introduction to Symfony
sessions}\label{introduction-to-symfony-sessions}}

\hypertarget{create-a-new-project-from-scratch-project-sessions01}{%
\section{\texorpdfstring{Create a new project from scratch (project
\texttt{sessions01})}{Create a new project from scratch (project sessions01)}}\label{create-a-new-project-from-scratch-project-sessions01}}

Let's start with a brand new project to learn about Symfony sessions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ create-project symfony/skeleton session01}
\end{Highlighting}
\end{Shaded}

Let's add to our project the Twig and annotations packages\footnote{And
  add the server package to \texttt{-\/-dev} if that's how you are
  testing locally.}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ req --dev server make}
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ req twig annotations}
\end{Highlighting}
\end{Shaded}

It's also a good idea to also include the \textbf{Debug} pacakge:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ req --dev debug}
\end{Highlighting}
\end{Shaded}

\hypertarget{default-controller---hello-world}{%
\section{Default controller - hello
world}\label{default-controller---hello-world}}

Create a new Default controller that renders a Twig template to say
\texttt{Hello\ World} to us.

So the controller should look as this (you can speed things up using
\texttt{make} and then editing the created file). If editing a generated
controlle, don't forget to change the route pattern from
\texttt{/default} to the website root of \texttt{\textbackslash{}} in
the annotation comment :

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Controller}\OtherTok{;}

    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Routing\textbackslash{}Annotation\textbackslash{}Route}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Bundle\textbackslash{}FrameworkBundle\textbackslash{}Controller\textbackslash{}Controller}\OtherTok{;}

    \KeywordTok{class}\NormalTok{ DefaultController }\KeywordTok{extends}\NormalTok{ Controller}
\NormalTok{    \{}
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/",}\CommentTok{ name="default")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ indexAction}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{$template}\NormalTok{ = }\StringTok{'default/index.html.twig'}\OtherTok{;}
            \KeywordTok{$args}\NormalTok{ = }\OtherTok{[];}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Our home page default template \texttt{default/index.html.twig} can be
this simple\footnote{If we have a suitable HTML skeleton base template.}:

\begin{verbatim}
    {% extends 'base.html.twig' %}

    {% block body %}
    <p>
        Hello World
    </p>
    {% endblock %}
\end{verbatim}

\hypertarget{twig-foregroundbackground-colours-sessions02}{%
\section{\texorpdfstring{Twig foreground/background colours
(\texttt{sessions02})}{Twig foreground/background colours (sessions02)}}\label{twig-foregroundbackground-colours-sessions02}}

Let's start out Symfony sessions learning with the ability to store (and
remember) foreground and background colours\footnote{I'm not going to
  get into a colo(u)rs naming discussion. But you may prefer to just
  always use US-English spelling (\emph{sans} `u') since most computer
  language functions and variables are spelt the US-English way}.

First, let's just pass in a Twig variable from our controller, so that
we can write some Twig to work with these variables. Later we'll not
receive this variable from the controller, instead we'll use Twig to
search for colors in the \textbf{session} and set these variables
accordingly. But for now, we'll pass a variable from our controller to
Twig:

\begin{itemize}
\item
  \texttt{colors}: an array holding 2 colors for foreground (text color)
  and background color

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{$colors}\NormalTok{ = }\OtherTok{[}
    \StringTok{'foreground'}\NormalTok{ => }\StringTok{'white'}\OtherTok{,}
    \StringTok{'background'}\NormalTok{ => }\StringTok{'black'}
\OtherTok{];}
\end{Highlighting}
\end{Shaded}
\end{itemize}

So our controller needs to create this variable and pass it on to Twig:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{$colors}\NormalTok{ = }\OtherTok{[}
            \StringTok{'foreground'}\NormalTok{ => }\StringTok{'white'}\OtherTok{,}
            \StringTok{'background'}\NormalTok{ => }\StringTok{'black'}
        \OtherTok{];}

        \KeywordTok{$template}\NormalTok{ = }\StringTok{'default/index.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
            \StringTok{'colors'}\NormalTok{ => }\KeywordTok{$colors}\OtherTok{,}
        \OtherTok{];}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Next let's add some HTML in our \texttt{default/index.html.twig} page to
display the value of our 2 stored values.

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{<ul>}
\NormalTok{        \{% for property, color in colors %\}}
            \KeywordTok{<li>}
\NormalTok{                \{\{ property \}\} = \{\{ color \}\}}
            \KeywordTok{</li>}
\NormalTok{        \{% endfor %\}}
    \KeywordTok{</ul>}
\end{Highlighting}
\end{Shaded}

Note that Twig offers a key-value array loop just like PHP, in the form:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    \{% for }\KeywordTok{<key>}\NormalTok{, }\KeywordTok{<value>}\NormalTok{ in }\KeywordTok{<array>}\NormalTok{ %\}}
\end{Highlighting}
\end{Shaded}

Figure \ref{twig_blackwhite} shows a screenshot of our home page listing
these Twig variables.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/685d4f89bf346bb223565ae18fae3a64be9f00e9.png}
\caption{Screenshot of home page listing Twig color array variable.
\label{twig_blackwhite}}
\end{figure}

Now, let's add a second controller method, named \texttt{pinkblue()}
that passes 2 different colours to our Twig template:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/pinkblue",}\CommentTok{ name="pinkblue")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ pinkblue}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{$colors}\NormalTok{ = }\OtherTok{[}
            \StringTok{'foreground'}\NormalTok{ => }\StringTok{'blue'}\OtherTok{,}
            \StringTok{'background'}\NormalTok{ => }\StringTok{'pink'}
        \OtherTok{];}

        \KeywordTok{$template}\NormalTok{ = }\StringTok{'default/index.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
            \StringTok{'colors'}\NormalTok{ => }\KeywordTok{$colors}\OtherTok{,}
        \OtherTok{];}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Figure \ref{twig_colours} shows a screenshot of our second route,
passing pink and blue colors to the Twig template.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/208cfa06fb9ee48e693def7d3b21bfe0a1bed489.png}
\caption{Screenshot of \texttt{/pinkblue} route passing different
colours to Twig. \label{twig_colours}}
\end{figure}

\hypertarget{working-with-sessions-in-symfony-controller-methods-project-session03}{%
\section{\texorpdfstring{Working with sessions in Symfony Controller
methods (project
\texttt{session03})}{Working with sessions in Symfony Controller methods (project session03)}}\label{working-with-sessions-in-symfony-controller-methods-project-session03}}

First, since we are going to be using sessions, let's return our default
\texttt{index()} controller method to pass no arguments to the Twig
template. This is because any color variables will be stored in the
session and set by other controllers:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/",}\CommentTok{ name="default")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{$template}\NormalTok{ = }\StringTok{'default/index.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
        \OtherTok{];}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

All we need to write to work with the current session object in a
Symfony controller method is the following statement:

\begin{verbatim}
    $session = new Session();
\end{verbatim}

Note, you also need to add the following \texttt{use} statement for the
class using this code:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Session\textbackslash{}Session}\OtherTok{;}
\end{Highlighting}
\end{Shaded}

Note - do \textbf{not} use any of the standard PHP command for working
with sessions. Do all your Symfony work through the Symfony session API.
So, for example, do not use either of these PHP functions:

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{session_start}\OtherTok{();} \CommentTok{// ----- do NOT use this in Symfony -------}
    \FunctionTok{session_destroy}\OtherTok{();} \CommentTok{// ----- do NOT use this in Symfony -------}
\end{Highlighting}
\end{Shaded}

You can now set/get values in the session by making reference to
\texttt{\$session}.

Note: You may wish to read about \textbf{how to start a session in
Symfony}\footnote{While a session will be started automatically if a
  session action takes places (if no session was already started), the
  Symfony documentation recommends your code starts a session if one is
  required. Here is the code to do so:
  \texttt{\$session-\textgreater{}start()}, but to be honest it's
  simpler to rely on Symfony to decide when to start a new session,
  since sometimes integrating this into your controller logic can be
  tricky (especially with controller redirects). You'll get errors if
  you try to start an already started session \ldots{}}.

\hypertarget{symfonys-2-session-bags}{%
\section{Symfony's 2 session `bags'}\label{symfonys-2-session-bags}}

We've already met sessions - the Symfony `flash bag', which stores
messages in the session for one request cycle.

Symfony also offers a second kind of session storage, session `attribute
bags', which store values for longer, and offer a namespacing approach
to accessing values in session arrays.

We store values in the attribute bag as follows using the
\texttt{session-\textgreater{}set()} method:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$session}\NormalTok{->set}\OtherTok{(}\StringTok{'<key>'}\OtherTok{,}\NormalTok{ <value>}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

Here's how we store our colors array in the Symfony application session
from our controllers:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{// create colors array}
    \KeywordTok{$colors}\NormalTok{ = }\OtherTok{[}
        \StringTok{'foreground'}\NormalTok{ => }\StringTok{'blue'}\OtherTok{,}
        \StringTok{'background'}\NormalTok{ => }\StringTok{'pink'}
    \OtherTok{];}

    \CommentTok{// store colours in session 'colours'}
    \KeywordTok{$session}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Session}\OtherTok{();}
    \KeywordTok{$session}\NormalTok{->set}\OtherTok{(}\StringTok{'colors'}\OtherTok{,} \KeywordTok{$colors}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

Note - also learn how to `unset' values when you learn to set them. We
can clear everything in a session by writing:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$session}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Session}\OtherTok{();}
    \KeywordTok{$session}\NormalTok{->clear}\OtherTok{();}
\end{Highlighting}
\end{Shaded}

\hypertarget{storing-values-in-the-session-in-a-controller-action}{%
\section{Storing values in the session in a controller
action}\label{storing-values-in-the-session-in-a-controller-action}}

Let's refactor \texttt{DefaultController} method \texttt{pinkBlue()}
which has route \texttt{/pinkblue} with logic to store colours in the
session and then re-direct Symfony to the home page route:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/pinkblue",}\CommentTok{ name="pinkblue")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ pinkBlue}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// create colors array}
        \KeywordTok{$colors}\NormalTok{ = }\OtherTok{[}
            \StringTok{'foreground'}\NormalTok{ => }\StringTok{'blue'}\OtherTok{,}
            \StringTok{'background'}\NormalTok{ => }\StringTok{'pink'}
        \OtherTok{];}

        \CommentTok{// store colours in session 'colours'}
        \KeywordTok{$session}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Session}\OtherTok{();}
        \KeywordTok{$session}\NormalTok{->set}\OtherTok{(}\StringTok{'colors'}\OtherTok{,} \KeywordTok{$colors}\OtherTok{);}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'default'}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

If you add the Symfony Profiler
(\texttt{composer\ req\ -\/-dev\ profiler}) you can view session values
in its session tab,, as show in Figure \ref{session_profiler}.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/b55c386213380dcd9a550b90e2383b0bc3e55ffa.png}
\caption{Homepage with session colours applied via CSS.
\label{session_profiler}}
\end{figure}

Learn more at about Symfony sessions at:

\begin{itemize}
\tightlist
\item
  \href{http://symfony.com/doc/current/components/http_foundation/sessions.html}{Symfony
  and sessions}
\end{itemize}

\hypertarget{twig-function-to-retrieve-values-from-session}{%
\section{Twig function to retrieve values from
session}\label{twig-function-to-retrieve-values-from-session}}

Twig offers a function to attempt to retrieve a named value in the
session:

\begin{verbatim}
    app.session.get('<attribute_key>')
\end{verbatim}

If fact the \texttt{app} Twig variable allows us to read lots about the
Symfony, including:

\begin{itemize}
\item
  request (\texttt{app.request})
\item
  user (\texttt{app.user})
\item
  session (\texttt{app.session})
\item
  environment (\texttt{app.environment})
\item
  debug mode (\texttt{app.debug})
\end{itemize}

Read more about Twig \texttt{app} in the Symfony documentation pages:

\begin{itemize}
\tightlist
\item
  \url{https://symfony.com/doc/current/templating/app_variable.html}
\end{itemize}

\hypertarget{attempt-to-read-colors-array-property-from-the-session}{%
\section{\texorpdfstring{Attempt to read \texttt{colors} array property
from the
session}{Attempt to read colors array property from the session}}\label{attempt-to-read-colors-array-property-from-the-session}}

We can store values in Twig variables using the
\texttt{set\ \textless{}var\textgreater{}\ =\ \textless{}expression\textgreater{}}
statement. So let's try to read an array of colours from the session
named \texttt{colors}, and store in a local Twig variable names
\texttt{colors}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    \{% set colors = app.session.get('colors') %\}}
\end{Highlighting}
\end{Shaded}

After this statement, \texttt{colors} either contains the array
retrieved from the session, or it is \texttt{null} if no such variable
was found in the session.

So we can test for \texttt{null}, and if \texttt{null} is the value of
\texttt{colors} then we can set \texttt{colors} to our default
(black/white) values:

\begin{verbatim}
    {# ------ attempt to read 'colors' from session ----- #}
    {% set colors = app.session.get('colors') %}

    {# ------ if 'null' then not found in session ----- #}
    {# ------ so set to black/white default values ----- #}
    {% if colors is null %}
        {# ------ set our default colours array ----- #}
        {% set colors = {
            'foreground': 'black',
            'background': 'white'
        }
        %}
    {% endif %}
\end{verbatim}

So at this point we know \texttt{colors} contains an array, either from
the session or our default values (black/white) set in the Twig
template.

The full listing for our Twig template \texttt{default/index.html.twig}
looks as follows: first part logic testing session, second part
outputting details about the variables:

\begin{verbatim}
    {# ------ attempt to read 'colors' from session ----- #}
    {% set colors = app.session.get('colors') %}

    {# ------ if 'null' then no found in session ----- #}
    {% if colors is null %}
        {# ------ set our default colours array ----- #}
        {% set colors = {
            'foreground': 'black',
            'background': 'white'
        }
        %}
    {% endif %}

    <ul>
        {% for property, color in colors %}
            <li>
                {{ property }} = {{ color }}
            </li>
        {% endfor %}
    </ul>

    <p>
        Hello World
    </p>
\end{verbatim}

Finally, we can add another route method in our controller to
\textbf{clear the session}, i.e.~telling our site to reset to the
default colors defined in our Twig template:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/default",}\CommentTok{ name="default_colors")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ defaultColors}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// store colours in session 'colours'}
        \KeywordTok{$session}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Session}\OtherTok{();}
        \KeywordTok{$session}\NormalTok{->clear}\OtherTok{();}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'default'}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{applying-colours-in-html-head-style-element-project-session04}{%
\section{\texorpdfstring{Applying colours in HTML head
\texttt{\textless{}style\textgreater{}} element (project
\texttt{session04})}{Applying colours in HTML head \textless{}style\textgreater{} element (project session04)}}\label{applying-colours-in-html-head-style-element-project-session04}}

Since we have an array of colours, let's finish this task logically by
moving our code into \texttt{base.html.twig} and creating some CSS to
actually set the foreground and background colours using these values.

So we remove the Twig code from template \texttt{index.html.twig}. So
this template just adds our \texttt{Hello\ World} paragraph to the
\texttt{body} block:

\begin{verbatim}
    {% extends 'base.html.twig' %}
    
    {% block title %}Hello Default Controller!{% endblock %}
    
    {% block body %}
    <p>
        Hello World
    </p>
    {% endblock %}
\end{verbatim}

We'll place our (slightly edited) Twig code into \texttt{base.html.twig}
as follows. Add the following \textbf{before} we start the HTML doctype
etc.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    \{# ------ attempt to read 'colors' from session ----- #\}}
\NormalTok{    \{% set colors = app.session.get('colors') %\}}
    
\NormalTok{    \{# ------ if 'null' then no found in session ----- #\}}
\NormalTok{    \{% if colors is null %\}}
\NormalTok{        \{# ------ set our default colours array ----- #\}}
\NormalTok{        \{% set colors = \{}
\NormalTok{            'foreground': 'black',}
\NormalTok{            'background': 'white'}
\NormalTok{        \}}
\NormalTok{        %\}}
\NormalTok{    \{% endif %\}}
\end{Highlighting}
\end{Shaded}

So now we know we have our Twig variable \texttt{colours} assigned
values (either from the session, or from the defaults. Now we can update
the \texttt{\textless{}head\textgreater{}} of our HTML to include a new
\texttt{body\ \{\}} CSS rule, that pastes in the values of our Twig
array
\texttt{colours{[}\textquotesingle{}foreground\textquotesingle{}{]}} and
\texttt{colours{[}\textquotesingle{}background\textquotesingle{}{]}}:

\begin{verbatim}
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8" />
        <title>MGW - {% block pageTitle %}{% endblock %}</title>

        <style>
            @import '/css/flash.css';
            {% block stylesheets %}
            {% endblock %}

            body {
                color: {{ colours['foreground'] }};
                background-color: {{ colours['background'] }};
            }
        </style>
    </head>
\end{verbatim}

Figure \ref{colours_css_index} shows our text and background colours
applied to the CSS of the website homepage.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/1aca0e32b45d577ec003c85e186871abd9ba9b56.png}
\caption{Homepage with session colours applied via CSS.
\label{colours_css_index}}
\end{figure}

\hypertarget{testing-whether-an-attribute-is-present-in-the-current-session}{%
\section{Testing whether an attribute is present in the current
session}\label{testing-whether-an-attribute-is-present-in-the-current-session}}

Before we work with a session attribute in a PHP controller method, we
may wish to test whether it is present. We can test for the existance of
an attribute in the session bag as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{if}\OtherTok{(}\KeywordTok{$session}\NormalTok{->has}\OtherTok{(}\StringTok{'<key>'}\OtherTok{))}\NormalTok{\{}
         \CommentTok{//do something}
\NormalTok{     \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{removing-an-item-from-the-session-attribute-bag}{%
\section{Removing an item from the session attribute
bag}\label{removing-an-item-from-the-session-attribute-bag}}

To remove an item from the session attribute bag write the following:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$session}\NormalTok{->remove}\OtherTok{(}\StringTok{'<key>'}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

\hypertarget{clearing-all-items-in-the-session-attribute-bag}{%
\section{Clearing all items in the session attribute
bag}\label{clearing-all-items-in-the-session-attribute-bag}}

To remove all items from the session attribute bag write the following:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$session}\NormalTok{->clear}\OtherTok{();}
\end{Highlighting}
\end{Shaded}

\hypertarget{working-with-a-session-basket-of-products}{%
\chapter{Working with a session `basket' of
products}\label{working-with-a-session-basket-of-products}}

\hypertarget{shopping-cart-of-products-project-session05}{%
\section{\texorpdfstring{Shopping cart of products (project
\texttt{session05})}{Shopping cart of products (project session05)}}\label{shopping-cart-of-products-project-session05}}

When you're leaning sessions, you need to build a `shopping cart'! Let's
create CRUD for some Products and then offer a shopping baset.

We will have an \texttt{basket} item in the session, containing an array
of \texttt{Product} objects adding the the basket. This array will be
indexed by the \texttt{id} property of each Product (so we won't add the
same Product twice to the array), and items are easy to remove by
unsetting.

\hypertarget{create-a-new-project-with-the-required-packages}{%
\section{Create a new project with the required
packages}\label{create-a-new-project-with-the-required-packages}}

Let's start with a brand new project to work with for shopping baskets
in sessions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ create-project symfony/skeleton session05}
\end{Highlighting}
\end{Shaded}

Let's add to our project the Twig and annotations packages:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ req twig annotations}
\end{Highlighting}
\end{Shaded}

Let's add to our project the server, make and debug developer packages:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ req --dev server debug}
\end{Highlighting}
\end{Shaded}

Now let's add the packages for working with databases and CRUD
generation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ req doctrine security-csrf validator form}
\end{Highlighting}
\end{Shaded}

\hypertarget{create-a-product-entity-generate-its-crud}{%
\section{Create a Product entity \& generate its
CRUD}\label{create-a-product-entity-generate-its-crud}}

Make a new \texttt{Product} entity:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:entity Product}
\end{Highlighting}
\end{Shaded}

In in the interactive mode add the following properties:

\begin{itemize}
\tightlist
\item
  \texttt{description} (defaults: string/255/not nullable)
\item
  \texttt{image} (defaults: string/255/not nullable)
\item
  \texttt{price} (float)
\end{itemize}

You should now have an entity class \texttt{src/Entity/Product} with
accessor methods and database annotation comments for each property. You
should also have a repository class
\texttt{src/Repository/ProductRepository}.

Configure your \texttt{.env} database settings, e.g.~to setup for MySQL
database \texttt{sessions01} have the following:

\begin{verbatim}
    DB_USER=root
    DB_PASSWORD=pass
    DB_HOST=127.0.0.1
    DB_PORT=3306
    DB_NAME=sessions01
    DATABASE_URL=mysql://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}
\end{verbatim}

Generate the database, and migrations and migrate:

\begin{verbatim}
    $ php bin/console doctrine:database:create
    $ php bin/console doctrine:migrations:diff
    $ php bin/console doctrine:migrations:migrate
\end{verbatim}

Then generate CRUD for this entity (i.e.~a ProductController, templates
in \texttt{/templates/product/}, and a form class
\texttt{src/Form/ProductType.php}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:crud Product}
\end{Highlighting}
\end{Shaded}

\hypertarget{homepage---link-to-products-home}{%
\section{Homepage - link to products
home}\label{homepage---link-to-products-home}}

Create a default controller:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:controller Default}
\end{Highlighting}
\end{Shaded}

Set this controller's route to the website root \texttt{/} (rather than
\texttt{/default}), and make the Twig template for the default homepage
be a link to generated route \texttt{product\_index}:

\begin{verbatim}
    <p>
        Hello World
    </p>

    <a href="{{ url('product_index') }}">list of products</a>
\end{verbatim}

Run the server and use your CRUD to add a few products into the
database, e.g.:

\begin{verbatim}
    Id  Description      Image          Price
    1   hammer           hammer.png     5.99
    2   ladder           ladder.png     19.99
    3   bucket of nails  nails.png       0.99
\end{verbatim}

\hypertarget{basket-index-list-basket-contents-project-sessions07}{%
\section{\texorpdfstring{Basket index: list basket contents (project
\texttt{sessions07})}{Basket index: list basket contents (project sessions07)}}\label{basket-index-list-basket-contents-project-sessions07}}

We'll write our code in a new controller class
\texttt{BasketController.php} in directory \texttt{/src/Controller/}.

Generate our new controller:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:controller Basket}
\end{Highlighting}
\end{Shaded}

Here is our class (with a couple of changes to routes, and a
\texttt{use} statement for \texttt{Session} class we need to use in a
minute):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php}
    
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Controller}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Bundle\textbackslash{}FrameworkBundle\textbackslash{}Controller\textbackslash{}AbstractController}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Routing\textbackslash{}Annotation\textbackslash{}Route}\OtherTok{;}
    
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/basket",}\CommentTok{ name="basket_")}
\CommentTok{     */}
    \KeywordTok{class}\NormalTok{ BasketController }\KeywordTok{extends}\NormalTok{ AbstractController}
\NormalTok{    \{}
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/",}\CommentTok{ name="index")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{$template}\NormalTok{ = }\StringTok{'basket/index.html.twig'}\OtherTok{;}
            \KeywordTok{$args}\NormalTok{ = }\OtherTok{[];}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Note:

\begin{itemize}
\item
  we have added the \texttt{@Route} prefix \texttt{/basket} to all
  controller actions in this class by writing a \texttt{@Route}
  annotation comment for the class declaration.
\item
  the basket index controller action is very simple, since all the work
  extracting values from the session will be done by our Twig template.
  So our index action simply returns the Twig rendering of template
  \texttt{basket/index.html.twig}
\end{itemize}

\hypertarget{controller-method---clear}{%
\section{\texorpdfstring{Controller method -
\texttt{clear()}}{Controller method - clear()}}\label{controller-method---clear}}

Let's write another simple method next - a method to remove any
\texttt{basket} attribute from the session. We can achieve this with the
statement
\texttt{\$session-\textgreater{}remove(\textquotesingle{}basket\textquotesingle{})}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/clear",}\CommentTok{ name="clear")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ clear}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{$session}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Session}\OtherTok{();}
        \KeywordTok{$session}\NormalTok{->remove}\OtherTok{(}\StringTok{'basket'}\OtherTok{);}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'basket_index'}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Plus, as usualy, we must add a \texttt{use} statement to declare the
namespace in which the \texttt{Session} class we are using belongs to:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Session\textbackslash{}Session}\OtherTok{;}
\end{Highlighting}
\end{Shaded}

Let's see how each route is prefixed with \texttt{/basket} and each
route name is prefixed with \texttt{basket\_} by listing routes at the
CLI:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console debug:router}

     \ExtensionTok{--------------------------}\NormalTok{ ---------- -------- ------ -----------------------------------}
      \ExtensionTok{Name}\NormalTok{                       Method     Scheme   Host   Path}
     \ExtensionTok{--------------------------}\NormalTok{ ---------- -------- ------ -----------------------------------}
      \ExtensionTok{basket_index}\NormalTok{               ANY        ANY      ANY    /basket/}
      \ExtensionTok{basket_clear}\NormalTok{               ANY        ANY      ANY    /basket/clear}
      \ExtensionTok{default}\NormalTok{                    ANY        ANY      ANY    /}
      \ExtensionTok{product_index}\NormalTok{              ANY        ANY      ANY    /product/}
      \ExtensionTok{product_new}\NormalTok{                GET}\KeywordTok{|}\ExtensionTok{POST}\NormalTok{   ANY      ANY    /product/new}
      \ExtensionTok{product_show}\NormalTok{               GET        ANY      ANY    /product/}\DataTypeTok{\{id\}}
      \ExtensionTok{product_edit}\NormalTok{               GET}\KeywordTok{|}\ExtensionTok{POST}\NormalTok{   ANY      ANY    /product/}\DataTypeTok{\{id\}}\NormalTok{/edit}
      \ExtensionTok{product_delete}\NormalTok{             DELETE     ANY      ANY    /product/}\DataTypeTok{\{id\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{debugging-sessions-in-twig}{%
\section{Debugging sessions in Twig}\label{debugging-sessions-in-twig}}

As well as the Symfony profiler, there is also the powerful Twig
function \texttt{dump()}. This can be used to interrogate values in the
session.

Add the Symfony Twig dumper to your project using Composer:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ req --dev var-dumper}
\end{Highlighting}
\end{Shaded}

You can either dump \textbf{every} variable that Twig can see, with
\texttt{dump()}. This will list arguments passed to Twig by the
controller, plus the \texttt{app} variable, containing session data and
other applicatiton object properties.

Or you can be more specific, and dump just a particular object or
variable. For example we'll be building an attribute stack session array
named \texttt{basket}, and the contents of this array can be dumped in
Twig with the following statement:

\begin{verbatim}
    {{ dump(app.session.get('basket')) }}
\end{verbatim}

You might put this at the bottom of the HTML

element in your \texttt{base.html.twig} main template while debugging
this shopping basket application:

\begin{verbatim}
    <!DOCTYPE html>
    <html>
        <head>
            <meta charset="UTF-8">
            <title>{% block title %}Welcome!{% endblock %}</title>
            {% block stylesheets %}{% endblock %}
        </head>
        <body>
            {% block body %}{% endblock %}
    
            <hr>
            contents of session 'basket'
    
            {{ dump(app.session.get('basket')) }}
            
        </body>
    </html>
\end{verbatim}

Figure \ref{basket_dump} shows an example of what we'd see on the home
page from this Twig \texttt{dump()} statement if there is one item
(Product 1) in the session basket:

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/84418b741d2d437a7bbca9010525e518fbcdd4de.png}
\caption{Screenshot of home page dumping session \texttt{basket}
variable contents. \label{twig_blackwhite}}
\end{figure}

\hypertarget{adding-a-object-to-the-basket}{%
\section{Adding a object to the
basket}\label{adding-a-object-to-the-basket}}

The logic to add an object into our session \texttt{basket} array
requires a little work.

We'll make things easy for ourselves - using the Symfony
Param-Converter. So a product \texttt{id} is in the URL
\texttt{/add/\textless{}id\textgreater{}}, but for our method
declaration we say we are expecting a reference to a \texttt{Product}
record \texttt{\$product}. Symfony will go off and retrieve the row from
the database corresonding to the \texttt{id}, and return us a reference
to a \texttt{Product} object containing the properties from the
database.

Since we'll be working with \texttt{Product} objects, we need to add a
\texttt{use} statement at the top of our \texttt{BasketController}
class:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Entity\textbackslash{}Product}\OtherTok{;}
\end{Highlighting}
\end{Shaded}

We need to get a PHP array \texttt{\$products}, that is either what is
currently in the session, or a new empty array if no such array was
found in the session:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/add/\{id\}",}\CommentTok{ name="add")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ addToBasket}\OtherTok{(}\NormalTok{Product }\KeywordTok{$product}\OtherTok{)}
\NormalTok{    \{}
        \CommentTok{// default - new empty array}
        \KeywordTok{$products}\NormalTok{ = }\OtherTok{[];}

        \CommentTok{// if 'products' array in session, retrieve and store in $products}
        \KeywordTok{$session}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Session}\OtherTok{();}
        \KeywordTok{if} \OtherTok{(}\KeywordTok{$session}\NormalTok{->has}\OtherTok{(}\StringTok{'basket'}\OtherTok{))}\NormalTok{ \{}
            \KeywordTok{$products}\NormalTok{ = }\KeywordTok{$session}\NormalTok{->get}\OtherTok{(}\StringTok{'basket'}\OtherTok{);}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}

Note above, that we are relying on the `magic' of the Symfony
param-converter here, so that the integer `id' received in the request
is converted into its corresponding Elective object for us.

Next we get the `id' of the Product object, and see whether it can be
found already in array \texttt{propducts}. If if is not already in the
array, then we add it to the array (with the `id' as key), and store the
updated array in the session under the attribute bag key
\texttt{basket}:

\begin{Shaded}
\begin{Highlighting}[]
        \CommentTok{// get ID of product}
        \KeywordTok{$id}\NormalTok{ = }\KeywordTok{$product}\NormalTok{->getId}\OtherTok{();}

        \CommentTok{// only try to add to array if not already in the array}
        \KeywordTok{if} \OtherTok{(}\NormalTok{!}\FunctionTok{array_key_exists}\OtherTok{(}\KeywordTok{$id}\OtherTok{,} \KeywordTok{$products}\OtherTok{))}\NormalTok{ \{}
            \CommentTok{// append $product to our list}
            \KeywordTok{$products}\OtherTok{[}\KeywordTok{$id}\OtherTok{]}\NormalTok{ = }\KeywordTok{$product}\OtherTok{;}

            \CommentTok{// store updated array back into the session}
            \KeywordTok{$session}\NormalTok{->set}\OtherTok{(}\StringTok{'basket'}\OtherTok{,} \KeywordTok{$products}\OtherTok{);}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}

Finally (whether we changed the session \texttt{basket} or not), we
redirect to the basket index route:

\begin{Shaded}
\begin{Highlighting}[]
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'basket_index'}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-delete-action-method}{%
\section{The delete action method}\label{the-delete-action-method}}

The delete action method is very similar to the add action method. In
this case we never need the whole \texttt{Product} object, so we can
keep the integer \texttt{id} as the parameter for the method.

We start (as for add) by ensuring we have a PHP variable array
\texttt{\$products}, whether or not one was found in the session.

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/delete/\{id\}",}\CommentTok{ name="delete")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ deleteAction}\OtherTok{(}\KeywordTok{int} \KeywordTok{$id}\OtherTok{)}
\NormalTok{    \{}
        \CommentTok{// default - new empty array}
        \KeywordTok{$products}\NormalTok{ = }\OtherTok{[];}

        \CommentTok{// if 'products' array in session, retrieve and store in $products}
        \KeywordTok{$session}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Session}\OtherTok{();}
        \KeywordTok{if} \OtherTok{(}\KeywordTok{$session}\NormalTok{->has}\OtherTok{(}\StringTok{'basket'}\OtherTok{))}\NormalTok{ \{}
            \KeywordTok{$products}\NormalTok{ = }\KeywordTok{$session}\NormalTok{->get}\OtherTok{(}\StringTok{'basket'}\OtherTok{);}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}

Next we see whether an item in this array can be found with the key
\texttt{\$id}. If it can, we remove it with \texttt{unset} and store the
updated array in the session attribute bag with key \texttt{basket}.

\begin{Shaded}
\begin{Highlighting}[]
        \CommentTok{// only try to remove if it's in the array}
        \KeywordTok{if} \OtherTok{(}\FunctionTok{array_key_exists}\OtherTok{(}\KeywordTok{$id}\OtherTok{,} \KeywordTok{$products}\OtherTok{))}\NormalTok{ \{}
            \CommentTok{// remove entry with $id}
            \KeywordTok{unset}\OtherTok{(}\KeywordTok{$products}\OtherTok{[}\KeywordTok{$id}\OtherTok{]);}

            \KeywordTok{if} \OtherTok{(}\FunctionTok{sizeof}\OtherTok{(}\KeywordTok{$products}\OtherTok{)}\NormalTok{ < }\DecValTok{1}\OtherTok{)}\NormalTok{ \{}
                \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'basket_clear'}\OtherTok{);}
\NormalTok{            \}}

            \CommentTok{// store updated array back into the session}
            \KeywordTok{$session}\NormalTok{->set}\OtherTok{(}\StringTok{'basket'}\OtherTok{,} \KeywordTok{$products}\OtherTok{);}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}

Note - if there are no items left in the baset, we redirect to the clear
action to remove the basket attribute completely from the session.

Finally (whether we changed the session \texttt{basket} or not), we
redirect to the basket index route:

\begin{Shaded}
\begin{Highlighting}[]
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'basket_index'}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-twig-template-for-the-basket-index-action}{%
\section{The Twig template for the basket index
action}\label{the-twig-template-for-the-basket-index-action}}

The work extracting the array of products in the basket and displaying
them is the task of template \texttt{index.html.twig} in
\texttt{/templates/basket/}.

First, after nice big \texttt{\textless{}h1\textgreater{}} heading, we
attempt to retrieve item \texttt{basket} from the session:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{<h1>}\NormalTok{Basket contents}\KeywordTok{</h1>}

\NormalTok{    \{% set basket = app.session.get('basket') %\}}
\end{Highlighting}
\end{Shaded}

Next we have a Twig \texttt{if} statement, displaying an empty basket
message if \texttt{basket} is null, i.e.:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    \{% if basket is null %\}}
        \KeywordTok{<p>}
\NormalTok{            you have no products in your basket}
        \KeywordTok{</p>}
\end{Highlighting}
\end{Shaded}

The we have an \texttt{else} statement (for when we did retrieve an
array), that loops through creating an unordered HTML list of the basket
items:

\begin{verbatim}
    {% else %}
        <ul>
            {% for product in basket %}
                <li>
                    <hr>
                    {{ product.id }} :: {{ product.description }}
                    <a href="{{ path('basket_delete', { 'id': product.id }) }}">(remove)</a>
                </li>
            {% endfor %}
        </ul>
    {% endif %}
\end{verbatim}

Note that a link to the \texttt{delete} action is offered at the end of
each list item as text \texttt{(remove}).

Finally, a paragraph is offered, containing a list to clear all items
from the basket:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{<p>}
        \KeywordTok{<a}\OtherTok{ href=}\StringTok{"\{\{ path('basket_clear') \}\}"}\KeywordTok{>}\NormalTok{CLEAR all items in basket}\KeywordTok{</a>}
    \KeywordTok{</p>}
\end{Highlighting}
\end{Shaded}

Figure \ref{electives_basket} shows a screenshot of the basket index
page - listing the basket contents.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/54acc690157f03f68d7c8277dc141f8b570861fa.png}
\caption{Shopping basket of elective modules. \label{electives_basket}}
\end{figure}

\hypertarget{adding-useful-links-to-our-base.html.twig-template}{%
\section{\texorpdfstring{Adding useful links to our
\texttt{base.html.twig}
template}{Adding useful links to our base.html.twig template}}\label{adding-useful-links-to-our-base.html.twig-template}}

Let's add those useful navigation links to the top of every page. Add
the following just before the \texttt{body} block is defined in template
\texttt{base.html.twig}:

\begin{verbatim}
    <nav>
        <ul>
            <li><a href="{{  url('default') }}">home</a></li>
            <li><a href="{{  url('product_index') }}">list of products</a></li>
            <li><a href="{{  url('basket_index') }}">basket</a></li>
        </ul>
    </nav>
\end{verbatim}

Every page on the website should now show these links.,

\hypertarget{adding-the-add-to-basket-link-in-the-list-of-products}{%
\section{Adding the `add to basket' link in the list of
products}\label{adding-the-add-to-basket-link-in-the-list-of-products}}

To link everything together, we can now add a link to `add to basket' in
our products CRUD index template. So when we see a list of products we
can add one to the basket, and then be redirected to see the updated
basket of products. We see below an extra list item for path
\texttt{basket\_add} in template \texttt{index.html.twig} in directory
\texttt{/templates/product/}.

We add this line:

\begin{verbatim}
   <a href="{{ path('basket_add', { 'id': product.id }) }}">add to basket</a>
\end{verbatim}

to the end of the table cell displaying each \texttt{Product}

\begin{verbatim}
    {% for product in products %}
        <tr>
            <td>{{ product.id }}</td>
            <td>{{ product.description }}</td>
            <td>{{ product.image }}</td>
            <td>{{ product.price }}</td>
            <td>
                <a href="{{ path('product_show', {'id': product.id}) }}">show</a>
                <a href="{{ path('product_edit', {'id': product.id}) }}">edit</a>
                <a href="{{ path('basket_add', { 'id': product.id }) }}">add to basket</a>
            </td>
        </tr>
    {% else %}
        <tr>
            <td colspan="5">no records found</td>
        </tr>
    {% endfor %}
\end{verbatim}

Figure \ref{add_to_basket} shows a screenshot of the list of products
page, each with an `add to basket' link.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/ca3e9c1fec1e44180d0d9921c1436d7d8338d566.png}
\caption{List of Products with `add to basket' link.
\label{add_to_basket}}
\end{figure}

\part{Security and Authentication}

\hypertarget{quickstart-symfony-security}{%
\chapter{Quickstart Symfony
security}\label{quickstart-symfony-security}}

\hypertarget{learn-about-symfony-security}{%
\section{Learn about Symfony
security}\label{learn-about-symfony-security}}

There are several key Symfony reference pages to read when starting with
security. These include:

\begin{itemize}
\item
  \href{https://symfony.com/doc/current/security.html}{Introduction to
  security}
\item
  \href{https://symfony.com/doc/current/security/form_login_setup.html}{How
  to build a traditional login form}
\item
  \href{https://symfony.com/doc/current/security/csrf.html}{Using CSRF
  protection}
\end{itemize}

\hypertarget{new-project-with-open-and-secured-routes-project-security01}{%
\section{\texorpdfstring{New project with open and secured routes
(project
\texttt{security01})}{New project with open and secured routes (project security01)}}\label{new-project-with-open-and-secured-routes-project-security01}}

We are going to quickly create a 2-page website, with an open home page
(url \texttt{/}) and a secured admin page (at url \texttt{/admin}).

\hypertarget{create-new-project-and-add-the-security-bundle-library}{%
\section{Create new project and add the security bundle
library}\label{create-new-project-and-add-the-security-bundle-library}}

Create a new project:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{symfony}\NormalTok{ new --full security01}
\end{Highlighting}
\end{Shaded}

Add the security bundle:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{composer}\NormalTok{ req symfony/security-bundle}
\end{Highlighting}
\end{Shaded}

Add the fixtures bundle (we'll need this later):

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{composer}\NormalTok{ require orm-fixtures --dev }
\end{Highlighting}
\end{Shaded}

\hypertarget{make-a-default-controller}{%
\section{Make a Default controller}\label{make-a-default-controller}}

Let's make a Default controller
\texttt{/src/Controller/DefaultController.php}:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{php}\NormalTok{ bin/console make:controller Default}
\end{Highlighting}
\end{Shaded}

Edit the route to be \texttt{/} and the internal name to be
\texttt{homepage}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/",}\CommentTok{ name="homepage")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ indexAction}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{$template}\NormalTok{ = }\StringTok{'default/index.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[];}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Change the template \texttt{/templates/default/index.html.twig} to be
something like:

\begin{verbatim}
    {% extends 'base.html.twig' %}

    {% block body %}
        welcome to the home page
    {% endblock %}
\end{verbatim}

This will be accessible to everyone.

\hypertarget{make-a-secured-admin-controller}{%
\section{Make a secured Admin
controller}\label{make-a-secured-admin-controller}}

Let's make a Admin controller:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:controller Admin}
\end{Highlighting}
\end{Shaded}

This will be accessible to only to users logged in with
\texttt{ROLE\_ADMIN} security.

Edit the new \texttt{AdminController} in
\texttt{/src/Controller/AdminController.php}. Add a \texttt{use}
statement, to let us use the \texttt{@IsGranted} annotation:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{use}\NormalTok{ Sensio\textbackslash{}Bundle\textbackslash{}FrameworkExtraBundle\textbackslash{}Configuration\textbackslash{}IsGranted}\OtherTok{;}
\end{Highlighting}
\end{Shaded}

Now we'll restrict access to the index action of our Admin controller
using the \texttt{@IsGranted} annotation. Symfony security expects
logged-in users to have one or more `roles', these are simple text
Strings in the form \texttt{ROLE\_xxxx}. The default is to have all
logged-in users having \texttt{ROLE\_USER}, and they can have additional
roles as well. So let's restrict our admin home page to only logged-in
users that have the authentication \texttt{ROLE\_ADMIN}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/admin",}\CommentTok{ name="admin")}
\CommentTok{     * }\AnnotationTok{@IsGranted("ROLE_ADMIN")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{$template}\NormalTok{ = }\StringTok{'admin/index.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[];}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

NOTE: We can \textbf{make up} whatever roles are appropriate for our
application, e.g.:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{ROLE_ADMIN}
    \KeywordTok{ROLE_STUDENT}
    \KeywordTok{ROLE_PRESIDENT}
    \KeywordTok{ROLE_TECHNICIAN}
    \StringTok{...}\NormalTok{ etc. }
\end{Highlighting}
\end{Shaded}

Change the template \texttt{/templates/admin/index.html.twig} to be
something like the following - a secret code we can only see if logged
in:

\begin{verbatim}
    {% extends 'base.html.twig' %}

    {% block body %}
        <h1>Admin home</h1>

        here is the secret code to the safe:
        007123
    {% endblock %}
\end{verbatim}

That's it!

Run the web sever:

\begin{itemize}
\item
  visiting the Default page at \texttt{/} is fine, even though we have
  not logged in ag all
\item
  however, visiting the the \texttt{/admin} page should result in an
  HTTP 401 error (Unauthorized) due to insufficient authentication. See
  Figure \ref{not_authorised}.
\end{itemize}

\begin{figure}
\centering
\includegraphics[width=0.75\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/1f857b19819be887adb09dafdce063deff3936e3.png}
\caption{Screenshot of error attempting to visit \texttt{/admin}.
\label{not_authorised}}
\end{figure}

Of course, we now need to add a way to login and define different user
credentials etc\ldots{}

\hypertarget{core-features-about-symfony-security}{%
\section{Core features about Symfony
security}\label{core-features-about-symfony-security}}

There are several related features and files that need to be understood
when using the Symnfony security system. These include:

\begin{itemize}
\tightlist
\item
  \textbf{firewalls}
\item
  \textbf{providers} and \textbf{encoders}
\item
  \textbf{route protection} (we met this with \texttt{@IsGranded}
  controller method annotation comment above\ldots{})
\item
  user \textbf{roles} (we met this as part of \texttt{@IsGranded} above
  \texttt{("ROLE\_ADMIN")} \ldots{})
\end{itemize}

Core to Symfony security are the \textbf{firewalls} defined in
\texttt{/config/packages/security.yml}. Symfony firewalls declare how
route patterns are protected (or not) by the security system. Here is
its default contents (less comments - lines starting with hash
\texttt{\#} character):

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{security:}
        \FunctionTok{providers:}
            \FunctionTok{users_in_memory:}\AttributeTok{ }\KeywordTok{\{} \FunctionTok{memory:}\AttributeTok{ }\CharTok{null}\AttributeTok{ }\KeywordTok{\}}

        \FunctionTok{firewalls:}
            \FunctionTok{dev:}
                \FunctionTok{pattern:}\AttributeTok{ ^/(_(profiler|wdt)|css|images|js)/}
                \FunctionTok{security:}\AttributeTok{ }\CharTok{false}
            \FunctionTok{main:}
                \FunctionTok{anonymous:}\AttributeTok{ lazy}
                \FunctionTok{provider:}\AttributeTok{ users_in_memory}
    
        \FunctionTok{access_control:}
\end{Highlighting}
\end{Shaded}

Symfony considers \textbf{every} request to have been authenticated, so
if no login action has taken place then the request is considered to
have been authenticated to be \textbf{anonymous} user \texttt{anon}. We
can see in this \texttt{anon} user in Figure \ref{anon_user} this
looking at the user information from the Symfony debug bar when visiting
the default home page.

\begin{figure}
\centering
\includegraphics[width=0.5\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/6888b9386404a3f170783e9672b48cf40ecc274c.png}
\caption{Symfony profiler showing anonymous user authentication.
\label{anon_user}}
\end{figure}

A Symfony \textbf{provider} is where the security system can access a
set of defined users of the web application. The default for a new
project is simply \texttt{in\_memory} - although non-trivial
applications have users in a database or from a separate API. We see
that the \texttt{main} firewall simply states that users are permitted
(at present) any request route pattern, and anonymous authenticated
users (i.e.~ones who have not logged in) are permitted.

The \texttt{dev} firewall allows Symfony development tools (like the
profiler) to work without any authentication required. Leave it in
\texttt{security.yml} and just ignore the \texttt{dev} firewall from
this point onwards.

\hypertarget{generating-the-special-user-entity-class-project-security02}{%
\section{\texorpdfstring{Generating the special \texttt{User} Entity
class (project
\texttt{security02})}{Generating the special User Entity class (project security02)}}\label{generating-the-special-user-entity-class-project-security02}}

Let's use the special \texttt{make:user} console command to create a
\texttt{User} entity class that meets the requirements of providing user
objects for the Symfony security system.

Enter the following at the command line, then just keep pressing
\texttt{\textless{}RETURN\textgreater{}} to accept all the defaults:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:user}

     \ExtensionTok{The}\NormalTok{ name of the security user class (e.g. User) [}\ExtensionTok{User}\NormalTok{]:}
     \OperatorTok{>}          \ExtensionTok{//}\NormalTok{ press }\OperatorTok{<}\NormalTok{RETURN}\OperatorTok{>}\NormalTok{ to accept default}
    
     \ExtensionTok{Do}\NormalTok{ you want to store user data in the database (via Doctrine)}\ExtensionTok{?}\NormalTok{ (yes/no) [}\ExtensionTok{yes}\NormalTok{]:}
     \OperatorTok{>}          \ExtensionTok{//}\NormalTok{ press }\OperatorTok{<}\NormalTok{RETURN}\OperatorTok{>}\NormalTok{ to accept default}
    
     \ExtensionTok{Enter}\NormalTok{ a property name that will be the unique }\StringTok{"display"}\NormalTok{ name for the user (e.g. email, username, uuid) [}\ExtensionTok{email}\NormalTok{]:}
     \OperatorTok{>}          \ExtensionTok{//}\NormalTok{ press }\OperatorTok{<}\NormalTok{RETURN}\OperatorTok{>}\NormalTok{ to accept default}
    
     \ExtensionTok{Will}\NormalTok{ this app need to hash/check user passwords? Choose No if passwords are not needed or will be checked/hashed by some other system (e.g. a single sign-on server)}\ExtensionTok{.}
    
     \ExtensionTok{Does}\NormalTok{ this app need to hash/check user passwords? (yes/no) [}\ExtensionTok{yes}\NormalTok{]:}
     \OperatorTok{>}          \ExtensionTok{//}\NormalTok{ press }\OperatorTok{<}\NormalTok{RETURN}\OperatorTok{>}\NormalTok{ to accept default}
    
     \ExtensionTok{created}\NormalTok{: src/Entity/User.php}
     \ExtensionTok{created}\NormalTok{: src/Repository/UserRepository.php}
     \ExtensionTok{updated}\NormalTok{: src/Entity/User.php}
     \ExtensionTok{updated}\NormalTok{: config/packages/security.yaml}
      \ExtensionTok{Success}\NormalTok{! }
\end{Highlighting}
\end{Shaded}

\hypertarget{review-the-changes-to-the-configpackagessecurity.yml-file}{%
\section{\texorpdfstring{Review the changes to the
\texttt{/config/packages/security.yml}
file}{Review the changes to the /config/packages/security.yml file}}\label{review-the-changes-to-the-configpackagessecurity.yml-file}}

If we look at \texttt{security.yml} it now begins as follows, taking
into account our new \texttt{User} class:

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{security:}
        \FunctionTok{encoders:}
            \FunctionTok{App\textbackslash{}Entity\textbackslash{}User:}
                \FunctionTok{algorithm:}\AttributeTok{ auto}
    
        \CommentTok{# https://symfony.com/doc/current/security.html#where-do-users-come-from-user-providers}
        \FunctionTok{providers:}
            \CommentTok{# used to reload user from session & other features (e.g. switch_user)}
            \FunctionTok{app_user_provider:}
                \FunctionTok{entity:}
                    \FunctionTok{class:}\AttributeTok{ App\textbackslash{}Entity\textbackslash{}User}
                    \FunctionTok{property:}\AttributeTok{ email}
\end{Highlighting}
\end{Shaded}

\hypertarget{migrate-new-user-class-to-your-database}{%
\section{\texorpdfstring{Migrate new \texttt{User} class to your
database}{Migrate new User class to your database}}\label{migrate-new-user-class-to-your-database}}

Since we've changed our Entity classes, we should migrate these changes
to the database (and, of course, first create your database if you havce
not already done so):

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{php}\NormalTok{ bin/console make:migration}
    \ExtensionTok{php}\NormalTok{ bin/console doctrine:migrations:migrate}
\end{Highlighting}
\end{Shaded}

\hypertarget{make-some-user-fixtures}{%
\section{\texorpdfstring{Make some \texttt{User}
fixtures}{Make some User fixtures}}\label{make-some-user-fixtures}}

Let's make some users with the \texttt{make:fixture} command:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{php}\NormalTok{ bin/console make:fixture UserFixtures}
\end{Highlighting}
\end{Shaded}

We'll use the Symfony sample code so that the plain-text passwords can
be encoded (hashed) when stored in the database, see:

\begin{itemize}
\tightlist
\item
  \url{https://symfony.com/doc/current/security.html\#c-encoding-passwords}
\end{itemize}

Edit your class \texttt{UserFixtures} to make use of the
\texttt{PasswordEncoder}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php    }
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}DataFixtures}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}Bundle\textbackslash{}FixturesBundle\textbackslash{}Fixture}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}Common\textbackslash{}Persistence\textbackslash{}ObjectManager}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Security\textbackslash{}Core\textbackslash{}Encoder\textbackslash{}UserPasswordEncoderInterface}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Entity\textbackslash{}User}\OtherTok{;}
    
    \KeywordTok{class}\NormalTok{ UserFixtures }\KeywordTok{extends}\NormalTok{ Fixture}
\NormalTok{    \{}
         \KeywordTok{private} \KeywordTok{$passwordEncoder}\OtherTok{;}
    
         \KeywordTok{public} \KeywordTok{function} \FunctionTok{__construct}\OtherTok{(}\NormalTok{UserPasswordEncoderInterface }\KeywordTok{$passwordEncoder}\OtherTok{)}
\NormalTok{         \{}
             \KeywordTok{$this}\NormalTok{->passwordEncoder = }\KeywordTok{$passwordEncoder}\OtherTok{;}
\NormalTok{         \}}
    
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ load}\OtherTok{(}\NormalTok{ObjectManager }\KeywordTok{$manager}\OtherTok{)}
\NormalTok{        \{}
            \CommentTok{// (1) create object}
            \KeywordTok{$user}\NormalTok{ = }\KeywordTok{new}\NormalTok{ User}\OtherTok{();}
            \KeywordTok{$user}\NormalTok{->setEmail}\OtherTok{(}\StringTok{'matt.smith@smith.com'}\OtherTok{);}
            \KeywordTok{$user}\NormalTok{->setRoles}\OtherTok{([}\StringTok{'ROLE_ADMIN'}\OtherTok{,} \StringTok{'ROLE_TEACHER'}\OtherTok{]);}
    
            \KeywordTok{$plainPassword}\NormalTok{ = }\StringTok{'smith'}\OtherTok{;}
            \KeywordTok{$encodedPassword}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->passwordEncoder->encodePassword}\OtherTok{(}\KeywordTok{$user}\OtherTok{,} \KeywordTok{$plainPassword}\OtherTok{);}
    
            \KeywordTok{$user}\NormalTok{->setPassword}\OtherTok{(}\KeywordTok{$encodedPassword}\OtherTok{);}
    
            \CommentTok{//(2) queue up object to be inserted into DB}
            \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$user}\OtherTok{);}
    
            \CommentTok{// (3) insert objects into database}
            \KeywordTok{$manager}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

From the template class geneated for us, the first thing we need to do
is add 2 \texttt{use} statements, to allow us to make use of the
\texttt{User} entity class, and the
\texttt{UserPasswordEncoderInterface} class:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Security\textbackslash{}Core\textbackslash{}Encoder\textbackslash{}UserPasswordEncoderInterface}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Entity\textbackslash{}User}\OtherTok{;}        
\end{Highlighting}
\end{Shaded}

Next, to make it easy to encode passwords we'll add a new private
instance variable \texttt{\$passwordEncoder}, and a constructor method
to initialise this object:

\begin{Shaded}
\begin{Highlighting}[]
     \KeywordTok{private} \KeywordTok{$passwordEncoder}\OtherTok{;}

     \KeywordTok{public} \KeywordTok{function} \FunctionTok{__construct}\OtherTok{(}\NormalTok{UserPasswordEncoderInterface }\KeywordTok{$passwordEncoder}\OtherTok{)}
\NormalTok{     \{}
         \KeywordTok{$this}\NormalTok{->passwordEncoder = }\KeywordTok{$passwordEncoder}\OtherTok{;}
\NormalTok{     \}}
\end{Highlighting}
\end{Shaded}

Finally, we can write the code to create a new \texttt{User} object, set
its \texttt{email} and \texttt{roles} properties, encode a plain text
password and set the encoded value to the object. This \texttt{\$user}
object needs to then be added to the queue of objects for the database
(\texttt{persist(...)}), and then finally inserted into the database
(\texttt{flush()}):

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ load}\OtherTok{(}\NormalTok{ObjectManager }\KeywordTok{$manager}\OtherTok{)}
\NormalTok{    \{}
        \CommentTok{// (1) create object}
        \KeywordTok{$user}\NormalTok{ = }\KeywordTok{new}\NormalTok{ User}\OtherTok{();}
        \KeywordTok{$user}\NormalTok{->setEmail}\OtherTok{(}\StringTok{'matt.smith@smith.com'}\OtherTok{);}
        \KeywordTok{$user}\NormalTok{->setRoles}\OtherTok{([}\StringTok{'ROLE_ADMIN'}\OtherTok{,} \StringTok{'ROLE_TEACHER'}\OtherTok{]);}

        \KeywordTok{$plainPassword}\NormalTok{ = }\StringTok{'smith'}\OtherTok{;}
        \KeywordTok{$encodedPassword}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->passwordEncoder->encodePassword}\OtherTok{(}\KeywordTok{$user}\OtherTok{,} \KeywordTok{$plainPassword}\OtherTok{);}

        \KeywordTok{$user}\NormalTok{->setPassword}\OtherTok{(}\KeywordTok{$encodedPassword}\OtherTok{);}

        \CommentTok{//(2) queue up object to be inserted into DB}
        \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$user}\OtherTok{);}

        \CommentTok{// (3) insert objects into database}
        \KeywordTok{$manager}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

NOTE: The \texttt{roles} property expects to be given an array of String
roles, in the form
\texttt{{[}\textquotesingle{}ROLE\_ADMIN\textquotesingle{},\ \textquotesingle{}ROLE\_SOMETHINGELSE\textquotesingle{},\ ...{]}}.
These roles can be whatever we want for user:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$user}\NormalTok{->setRoles}\OtherTok{([}\StringTok{'ROLE_ADMIN'}\OtherTok{,} \StringTok{'ROLE_TEACHER'}\OtherTok{]);}
\end{Highlighting}
\end{Shaded}

\hypertarget{run-and-check-your-fixtures}{%
\section{Run and check your
fixtures}\label{run-and-check-your-fixtures}}

Load the fixtures into the database (with
\texttt{doctrine:fixtures:load}), and check them with a simple SQL query
\texttt{select\ *\ from\ user}:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{php}\NormalTok{ bin/console doctrine:query:sql }\StringTok{"select * from user"}
    \ExtensionTok{Cannot}\NormalTok{ load Xdebug - it was already loaded}
    
    \ExtensionTok{/php-symfony-5-book-codes-security-02-user/vendor/doctrine/dbal/lib/Doctrine/DBAL/Tools}\NormalTok{/Dumper.php:}\ExtensionTok{71}\NormalTok{:}
    \ExtensionTok{array}\NormalTok{ (size=1)}
      \ExtensionTok{0}\NormalTok{ =}\OperatorTok{>} 
        \ExtensionTok{array}\NormalTok{ (size=4)}
          \StringTok{'id'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'1'}\NormalTok{ (length=1)}
          \StringTok{'email'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'matt.smith@smith.com'}\NormalTok{ (length=20)}
          \StringTok{'roles'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'["ROLE_USER", "ROLE_ADMIN"]'}\NormalTok{ (length=27)}
          \StringTok{'password'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'$2y$13$BInaG05FUpAHqcEBtGG05.G.qDbT5SNHoCI1nBHb58FILxJxFUmPu'}\NormalTok{ (length=60)}
\end{Highlighting}
\end{Shaded}

We can see the encoded password and roles \texttt{ROLE\_USER} and
\texttt{ROLE\_ADMIN}

\hypertarget{creating-a-login-form}{%
\section{Creating a Login form}\label{creating-a-login-form}}

One new additional to the maker tool in Symfony 5 is automatic
generation of a login form. Enter the following at the commadn line:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{php}\NormalTok{ bin/console make:auth}
\end{Highlighting}
\end{Shaded}

When prompted choose option \texttt{1}, a Login Form Authenticator:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{What}\NormalTok{ style of authentication do you want? [Empty authenticator]:}
\NormalTok{    [}\ExtensionTok{0}\NormalTok{] Empty authenticator}
\NormalTok{    [}\ExtensionTok{1}\NormalTok{] Login form authenticator}
    \OperatorTok{>} \ExtensionTok{1}
\end{Highlighting}
\end{Shaded}

Next, give the name \texttt{LoginFormAuthenticator} for this new
authenticator:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{The}\NormalTok{ class name of the authenticator to create (e.g. AppCustomAuthenticator)}\BuiltInTok{:}
    \OperatorTok{>} \ExtensionTok{LoginFormAuthenticator}
\end{Highlighting}
\end{Shaded}

Accept the default (press \texttt{\textless{}RETURN\textgreater{}}) for
the name of your controller class (\texttt{SecurityController}):

\begin{Shaded}
\begin{Highlighting}[]
     \ExtensionTok{Choose}\NormalTok{ a name for the controller class (e.g. SecurityController) [}\ExtensionTok{SecurityController}\NormalTok{]:}
     \OperatorTok{>} 
\end{Highlighting}
\end{Shaded}

Accept the default (press \texttt{\textless{}RETURN\textgreater{}}) for
creating a \textbf{logout} route (\texttt{yes}):

\begin{Shaded}
\begin{Highlighting}[]
     \ExtensionTok{Do}\NormalTok{ you want to generate a }\StringTok{'/logout'}\NormalTok{ URL? (yes/no) [}\ExtensionTok{yes}\NormalTok{]:}
     \OperatorTok{>} 
\end{Highlighting}
\end{Shaded}

You should now have a new controller \texttt{SecurityController}, a
login form \texttt{templates/security/login.html.twig}, an authenticator
class \texttt{LoginFormAuthenticator}, and an updated set of security
settings \texttt{config/packages/security.yaml}:

\begin{Shaded}
\begin{Highlighting}[]
     \ExtensionTok{created}\NormalTok{: src/Security/LoginFormAuthenticator.php}
     \ExtensionTok{updated}\NormalTok{: config/packages/security.yaml}
     \ExtensionTok{created}\NormalTok{: src/Controller/SecurityController.php}
     \ExtensionTok{created}\NormalTok{: templates/security/login.html.twig}

      \ExtensionTok{Success}\NormalTok{! }
\end{Highlighting}
\end{Shaded}

\hypertarget{check-the-new-routes}{%
\section{Check the new routes}\label{check-the-new-routes}}

We can check we have new login/logout routes from with the
\texttt{debug:router} command:

\begin{Shaded}
\begin{Highlighting}[]
     \ExtensionTok{php}\NormalTok{ bin/console debug:router}
    \ExtensionTok{Cannot}\NormalTok{ load Xdebug - it was already loaded}
     \ExtensionTok{--------------------------}\NormalTok{ -------- -------- ------ ----------------------------------- }
      \ExtensionTok{Name}\NormalTok{                       Method   Scheme   Host   Path                               }
     \ExtensionTok{--------------------------}\NormalTok{ -------- -------- ------ ----------------------------------- }
      \ExtensionTok{_preview_error}\NormalTok{             ANY      ANY      ANY    /_error/}\DataTypeTok{\{code\}}\NormalTok{.}\DataTypeTok{\{_format\}}           
        \ExtensionTok{....}\NormalTok{ other _profiler debug routes here ...}
      \ExtensionTok{admin}\NormalTok{                      ANY      ANY      ANY    /admin                             }
      \ExtensionTok{homepage}\NormalTok{                   ANY      ANY      ANY    /                                  }
      \ExtensionTok{app_login}\NormalTok{                  ANY      ANY      ANY    /login                             }
      \ExtensionTok{app_logout}\NormalTok{                 ANY      ANY      ANY    /logout          }
\end{Highlighting}
\end{Shaded}

\hypertarget{allow-any-user-to-view-the-login-form}{%
\section{\texorpdfstring{Allow \textbf{any} user to view the login
form}{Allow any user to view the login form}}\label{allow-any-user-to-view-the-login-form}}

Finally, we now have to edit our security firewall to allow \textbf{all}
users, especially those not yet logged-in!, to access the
\texttt{/login} route. Add the following line to the end of your
\texttt{/config/packages/security.yml} configuration file:

\begin{Shaded}
\begin{Highlighting}[]
          \KeywordTok{-} \KeywordTok{\{} \FunctionTok{path:}\AttributeTok{ ^/login$}\KeywordTok{,} \FunctionTok{roles:}\AttributeTok{ IS_AUTHENTICATED_ANONYMOUSLY }\KeywordTok{\}}
\end{Highlighting}
\end{Shaded}

So the full \texttt{security.yml} file should look as follows (with
comments removed):

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{security:}
        \FunctionTok{encoders:}
            \FunctionTok{App\textbackslash{}Entity\textbackslash{}User:}
                \FunctionTok{algorithm:}\AttributeTok{ auto}
    
        \FunctionTok{providers:}
            \FunctionTok{app_user_provider:}
                \FunctionTok{entity:}
                    \FunctionTok{class:}\AttributeTok{ App\textbackslash{}Entity\textbackslash{}User}
                    \FunctionTok{property:}\AttributeTok{ email}
    
        \FunctionTok{firewalls:}
            \FunctionTok{dev:}
                \FunctionTok{pattern:}\AttributeTok{ ^/(_(profiler|wdt)|css|images|js)/}
                \FunctionTok{security:}\AttributeTok{ }\CharTok{false}
            \FunctionTok{main:}
                \FunctionTok{anonymous:}\AttributeTok{ lazy}
                \FunctionTok{provider:}\AttributeTok{ app_user_provider}
                \FunctionTok{guard:}
                    \FunctionTok{authenticators:}
                        \KeywordTok{-}\NormalTok{ App\textbackslash{}Security\textbackslash{}LoginFormAuthenticator}
                \FunctionTok{logout:}
                    \FunctionTok{path:}\AttributeTok{ app_logout}

        \FunctionTok{access_control:}
          \KeywordTok{-} \KeywordTok{\{} \FunctionTok{path:}\AttributeTok{ ^/login$}\KeywordTok{,} \FunctionTok{roles:}\AttributeTok{ IS_AUTHENTICATED_ANONYMOUSLY }\KeywordTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{clear-cache-visit-admin}{%
\section{\texorpdfstring{Clear cache \& visit
\texttt{/admin}}{Clear cache \& visit /admin}}\label{clear-cache-visit-admin}}

Clear the cache (e.g.~delete \texttt{/var/cache}), and open your browser
to \texttt{/admin}. Since you are not currently logged-in, you should
now be presented with a login form.

After we login with \texttt{matt.smith@smith.com} password =
\texttt{smith}, we should now be able to see in the Symfony Profiler
footer that we are logged in, and if we click this profiler footer, and
then the \texttt{Security} link, we see this user has roles
\texttt{ROLE\_USER} and \texttt{ROLE\_ADMIN}.

See Figure \ref{anon_user} this looking at the user information from the
Symfony debug bar when visiting the default home page.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/63b5ae9f82867fc51df48c24966ee9fcfd7c738c.png}
\caption{Symfony profiler showing ROLE\_USER and ROLE\_ADMIN
authenticationm. \label{security01}}
\end{figure}

\hypertarget{using-the-logout-route}{%
\section{\texorpdfstring{Using the \texttt{/logout}
route}{Using the /logout route}}\label{using-the-logout-route}}

A logout route \texttt{/logout} was automatically added when we used the
\texttt{make:auth} tool. So we can now use this route to logout the
current user in several ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  We can enter the route directly in the browser address bar, e.g.~via
  URL:

\begin{verbatim}
    http://localhost:8000/logout
\end{verbatim}
\item
  We can also logout via the Symfony profile toolbar. See Figure
  \ref{logout_link}.
\end{enumerate}

\begin{figure}
\centering
\includegraphics[width=0.75\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/e0059108995273ffa1150aad93ab2af90f546186.png}
\caption{Symfony profiler user logout action. \label{logout_link}}
\end{figure}

In either case we'll logout any currently logged-in user, and return the
anonymously authenticated user \texttt{anon} with no defined
authentication roles.

\hypertarget{finding-and-using-the-internal-loginlogout-route-names-in-securitycontroller}{%
\section{\texorpdfstring{Finding and using the internal login/logout
route names in
\texttt{SecurityController}}{Finding and using the internal login/logout route names in SecurityController}}\label{finding-and-using-the-internal-loginlogout-route-names-in-securitycontroller}}

Look inside the generated
\texttt{/src/controller/SecurityController.php} file to see the
annotation route comments for our login/lgout routes:

\begin{Shaded}
\begin{Highlighting}[]
    \StringTok{...}

    \KeywordTok{class}\NormalTok{ SecurityController }\KeywordTok{extends}\NormalTok{ AbstractController}
\NormalTok{    \{}
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/login",}\CommentTok{ name="app_login")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ login}\OtherTok{(}\NormalTok{AuthenticationUtils }\KeywordTok{$authenticationUtils}\OtherTok{)}\NormalTok{: Response}
\NormalTok{        \{}
            \StringTok{...}
\NormalTok{        \}}
    
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/logout",}\CommentTok{ name="app_logout")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ logout}\OtherTok{()}
\NormalTok{        \{}
            \StringTok{...}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}

We can add links for the user to login/logout on any page in a Twig
template, by using the Twig \texttt{url(...)} function and passing it
the internal route name for our logout route \texttt{app\_logout}, e.g.

\begin{verbatim}
    <a href="{{ url('app_logout') }}">
        logout
    </a>
\end{verbatim}

\hypertarget{security-users-from-database}{%
\chapter{Security users from
database}\label{security-users-from-database}}

\hypertarget{improving-userfixtures-with-a-createuser...-method-project-security03}{%
\section{\texorpdfstring{Improving UserFixtures with a
\texttt{createUser(...)} method (project
\texttt{security03})}{Improving UserFixtures with a createUser(...) method (project security03)}}\label{improving-userfixtures-with-a-createuser...-method-project-security03}}

Since making users in our \texttt{UserFixtures} class is very important,
let's add a \textbf{helper} method to make it very clear what the
properties of each new \texttt{User} object will be. See how clear the
following is, if we have an exrta method \texttt{createUser(...)}:

We need a \texttt{load(...)} method, that gets invoked when we are
loading fixtures from the CLI. This method creates objects for the
entities we want in our database, and the saves (persists) them to the
database:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ load}\OtherTok{(}\NormalTok{ObjectManager }\KeywordTok{$manager}\OtherTok{)}
\NormalTok{    \{}
        \CommentTok{// create objects}
        \KeywordTok{$userUser}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->createUser}\OtherTok{(}\StringTok{'user@user.com'}\OtherTok{,} \StringTok{'user'}\OtherTok{);}
        \KeywordTok{$userAdmin}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->createUser}\OtherTok{(}\StringTok{'admin@admin.com'}\OtherTok{,} \StringTok{'admin'}\OtherTok{,} \OtherTok{[}\StringTok{'ROLE_ADMIN'}\OtherTok{]);}
        \KeywordTok{$userMatt}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->createUser}\OtherTok{(}\StringTok{'matt.smith@smith.com'}\OtherTok{,} \StringTok{'smith'}\OtherTok{,} \OtherTok{[}\StringTok{'ROLE_ADMIN'}\OtherTok{,} \StringTok{'ROLE_SUPER_ADMIN'}\OtherTok{]);}

        \CommentTok{// add to DB queue}
        \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$userUser}\OtherTok{);}
        \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$userAdmin}\OtherTok{);}
        \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$userMatt}\OtherTok{);}

        \CommentTok{// send query to DB}
        \KeywordTok{$manager}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Rather than put all the work in the \texttt{load(...)} method, we can
create a helper method to create each new object. Method
\texttt{createUser(...)} creates and returns a reference to a new
\texttt{User} object given some parameters:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{private} \KeywordTok{function}\NormalTok{ createUser}\OtherTok{(}\KeywordTok{$username}\OtherTok{,} \KeywordTok{$plainPassword}\OtherTok{,} \KeywordTok{$roles}\NormalTok{ = }\OtherTok{[}\StringTok{'ROLE_USER'}\OtherTok{])}\NormalTok{:User}
\NormalTok{    \{}
        \KeywordTok{$user}\NormalTok{ = }\KeywordTok{new}\NormalTok{ User}\OtherTok{();}
        \KeywordTok{$user}\NormalTok{->setUsername}\OtherTok{(}\KeywordTok{$username}\OtherTok{);}
        \KeywordTok{$user}\NormalTok{->setRoles}\OtherTok{(}\KeywordTok{$roles}\OtherTok{);}

        \CommentTok{// password - and encoding}
        \KeywordTok{$encodedPassword}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->encodePassword}\OtherTok{(}\KeywordTok{$user}\OtherTok{,} \KeywordTok{$plainPassword}\OtherTok{);}
        \KeywordTok{$user}\NormalTok{->setPassword}\OtherTok{(}\KeywordTok{$encodedPassword}\OtherTok{);}

        \KeywordTok{return} \KeywordTok{$user}\OtherTok{;}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

NOTE: The default role is \texttt{ROLE\_USER} if none is provided.

\hypertarget{loading-the-fixtures-1}{%
\section{Loading the fixtures}\label{loading-the-fixtures-1}}

Loading fixtures involves deleting all existing database contents and
then creating the data from the fixture classes - so you'll get a
warning when loading fixtures. At the CLI type:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{php}\NormalTok{ bin/console doctrine:fixtures:load}
\end{Highlighting}
\end{Shaded}

That's it!

You should now be able to access \texttt{/admin} with either the
\texttt{matt.smith@smith.com/smith} or \texttt{admin@admin.com/admin}
users. You will get an Access Denied exception if you login with
\texttt{user@user.com/user}, since that only has \texttt{ROLE\_USER}
privileges, and \texttt{ROLE\_ADMIN} is required to visit
\texttt{/admin}.

See Figure \ref{denied_exception} to see the default Symfony (dev mode)
Access Denied exception page.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/f181b091bf6a4a0a60d5cb4a8121508d7ac4b938.png}
\caption{Screenshot of Default Symfony access denied page.
\label{denied_exception}}
\end{figure}

The next chapter will show you how to deal with (and log) access denied
exceptions \ldots{}

\hypertarget{using-sql-from-cli-to-see-users-in-db}{%
\section{Using SQL from CLI to see users in
DB}\label{using-sql-from-cli-to-see-users-in-db}}

To double check your fixtures have been created correctly in the
database, you could run an SQL query from the CLI:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console doctrine:query:sql }\StringTok{"SELECT * FROM user"}
    \ExtensionTok{Cannot}\NormalTok{ load Xdebug - it was already loaded}
    
    \ExtensionTok{/php-symfony-5-book-codes-security-03-create-user/vendor/doctrine/dbal/lib/Doctrine/DBAL/Tools}\NormalTok{/Dumper.php:}\ExtensionTok{71}\NormalTok{:}
    \ExtensionTok{array}\NormalTok{ (size=3)}
      \ExtensionTok{0}\NormalTok{ =}\OperatorTok{>} 
        \ExtensionTok{array}\NormalTok{ (size=4)}
          \StringTok{'id'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'2'}\NormalTok{ (length=1)}
          \StringTok{'email'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'user@user.com'}\NormalTok{ (length=13)}
          \StringTok{'roles'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'["ROLE_USER"]'}\NormalTok{ (length=13)}
          \StringTok{'password'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'$2y$13$yfMogZlZfDQ3cJeib6Q2kOqXemYBs.4/AnyK/RbAFp69.360N60ai'}\NormalTok{ (length=60)}
      \ExtensionTok{1}\NormalTok{ =}\OperatorTok{>} 
        \ExtensionTok{array}\NormalTok{ (size=4)}
          \StringTok{'id'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'3'}\NormalTok{ (length=1)}
          \StringTok{'email'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'admin@admin.com'}\NormalTok{ (length=15)}
          \StringTok{'roles'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'["ROLE_ADMIN"]'}\NormalTok{ (length=14)}
          \StringTok{'password'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'$2y$13$9UyVwrOluOkxLaH57IJM7uPF/NN7iKdBby.z9im2vx4531elfT80a'}\NormalTok{ (length=60)}
      \ExtensionTok{2}\NormalTok{ =}\OperatorTok{>} 
        \ExtensionTok{array}\NormalTok{ (size=4)}
          \StringTok{'id'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'4'}\NormalTok{ (length=1)}
          \StringTok{'email'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'matt.smith@smith.com'}\NormalTok{ (length=14)}
          \StringTok{'roles'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'["ROLE_ADMIN", "ROLE_SUPER_ADMIN"]'}\NormalTok{ (length=34)}
          \StringTok{'password'}\NormalTok{ =}\OperatorTok{>} \ExtensionTok{string} \StringTok{'$2y$13$4/yo6pKgUgECygZHbawemOSeANK78Cu6bGtKKbSgByFLFxASSlC3u'}\NormalTok{ (length=60)}
\end{Highlighting}
\end{Shaded}

\hypertarget{custom-login-page}{%
\chapter{Custom login page}\label{custom-login-page}}

\hypertarget{a-d.i.y.-customisable-login-form-project-security04}{%
\section{\texorpdfstring{A D.I.Y. (customisable) login form (project
\texttt{security04})}{A D.I.Y. (customisable) login form (project security04)}}\label{a-d.i.y.-customisable-login-form-project-security04}}

When we created the Authenticator it created a login form Twig template
for us:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:auth}

    \ExtensionTok{...} 

    \ExtensionTok{created}\NormalTok{: src/Controller/SecurityController.php}
    \ExtensionTok{created}\NormalTok{: templates/security/login.html.twig}
\end{Highlighting}
\end{Shaded}

This is just a Twig template, and we should feel free to look inside and
edit it ourselves \ldots{}

\hypertarget{simplifying-the-generated-login-twig-template}{%
\section{Simplifying the generated login Twig
template}\label{simplifying-the-generated-login-twig-template}}

The generated Twig login page is fine - but you should become confident
in making it your own.

Start by replacing it with this simple, standard HTML login form:

\begin{verbatim}
    <form method="post">
        <h1>Login</h1>

        Username:
        <input value="{{ last_username }}" name="email" id="inputEmail" autofocus>

        <p>
        Password:
        <input type="password" name="password" id="inputPassword">

        <input type="submit" value="Login">

    </form>
\end{verbatim}

The form is shown when the \texttt{/login} URL is visited, or Symfony is
redirected to internal route \texttt{app\_login}, with the HTTP
\texttt{GET} method. There is not \texttt{action} attribute for the
\texttt{\textless{}form\textgreater{}} element, so the form is submitted
to the same router, but using the \texttt{post} method.

Two name/value form variables are submitted:

\begin{itemize}
\item
  \texttt{email} - the email address being used as the unique username
\item
  \texttt{password} - the password
\end{itemize}

\hypertarget{csrf-cross-site-request-forgery-protection}{%
\section{CSRF (Cross Site Request Forgery)
protection}\label{csrf-cross-site-request-forgery-protection}}

Although this Twig template will present a login form to the user, it
will \textbf{not} be accepted by the Symfony security system, due to an
esxposre to CSRF security vulnerability.

NOTE: For any public \textbf{production} site you should always
implement CSRF protection. This is implemented using CSRF `tokens'
created on the server and exchanged with the web client and form
submissions. CSRF tokens help protect web applications against
cross-site scripting request forgery attacks and forged login attacks.

Symfony expects forms to submit a special form variable
\texttt{\_csrf\_token}. In Symfony this token can be generated using
Twig function
\texttt{csrf\_token(\textquotesingle{}authenticate\textquotesingle{})}.
So we need to add this as a hidden form variable for our D.I.Y. form to
work:

\begin{verbatim}
    <form method="post">
        <input type="hidden" name="_csrf_token" value="{{ csrf_token('authenticate') }}">

        ... as before
    </form>
\end{verbatim}

Learn more about CSRF threats and security:

\begin{itemize}
\tightlist
\item
  \href{https://symfony.com/doc/current/security/csrf.html}{Symfony CSRF
  protection}
\item
  \href{https://en.wikipedia.org/wiki/Cross-site_request_forgery\#Forging_login_requests}{Wikipedia}
\end{itemize}

When using the Symfony generated login form (as we created in this
chapter) the CSRF token protection is built-in automatically.

\hypertarget{display-any-errors}{%
\section{Display any errors}\label{display-any-errors}}

We are only missing one more important set of data from Symfony - any
errors to be displayed due to a previous invalid form submission. We
should always check for an \texttt{error} object, and if present display
its \texttt{messageData} values as follows (here I've added some CSS to
add some padding and a pink background colour):

\begin{verbatim}
    <form method="post">
        <input type="hidden" name="_csrf_token" value="{{ csrf_token('authenticate') }}">

        {% if error %}
            <div style="background-color: pink; padding: 1rem;">
                {{ error.messageKey|trans(error.messageData, 'security') }}
            </div>
        {% endif %}

       <h1>Login</h1>

        Username:
        <input value="{{ last_username }}" name="email" id="inputEmail" autofocus>

        <p>
        Password:
        <input type="password" name="password" id="inputPassword">

        <input type="submit" value="Login">
    </form>
\end{verbatim}

Above we can see the following in our Login Twig template:

\begin{verbatim}
- the HTML `<form>` open tag, which we see submits via HTTP `POST` method

    - no action is given, so the form will submit to the same URL as displayed the form (`/login`), but with a `POST` method

- add the security CSRF token as a hidden form variable    


- display of any Twig `error` variable received

- the `username` label and text input field

    - with 'sticky' form last username value (`last_username`) if any found in the Twig variables

- the `password` label and password input field

- the submit button named `Login`
\end{verbatim}

\hypertarget{custom-login-form-when-attempting-to-access-admin}{%
\section{\texorpdfstring{Custom login form when attempting to access
\texttt{/admin}}{Custom login form when attempting to access /admin}}\label{custom-login-form-when-attempting-to-access-admin}}

See Figure \ref{custom_login_form} to see our custom login form in
action.

\begin{figure}
\centering
\includegraphics[width=0.75\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/6ae94af6a6d64805890fbeb693bf09927b28b8c9.png}
\caption{Screenshot of custom login form. \label{custom_login_form}}
\end{figure}

\hypertarget{path-for-successful-login}{%
\section{Path for successful login}\label{path-for-successful-login}}

If the user visits the path \texttt{/login} directly in the browser,
Symfony needs to know where to direct the user if login is successful.
This is defined in method \texttt{onAuthenticationSuccess} in class
\texttt{Security/LoginFormAuthenticator}. If no redirect is defined,
then the \texttt{TODO} Exception will be thrown:

\begin{Shaded}
\begin{Highlighting}[]
        \KeywordTok{throw} \KeywordTok{new}\NormalTok{ \textbackslash{}}\KeywordTok{Exception}\OtherTok{(}\StringTok{'TODO: provide a valid redirect inside '}\NormalTok{.}\KeywordTok{__FILE__}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

Since we have a secure \textbf{admin} page, then let's redirect to route
\texttt{admin}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ onAuthenticationSuccess}\OtherTok{(}\NormalTok{Request }\KeywordTok{$reques§t}\OtherTok{,}\NormalTok{ TokenInterface }\KeywordTok{$token}\OtherTok{,} \KeywordTok{$providerKey}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{if} \OtherTok{(}\KeywordTok{$targetPath}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getTargetPath}\OtherTok{(}\KeywordTok{$request}\NormalTok{->getSession}\OtherTok{(),} \KeywordTok{$providerKey}\OtherTok{))}\NormalTok{ \{}
            \KeywordTok{return} \KeywordTok{new}\NormalTok{ RedirectResponse}\OtherTok{(}\KeywordTok{$targetPath}\OtherTok{);}
\NormalTok{        \}}

        \KeywordTok{return} \KeywordTok{new}\NormalTok{ RedirectResponse}\OtherTok{(}\KeywordTok{$this}\NormalTok{->urlGenerator->generate}\OtherTok{(}\StringTok{'admin'}\OtherTok{));}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

If you want to redirect to different pages, depending on the
\textbf{role} of the newly logged-in user, then do the following:

\begin{itemize}
\item
  get the array of string roles from \texttt{\$token} with
  \texttt{\$token-\textgreater{}getRoles()}
\item
  add \texttt{IF}-statement(s) returning a different named route
  depending on their role, e.g.~something like:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{if}\OtherTok{(}\FunctionTok{in_array}\OtherTok{(}\StringTok{'ROLE_ADMIN'}\OtherTok{,} \KeywordTok{$roles}\OtherTok{)}\NormalTok{\{        }
        \KeywordTok{return} \KeywordTok{new}\NormalTok{ RedirectResponse}\OtherTok{(}\KeywordTok{$this}\NormalTok{->urlGenerator->generate}\OtherTok{(}\StringTok{'index_admin'}\OtherTok{));}
\NormalTok{    \}        }

    \CommentTok{// else direct to basic staff homne page - or whatever ...}
    \KeywordTok{return} \KeywordTok{new}\NormalTok{ RedirectResponse}\OtherTok{(}\KeywordTok{$this}\NormalTok{->urlGenerator->generate}\OtherTok{(}\StringTok{'index_staff'}\OtherTok{));}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\hypertarget{custom-accessdeniedexception-handler}{%
\chapter{Custom AccessDeniedException
handler}\label{custom-accessdeniedexception-handler}}

\hypertarget{symfony-documentation-for-403-access-denied-exception}{%
\section{Symfony documentation for 403 access denied
exception}\label{symfony-documentation-for-403-access-denied-exception}}

For details about this topic visit the Symfony documentation:

\begin{itemize}
\tightlist
\item
  \url{https://symfony.com/doc/current/security/access_denied_handler.html}
\end{itemize}

\hypertarget{declaring-our-handler-project-security05}{%
\section{\texorpdfstring{Declaring our handler (project
\texttt{security05})}{Declaring our handler (project security05)}}\label{declaring-our-handler-project-security05}}

In \texttt{/config/packages/security.yml} we need to declare that the
class we'll write below will handle access denied exceptions.

So we add this line to the end of our \texttt{main} firewall in
\texttt{security.yml}:

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{access_denied_handler:}\AttributeTok{ App\textbackslash{}Security\textbackslash{}AccessDeniedHandler}
\end{Highlighting}
\end{Shaded}

So the full listing for our \texttt{security.yml} is now:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{security:}
    \FunctionTok{encoders:}
        \FunctionTok{App\textbackslash{}Entity\textbackslash{}User:}
            \FunctionTok{algorithm:}\AttributeTok{ bcrypt}

    \FunctionTok{providers:}
        \FunctionTok{our_db_provider:}
            \FunctionTok{entity:}
                \FunctionTok{class:}\AttributeTok{ App\textbackslash{}Entity\textbackslash{}User}
                \FunctionTok{property:}\AttributeTok{ username}

    \FunctionTok{firewalls:}
        \FunctionTok{dev:}
            \FunctionTok{pattern:}\AttributeTok{ ^/(_(profiler|wdt)|css|images|js)/}
            \FunctionTok{security:}\AttributeTok{ }\CharTok{false}
        \FunctionTok{main:}
            \FunctionTok{anonymous:}\AttributeTok{ }\CharTok{true}
            \FunctionTok{provider:}\AttributeTok{ our_db_provider}
            \FunctionTok{form_login:}
                \FunctionTok{login_path:}\AttributeTok{ login}
                \FunctionTok{check_path:}\AttributeTok{ login}
            \FunctionTok{logout:}
                \FunctionTok{path:}\AttributeTok{   /logout}
                \FunctionTok{target:}\AttributeTok{ /}
            \FunctionTok{access_denied_handler:}\AttributeTok{ App\textbackslash{}Security\textbackslash{}AccessDeniedHandler}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-exception-handler-class}{%
\section{The exception handler
class}\label{the-exception-handler-class}}

Now we needs to write our exception handler class in
\texttt{/src/Security}.

Create new class \texttt{AccessDeniedHandler} in file
\texttt{/src/Security/AccessDeniedHandler.php}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Security}\OtherTok{;}

    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Request}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Response}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Security\textbackslash{}Core\textbackslash{}}\KeywordTok{Exception}\NormalTok{\textbackslash{}AccessDeniedException}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Security\textbackslash{}Http\textbackslash{}Authorization\textbackslash{}AccessDeniedHandlerInterface}\OtherTok{;}

    \KeywordTok{class}\NormalTok{ AccessDeniedHandler }\KeywordTok{implements}\NormalTok{ AccessDeniedHandlerInterface}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ handle}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{,}\NormalTok{ AccessDeniedException }\KeywordTok{$accessDeniedException}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{return} \KeywordTok{new}\NormalTok{ Response}\OtherTok{(}\StringTok{'sorry - you have been denied access'}\OtherTok{,} \DecValTok{403}\OtherTok{);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

That's it!

Now if you try to access \texttt{/admin} with \texttt{user/user} you'll
see the message `sorry - you have been denied access' on screen. See
Figure \ref{denied_exception}.

\begin{figure}
\centering
\includegraphics[width=0.75\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/f4cc4aaf3249bfde725a7e233578eed13886be41.png}
\caption{Screenshot of Custom Twig access denied page.
\label{denied_exception}}
\end{figure}

Although it won't be generated through the Twig templating system -
we'll learn how to do that next \ldots{}

\hypertarget{twig-and-logging}{%
\chapter{Twig and logging}\label{twig-and-logging}}

\hypertarget{getting-reference-to-twig-and-logger-objects}{%
\section{Getting reference to Twig and Logger
objects}\label{getting-reference-to-twig-and-logger-objects}}

There are many useful service objects available in the Symfony system
via the `Service Container'. This is a design pattern known as
\textbf{Dependency Injection}. In Symfony we get access to a servce
object by \textbf{Type Hinting} with the server or interface class name,
in the parameter parentheses of the method or constructor of the class.

In this chapter we'll use this technique to get a reference to the Twig
and Logger service objects.

Learn more in the Symfony documentation:

\begin{itemize}
\item
  \url{https://symfony.com/doc/current/service_container.html}
\item
  \url{https://symfony.com/doc/current/components/dependency_injection.html}
\end{itemize}

\hypertarget{using-twig-for-access-denied-message-project-security06}{%
\section{\texorpdfstring{Using Twig for access denied message (project
\texttt{security06})}{Using Twig for access denied message (project security06)}}\label{using-twig-for-access-denied-message-project-security06}}

Let's improved our Access Denied exception handler in 2 ways:

\begin{itemize}
\item
  display a nice Twig template
\item
  log the exception using the standard Monolog logging system
\end{itemize}

First add Monolog to our project with Composer:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ req logger}
\end{Highlighting}
\end{Shaded}

Now we will refactor class \texttt{AccessDeniedHandler} to

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Security}\OtherTok{;}

    \KeywordTok{use}\NormalTok{ Psr\textbackslash{}}\FunctionTok{Log}\NormalTok{\textbackslash{}LoggerInterface}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}DependencyInjection\textbackslash{}ContainerInterface}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Request}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Response}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Security\textbackslash{}Core\textbackslash{}}\KeywordTok{Exception}\NormalTok{\textbackslash{}AccessDeniedException}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Security\textbackslash{}Http\textbackslash{}Authorization\textbackslash{}AccessDeniedHandlerInterface}\OtherTok{;}

    \KeywordTok{class}\NormalTok{ AccessDeniedHandler }\KeywordTok{implements}\NormalTok{ AccessDeniedHandlerInterface}
\NormalTok{    \{}
        \KeywordTok{private} \KeywordTok{$twig}\OtherTok{;}
        \KeywordTok{private} \KeywordTok{$logger}\OtherTok{;}

        \KeywordTok{public} \KeywordTok{function} \FunctionTok{__construct}\OtherTok{(}\NormalTok{ContainerInterface }\KeywordTok{$container}\OtherTok{,}\NormalTok{ LoggerInterface }\KeywordTok{$logger}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$this}\NormalTok{->twig = }\KeywordTok{$container}\NormalTok{->get}\OtherTok{(}\StringTok{'twig'}\OtherTok{);}
            \KeywordTok{$this}\NormalTok{->logger = }\KeywordTok{$logger}\OtherTok{;}
\NormalTok{        \}}

\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Now we can re-write method \texttt{handle(...)} to log an error message,
and

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ handle}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{,}\NormalTok{ AccessDeniedException }\KeywordTok{$accessDeniedException}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$this}\NormalTok{->logger->error}\OtherTok{(}\StringTok{'access denied exception'}\OtherTok{);}

        \KeywordTok{$template}\NormalTok{ = }\StringTok{'error/accessDenied.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[];}
        \KeywordTok{$html}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->twig->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
        \KeywordTok{return} \KeywordTok{new}\NormalTok{ Response}\OtherTok{(}\KeywordTok{$html}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-twig-page}{%
\section{The Twig page}\label{the-twig-page}}

Create a new folder \texttt{error} in our \texttt{/templates} folder,
and in that create new Twig template \texttt{accessDenied.html.twig} for
our nicer looking error page:

\begin{verbatim}
    {% extends 'base.html.twig' %}
    
    {% block title %}error{% endblock %}
    
    {% block body %}
        sorry - access is denied for your request
        <p>
            <a href="{{ url('homepage') }}">home</a>
        </p>
    {% endblock %}
\end{verbatim}

Now, login in as \texttt{user@user.com} and try to visit
\texttt{/admin}. We should get that access denied exception again, since
this user does not have the required \texttt{ROLE\_ADMIN} role
privilege. See Figure \ref{denied_log} to see the error log register in
the Symfony profiler footer, at the bottom of our custom error page.

\begin{figure}
\centering
\includegraphics[width=0.75\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/5d7967da5faff673e42573d187ad5b911c5112c2.png}
\caption{Screenshot of Custom Twig access denied page.
\label{denied_log}}
\end{figure}

If you click on the red error you'll see details of all logged messages
during the processing of this request. See Figure \ref{profiler_log}.

\begin{figure}
\centering
\includegraphics[width=0.75\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/df4541901cd35983e7beb2048b210fa5f1087755.png}
\caption{Screenshot of Profiler log entries. \label{profiler_log}}
\end{figure}

\hypertarget{terminal-log}{%
\section{Terminal log}\label{terminal-log}}

You'll also see a red highlighted error appear in the terminal window if
you are serving this website project with the Symfony web server:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ [}\ExtensionTok{OK}\NormalTok{] Web server listening on https://127.0.0.1:8000 (PHP FPM 7.3.8)                                                    }

    \ExtensionTok{Mar}\NormalTok{ 10 17:11:55 }\KeywordTok{|}\ExtensionTok{WARN} \KeywordTok{|} \ExtensionTok{SERVER}\NormalTok{ GET  (403) }\ExtensionTok{/admin}\NormalTok{ ip=}\StringTok{"127.0.0.1"}
    \ExtensionTok{Mar}\NormalTok{ 10 18:11:54 }\KeywordTok{|}\ExtensionTok{INFO} \KeywordTok{|} \ExtensionTok{REQUES}\NormalTok{ Matched route }\StringTok{"admin"}\NormalTok{. method=}\StringTok{"GET"}\NormalTok{ request_uri=}\StringTok{"https://127.0.0.1:8000/admin"}\NormalTok{ route=}\StringTok{"admin"}\NormalTok{ route_parameters=}\DataTypeTok{\{"_controller":"App\textbackslash{}\textbackslash{}Controller\textbackslash{}\textbackslash{}AdminController::index","_route":"admin"\}}
    \ExtensionTok{Mar}\NormalTok{ 10 18:11:55 }\KeywordTok{|}\ExtensionTok{DEBUG}\KeywordTok{|} \ExtensionTok{SECURI}\NormalTok{ Checking for guard authentication credentials. authenticators=1 firewall_key=}\StringTok{"main"}
        \ExtensionTok{...}\NormalTok{ a bunch more DEBUG logs ....}
    \ExtensionTok{Mar}\NormalTok{ 10 18:11:55 }\KeywordTok{|}\ExtensionTok{DEBUG}\KeywordTok{|} \ExtensionTok{SECURI}\NormalTok{ Access denied, the user is neither anonymous, nor remember-me. }

    \ExtensionTok{Mar}\NormalTok{ 10 18:11:55 }\KeywordTok{|}\ExtensionTok{ERROR}\KeywordTok{|} \ExtensionTok{APP}\NormalTok{    access denied exception  }\OperatorTok{<<<<<<}\NormalTok{ here is our acess denied logged error in the terminal }
\end{Highlighting}
\end{Shaded}

\hypertarget{learn-more-about-logger-and-exceptions}{%
\section{Learn more about logger and
exceptions}\label{learn-more-about-logger-and-exceptions}}

Learn more about Symfony and the Monolog logger:

\begin{itemize}
\tightlist
\item
  \href{http://symfony.com/doc/current/logging.html}{Logging with
  Monolog}
\end{itemize}

Learn more about custom exception handlers and error pages:

\begin{itemize}
\tightlist
\item
  \href{https://symfony.com/doc/current/security/access_denied_handler.html}{Access
  Denied Handler}
\item
  \href{https://symfony.com/doc/current/controller/error_pages.html}{Custom
  Error pages}
\end{itemize}

\hypertarget{user-roles-and-role-hierarchies}{%
\chapter{User roles and role
hierarchies}\label{user-roles-and-role-hierarchies}}

\hypertarget{simplifying-roles-with-a-hierarchy-project-security07}{%
\section{\texorpdfstring{Simplifying roles with a hierarchy (project
\texttt{security07})}{Simplifying roles with a hierarchy (project security07)}}\label{simplifying-roles-with-a-hierarchy-project-security07}}

Let's avoid repeating roles in our program logic (e.g.~IF
\texttt{ROLE\_USER} OR \texttt{ROLE\_ADMIN}) by creating a hierarchy, so
we can give \texttt{ROLE\_ADMIN} all properties of \texttt{ROLE\_USER}
as well. We can easily create a role hierarchy in
\texttt{/config/packages/security.yml}:

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{security:}
        \FunctionTok{role_hierarchy:}
            \FunctionTok{ROLE_ADMIN:}\AttributeTok{       ROLE_USER}

\NormalTok{        ... rest of }\StringTok{'security.yml'}\NormalTok{ as before ...}
\end{Highlighting}
\end{Shaded}

In fact let's go one further - let's create a 3rd user role
(\texttt{ROLE\_SUPER\_ADMIN}) and define that as having all
\texttt{ROLE\_ADMIN} privileges plus the \texttt{ROLE\_USER} privileges
that were inherited by \texttt{ROLE\_ADMIN}:

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{security:}
        \FunctionTok{role_hierarchy:}
            \FunctionTok{ROLE_ADMIN:}\AttributeTok{       ROLE_USER}
            \FunctionTok{ROLE_SUPER_ADMIN:}\AttributeTok{ ROLE_ADMIN}

\NormalTok{        ... rest of }\StringTok{'security.yml'}\NormalTok{ as before ...}
\end{Highlighting}
\end{Shaded}

Now if we log in as a user with \texttt{ROLE\_SUPER\_ADMIN} we also get
\texttt{ROLE\_ADMIN} and \texttt{ROLE\_USER} too!

\hypertarget{modify-fixtures}{%
\section{Modify fixtures}\label{modify-fixtures}}

Now we can modify our fixtures to make user \texttt{matt} have just
\texttt{ROLE\_SUPER\_ADMIN} - the other roles should be inherited
through the hierarchy:

Change \texttt{/src/DataFixtures/UserFixtures.php} as follows:

\begin{Shaded}
\begin{Highlighting}[]
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ load}\OtherTok{(}\NormalTok{ObjectManager }\KeywordTok{$manager}\OtherTok{)}
\NormalTok{        \{}
            \StringTok{...}

            \KeywordTok{$userMatt}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->createUser}\OtherTok{(}\StringTok{'matt.smith@smith.com'}\OtherTok{,} \StringTok{'smith'}\OtherTok{,} \OtherTok{[}\StringTok{'ROLE_SUPER_ADMIN'}\OtherTok{]);}

            \StringTok{...}
\end{Highlighting}
\end{Shaded}

\hypertarget{removing-default-adding-of-role_user-if-using-a-hierarchy}{%
\section{\texorpdfstring{Removing default adding of \texttt{ROLE\_USER}
if using a
hierarchy}{Removing default adding of ROLE\_USER if using a hierarchy}}\label{removing-default-adding-of-role_user-if-using-a-hierarchy}}

If we are using a hierarchy, we don't need always add
\texttt{ROLE\_USER} in code, so we can simplify our getter in our
\texttt{User} Entity in \texttt{/src/Entity/User.php}:

\begin{verbatim}
```php
    public function getRoles()
    {
        return $this->roles;
    }
```
\end{verbatim}

We'll still see \texttt{ROLE\_USER} for admin and super users, but in
the list of \textbf{inherited} roles from the hierarchy. This is show in
Figure \ref{role_inherited}.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/2404dfd6a394c9f1aedb6443b74ebf498abf0705.png}
\caption{Super admin user inheriting \texttt{ROLE\_USER}.
\label{role_inherited}}
\end{figure}

Learn about user role hierarchies at:

\begin{itemize}
\tightlist
\item
  \href{https://symfony.com/doc/current/security.html\#hierarchical-roles}{Symfony
  hierarchical roles}
\end{itemize}

\hypertarget{allowing-easy-switching-of-users-when-debugging}{%
\section{Allowing easy switching of users when
debugging}\label{allowing-easy-switching-of-users-when-debugging}}

If you wish to speed up testing, you can allow easy switching between
users just by adding a but at the end of your request URL, \textbf{if}
you add the following to your firewall:

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{switch_user:}\AttributeTok{ }\CharTok{true}
\end{Highlighting}
\end{Shaded}

Now you can switch users bu adding the following at the end of the URL:

\begin{verbatim}
    ?_switch_user=<username>
\end{verbatim}

You stop impersonating users by adding \texttt{?\_switch\_user=\_exit}
to the end of a URL.

For example to visit the home page as user \texttt{user} you would write
this URL:

\begin{verbatim}
    http://localhost:8000/?_switch_user=user
\end{verbatim}

In your Twig you can allow this user to see special content (e.g.~a link
to exit impersonation) by testing for the special (automatically created
role) \texttt{ROLE\_PREVIOUS\_ADMIN}:

\begin{verbatim}
    {% if is_granted('ROLE_PREVIOUS_ADMIN') %}
        <a href="{{ path('admin_index', {'_switch_user': '_exit'}) }}">Exit impersonation & return to admin home</a>
    {% endif %}
\end{verbatim}

Learn more at:

\begin{itemize}
\tightlist
\item
  \href{https://symfony.com/doc/current/security/impersonating_user.html}{Impersonating
  users}
\end{itemize}

\hypertarget{customising-view-based-on-logged-in-user}{%
\chapter{Customising view based on logged-in
user}\label{customising-view-based-on-logged-in-user}}

\hypertarget{twig-nav-links-when-logged-in-project-security08}{%
\section{\texorpdfstring{Twig nav links when logged in (project
\texttt{security08})}{Twig nav links when logged in (project security08)}}\label{twig-nav-links-when-logged-in-project-security08}}

The
\href{https://symfony.com/doc/current/security.html\#fetch-the-user-in-a-template}{Symfony
security docs} give us the Twig code for a conditional statement for
when the current user has logged in:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    \{% if is_granted('IS_AUTHENTICATED_FULLY') %\}}
        \KeywordTok{<p>}\NormalTok{Username: \{\{ app.user.username \}\}}\KeywordTok{</p>}
\NormalTok{    \{% endif %\}}
\end{Highlighting}
\end{Shaded}

We can also test for which \textbf{role} a user may have granted when
logged-in, e.g.:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    \{% if is_granted('ROLE_ADMIN') %\}}
\NormalTok{          Welcome to the Admin home page ...}
\NormalTok{    \{% endif %\}}
\end{Highlighting}
\end{Shaded}

We can use such conditionals in 2 useful and common ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Confirm the login username and offer a \texttt{logout} link for users
  who are logged in
\item
  Have navbar links revealed only for logged-in users (of particular
  roles)
\end{enumerate}

So let's add such code to our \texttt{base.html.twig} master template
(in \texttt{/templates}).

First, let's add a \texttt{\textless{}header\textgreater{}} element to
either show the username and a logout link, or a link to login if the
user is not logged-in yet:

\begin{verbatim}
    <header>
        {% if is_granted('IS_AUTHENTICATED_FULLY') %}
            Username:
            <strong>{{ app.user.username }}</strong>
            <br>
            <a href="{{ url('app_logout') }}">logout</a>
        {% else %}
            <a href="{{ url('app_login') }}">login</a>
        {% endif %}
    </header>
\end{verbatim}

We can right align it and have a black bottom border with a little style
in the \texttt{\textless{}head\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <!DOCTYPE html}\OperatorTok{>}
\NormalTok{    <html}\OperatorTok{>}
\NormalTok{        <head}\OperatorTok{>}
\NormalTok{            <meta charset="UTF-8"}\OperatorTok{>}
\NormalTok{            <title}\OperatorTok{>}\NormalTok{\{% block title %\}Welcome!\{% endblock %\}</title}\OperatorTok{>}

\NormalTok{            <style}\OperatorTok{>}
\NormalTok{                header \{}
                    \KeywordTok{text-align}\NormalTok{: }\DecValTok{right}\OperatorTok{;}
                    \KeywordTok{border-bottom}\NormalTok{: }\DecValTok{0.5}\DataTypeTok{rem} \DecValTok{solid} \ConstantTok{black}\OperatorTok{;}
                    \KeywordTok{padding}\NormalTok{: }\DecValTok{1}\DataTypeTok{rem}\OperatorTok{;}
\NormalTok{                \}}
\NormalTok{            </style}\OperatorTok{>}
\end{Highlighting}
\end{Shaded}

Next, let's define a \texttt{\textless{}nav\textgreater{}} element, so
that \textbf{all} users see a link to the homepage on every page on the
website (at least those that extend \texttt{base.html.twig}). We will
also add a conditional navigation link - to that users logged-in with
\texttt{ROLE\_ADMIN} can also see a link to the admin home page:

\begin{verbatim}
    <nav>
        <ul>
            <li>
                <a href="{{ url('homepage') }}">home</a>
            </li>

            {% if is_granted('ROLE_ADMIN') %}
                <li>
                    <a href="{{ url('admin') }}">admin home</a>
                </li>
            {% endif %}
        </ul>
    </nav>
\end{verbatim}

So when a user first visits our website homepage, they are not
logged-in, so will see a \texttt{login} link in the header, and the
navigation bar will only show a link to this homepage. See Figure
\ref{homepage_login_link}.

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/37775f03f58d57201d8d743fdd9e86349205c708.png}
\caption{Screenshot of homepage before logging-in.
\label{homepage_login_link}}
\end{figure}

If the user has successfully logged-in with a \texttt{ROLE\_ADMIN}
privilege account, they will now see their userame and a \texttt{logout}
link in the header, and they will also see revealed a link to the admin
home page. See Figure \ref{admin_user_homepage}.

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/49ec37103f4f81567fa2694c122b38f522d2b6be.png}
\caption{Screenshot of homepage after \texttt{ROLE\_ADMIN} has
logged-in.\label{admin_user_homepage}}
\end{figure}

\hypertarget{getting-reference-to-the-current-user-in-a-controller}{%
\section{Getting reference to the current user in a
Controller}\label{getting-reference-to-the-current-user-in-a-controller}}

in PHP (e.g.~a controller) you can get the user object as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$user}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getUser}\OtherTok{();}
\end{Highlighting}
\end{Shaded}

or you can type-hint in a controller method declaration, and the param
converter will provide the \$security object for your to interrogate:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Security\textbackslash{}Core\textbackslash{}Security}\OtherTok{;}

    \KeywordTok{public} \KeywordTok{function}\NormalTok{ indexAction}\OtherTok{(}\NormalTok{Security }\KeywordTok{$security}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$user}\NormalTok{ = }\KeywordTok{$security}\NormalTok{->getUser}\OtherTok{();}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

see:

\begin{itemize}
\tightlist
\item
  \url{https://symfony.com/doc/current/security.html\#a-fetching-the-user-object}

  \part{Entity associations (one-to-many relationships etc.)}
\end{itemize}

\hypertarget{database-relationships-doctrine-associations}{%
\chapter{Database relationships (Doctrine
associations)}\label{database-relationships-doctrine-associations}}

\hypertarget{information-about-symfony-4-and-databases}{%
\section{Information about Symfony 4 and
databases}\label{information-about-symfony-4-and-databases}}

Learn about Doctrine relationships and associates at the Symfony
documentation pages:

\begin{itemize}
\item
  \url{https://symfony.com/doc/current/doctrine.html\#relationships-and-associations}
\item
  \url{https://symfony.com/doc/current/doctrine/associations.html}
\end{itemize}

\hypertarget{create-a-new-project-from-scratch-project-associations01}{%
\section{\texorpdfstring{Create a new project from scratch (project
\texttt{associations01})}{Create a new project from scratch (project associations01)}}\label{create-a-new-project-from-scratch-project-associations01}}

Create a new project, adding the usual packages for database and CRUD
generation:

\begin{itemize}
\tightlist
\item
  server
\item
  make
\item
  twig
\item
  annotations
\item
  doctrine
\item
  form
\item
  validation
\item
  annotations
\item
  security-csrf
\item
  orm-fixtures
\end{itemize}

\hypertarget{categories-for-products}{%
\section{Categories for Products}\label{categories-for-products}}

Let's work with a project where we have \texttt{Products}, and two
categories of Product:

\begin{itemize}
\item
  large items
\item
  small items
\end{itemize}

So we need to generate a Entity \texttt{Category} , with a \texttt{name}
property:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{     $ }\ExtensionTok{php}\NormalTok{ bin/console make:entity Category}
     
      \ExtensionTok{created}\NormalTok{: src/Entity/Category.php}
      \ExtensionTok{created}\NormalTok{: src/Repository/CategoryRepository.php}
      
      \ExtensionTok{Entity}\NormalTok{ generated! Now let}\StringTok{'s add some fields!}
\StringTok{      You can always add more fields later manually or by re-running this command.}
\StringTok{     }
\StringTok{      New property name (press <return> to stop adding fields):}
\StringTok{      > name }

\StringTok{      ... (hit <RETURN> for defaults and to end generation)}
\end{Highlighting}
\end{Shaded}

Now generate a Product Entity, with properties for \texttt{description}
(text), \texttt{image} (text) and \texttt{price} (float):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:entity Product}

     \ExtensionTok{created}\NormalTok{: src/Entity/Product.php}
     \ExtensionTok{created}\NormalTok{: src/Repository/ProductRepository.php}
     
     \ExtensionTok{...}\NormalTok{ etc. etc.}
\end{Highlighting}
\end{Shaded}

\hypertarget{defining-the-many-to-one-relationship-from-product-to-category}{%
\section{Defining the many-to-one relationship from Product to
Category}\label{defining-the-many-to-one-relationship-from-product-to-category}}

We now edit our \texttt{Product} entity, declaring a property
\texttt{category} that has a many-to-one relationship with entity
\texttt{Category}. I.e., many products relate to one category.

Add the following field and setter in \texttt{/src/Entity/Product.php}:

\begin{Shaded}
\begin{Highlighting}[]

    \KeywordTok{class}\NormalTok{ Product}
\NormalTok{    \{}

        \StringTok{...}\NormalTok{ properties }\KeywordTok{and}\NormalTok{ accessor methods }\KeywordTok{for}\NormalTok{ descrition / image / price }\StringTok{...}

        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@ORM\textbackslash{}ManyToOne(targetEntity="App\textbackslash{}Entity\textbackslash{}Category",}\CommentTok{ inversedBy="products")}
\CommentTok{         * }\AnnotationTok{@ORM\textbackslash{}JoinColumn(nullable=true)}
\CommentTok{         */}
        \KeywordTok{private} \KeywordTok{$category}\OtherTok{;}

        \KeywordTok{public} \KeywordTok{function}\NormalTok{ getCategory}\OtherTok{()}\NormalTok{: Category}
\NormalTok{        \{}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->category}\OtherTok{;}
\NormalTok{        \}}

        \KeywordTok{public} \KeywordTok{function}\NormalTok{ setCategory}\OtherTok{(}\NormalTok{Category }\KeywordTok{$category}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$this}\NormalTok{->category = }\KeywordTok{$category}\OtherTok{;}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{how-to-allow-null-for-a-products-category}{%
\section{\texorpdfstring{How to allow \texttt{null} for a Product's
category}{How to allow null for a Product's category}}\label{how-to-allow-null-for-a-products-category}}

We need to allow \texttt{null} for a Product's category:

\begin{itemize}
\item
  when it is first created (to generate a form the easy way)
\item
  to allow a category to be removed from a Product
\end{itemize}

We need to allow our `getter' to return \texttt{null} or a reference to
a \texttt{Category}, so we change the return type to \texttt{?Category}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{// allow null - ?Category vs Category}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ getCategory}\OtherTok{()}\NormalTok{: }\OtherTok{?}\NormalTok{Category}
\NormalTok{    \{}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->category}\OtherTok{;}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

We need set the default value for our `setter' to \texttt{null}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{// default Category to null}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ setCategory}\OtherTok{(}\NormalTok{Category }\KeywordTok{$category}\NormalTok{ = }\KeywordTok{null}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$this}\NormalTok{->category = }\KeywordTok{$category}\OtherTok{;}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

This `nullable' parameter/return value is one of the new features from
PHP 7.1 onwards:

\begin{itemize}
\tightlist
\item
  \href{http://php.net/manual/en/migration71.new-features.php}{PHP.net
  guide to migrating to PHP 7.1}
\end{itemize}

\hypertarget{adding-the-optional-one-to-many-relationship-from-category-to-product}{%
\section{Adding the optional one-to-many relationship from Category to
Product}\label{adding-the-optional-one-to-many-relationship-from-category-to-product}}

Each \texttt{Category} relates to many \texttt{Products}. Symfony with
Doctrine makes it very easy to get an array of \texttt{Product} objects
for a given \texttt{Category} object, without having to write any
queries. We just declare a \texttt{products} property in gthe
\texttt{Category} entity class, and use annotations to declare that it
is the recipricol one-to-many relationship with entity \texttt{Product}.

Add the following field and setter in \texttt{/src/Entity/Product.php}
(don't forget to add the \texttt{use} statement for class
\texttt{ArrayCollection}):

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}}\KeywordTok{ORM}\NormalTok{\textbackslash{}Mapping }\KeywordTok{as} \KeywordTok{ORM}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}Common\textbackslash{}Collections\textbackslash{}ArrayCollection}\OtherTok{;}

    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@ORM\textbackslash{}Entity(repositoryClass="App\textbackslash{}Repository\textbackslash{}CategoryRepository")}
\CommentTok{     */}
    \KeywordTok{class}\NormalTok{ Category}
\NormalTok{    \{}
        \StringTok{...}\NormalTok{ properties }\KeywordTok{and}\NormalTok{ accessor methods }\KeywordTok{for}\NormalTok{ name }\StringTok{...}

        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@ORM\textbackslash{}OneToMany(targetEntity="App\textbackslash{}Entity\textbackslash{}Product",}\CommentTok{ mappedBy="category")}
\CommentTok{         */}
        \KeywordTok{private} \KeywordTok{$products}\OtherTok{;}

        \KeywordTok{public} \KeywordTok{function} \FunctionTok{__construct}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{$this}\NormalTok{->products = }\KeywordTok{new}\NormalTok{ ArrayCollection}\OtherTok{();}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{create-and-migrate-db-schema}{%
\section{Create and migrate DB
schema}\label{create-and-migrate-db-schema}}

Configure your \texttt{.env} database settings:

\begin{verbatim}
    DB_USER=root
    DB_PASSWORD=pass
    DB_HOST=127.0.0.1
    DB_PORT=3306
    DB_NAME=web7
    DATABASE_URL=mysql://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}
\end{verbatim}

Generate the database, and migrations and migrate:

\begin{verbatim}
    $ php bin/console doctrine:database:create
    $ php bin/console doctrine:migrations:diff
    $ php bin/console doctrine:migrations:migrate
\end{verbatim}

\hypertarget{generate-crud-for-product-and-category}{%
\section{Generate CRUD for Product and
Category}\label{generate-crud-for-product-and-category}}

Then generate CRUD for this entity (i.e.~a ProductController and some
templates in \texttt{/templates/product/}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:crud Product}
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:crud Category}
\end{Highlighting}
\end{Shaded}

\hypertarget{add-category-selection-in-product-form}{%
\section{Add Category selection in Product
form}\label{add-category-selection-in-product-form}}

Our generated CRUD for Product creates a Symfony form using method
\texttt{buildForm(...)} in generated form class
\texttt{/src/Form/ProductType}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ buildForm}\OtherTok{(}\NormalTok{FormBuilderInterface }\KeywordTok{$builder}\OtherTok{,} \KeywordTok{array} \KeywordTok{$options}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$builder}
\NormalTok{            ->add}\OtherTok{(}\StringTok{'description'}\OtherTok{)}
\NormalTok{            ->add}\OtherTok{(}\StringTok{'image'}\OtherTok{)}
\NormalTok{            ->add}\OtherTok{(}\StringTok{'price'}\OtherTok{)}
\NormalTok{            ->add}\OtherTok{(}\StringTok{'category'}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

We need to refine this form builder a declaration that the
\texttt{Category} to be associated with this Product can be set in the
form. So we need to refine the \texttt{category} property to our builder
as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    ->add}\OtherTok{(}\StringTok{'category'}\OtherTok{,}\NormalTok{ EntityType::}\KeywordTok{class}\OtherTok{,} \OtherTok{[}
              \CommentTok{// list objects from this class}
              \StringTok{'class'}\NormalTok{ => }\StringTok{'App:Category'}\OtherTok{,}

              \CommentTok{// use the 'Category.name' property as the visible option string}
              \StringTok{'choice_label'}\NormalTok{ => }\StringTok{'name'}\OtherTok{,}
          \OtherTok{]);}
\end{Highlighting}
\end{Shaded}

This references the \texttt{EntityType} class, so we need to add a
\texttt{use} statement for this class:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Bridge\textbackslash{}Doctrine\textbackslash{}Form\textbackslash{}Type\textbackslash{}EntityType}\OtherTok{;}
\end{Highlighting}
\end{Shaded}

So the full listing for our updated \texttt{ProductType} class is:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Form}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Entity\textbackslash{}Product}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Form\textbackslash{}AbstractType}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Form\textbackslash{}FormBuilderInterface}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}OptionsResolver\textbackslash{}OptionsResolver}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Bridge\textbackslash{}Doctrine\textbackslash{}Form\textbackslash{}Type\textbackslash{}EntityType}\OtherTok{;}
    
    
    \KeywordTok{class}\NormalTok{ ProductType }\KeywordTok{extends}\NormalTok{ AbstractType}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ buildForm}\OtherTok{(}\NormalTok{FormBuilderInterface }\KeywordTok{$builder}\OtherTok{,} \KeywordTok{array} \KeywordTok{$options}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$builder}
\NormalTok{                ->add}\OtherTok{(}\StringTok{'description'}\OtherTok{)}
\NormalTok{                ->add}\OtherTok{(}\StringTok{'image'}\OtherTok{)}
\NormalTok{                ->add}\OtherTok{(}\StringTok{'price'}\OtherTok{)}
\NormalTok{                ->add}\OtherTok{(}\StringTok{'category'}\OtherTok{,}\NormalTok{ EntityType::}\KeywordTok{class}\OtherTok{,} \OtherTok{[}
                    \CommentTok{// list objects from this class}
                    \StringTok{'class'}\NormalTok{ => }\StringTok{'App:Category'}\OtherTok{,}
    
                    \CommentTok{// use the 'Category.name' property as the visible option string}
                    \StringTok{'choice_label'}\NormalTok{ => }\StringTok{'name'}\OtherTok{,}
                \OtherTok{]);}        \OtherTok{;}
\NormalTok{        \}}
    
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ configureOptions}\OtherTok{(}\NormalTok{OptionsResolver }\KeywordTok{$resolver}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$resolver}\NormalTok{->setDefaults}\OtherTok{([}
                \StringTok{'data_class'}\NormalTok{ => Product::}\KeywordTok{class}\OtherTok{,}
            \OtherTok{]);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{add-small-and-large-item-category}{%
\section{Add small and large item
Category}\label{add-small-and-large-item-category}}

Let's create two categories:

\begin{itemize}
\item
  \texttt{small\ items}
\item
  \texttt{large\ items}
\end{itemize}

You could run the server and manually created these at CRUD page
\texttt{/category/new}. Alterntively you could create a
\texttt{CategoryFixtures} class to automatially add these to the
database:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}DataFixtures}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}Bundle\textbackslash{}FixturesBundle\textbackslash{}Fixture}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}Common\textbackslash{}Persistence\textbackslash{}ObjectManager}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Entity\textbackslash{}Category}\OtherTok{;}
    
    \KeywordTok{class}\NormalTok{ CategoryFixtures }\KeywordTok{extends}\NormalTok{ Fixture}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ load}\OtherTok{(}\NormalTok{ObjectManager }\KeywordTok{$manager}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$cat1}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Category}\OtherTok{();}
            \KeywordTok{$cat1}\NormalTok{->setName}\OtherTok{(}\StringTok{'small items'}\OtherTok{);}
    
            \KeywordTok{$cat2}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Category}\OtherTok{();}
            \KeywordTok{$cat2}\NormalTok{->setName}\OtherTok{(}\StringTok{'large items'}\OtherTok{);}
    
            \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$cat1}\OtherTok{);}
            \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$cat2}\OtherTok{);}
    
            \KeywordTok{$manager}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{drop-down-menu-of-categories-when-creatingediting-products}{%
\section{\texorpdfstring{Drop-down menu of categories when
creating/editing
\texttt{Product}s}{Drop-down menu of categories when creating/editing Products}}\label{drop-down-menu-of-categories-when-creatingediting-products}}

Now we are automatically given a drop-down list of \texttt{Category}
items to choose from when we visit \texttt{/product/new} to create a new
\texttt{Product} object. See Figure \ref{category_dropdown}.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/4ddf85c5125b25530a9a963f1fd98b09b5395541.png}
\caption{Screenshot of Category dropdown for new Product form.
\label{category_dropdown}}
\end{figure}

\hypertarget{adding-display-of-category-to-list-and-show-product}{%
\section{Adding display of Category to list and show
Product}\label{adding-display-of-category-to-list-and-show-product}}

Remember, with the Doctrine ORM (Object-Relational Mapper), if we have a
reference to a \texttt{Product} object, in PHP we can get its
\texttt{Category} as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$category}\NormalTok{ = }\KeywordTok{$product}\NormalTok{->getCategory}\OtherTok{();}

    \KeywordTok{if}\OtherTok{(}\KeywordTok{null}\NormalTok{ != }\KeywordTok{$category}\OtherTok{)}
        \CommentTok{// do something with $category}
\end{Highlighting}
\end{Shaded}

In Twig its even simpler, since the dot-syntax finds the public
\texttt{getter} automatically:

\begin{verbatim}
    Category = {{ product.category }}
\end{verbatim}

So we can update the Product list Twig template to show Category as
follows (\texttt{/templates/product/index.html.twig}):

\begin{verbatim}
    {% for product in products %}
        <tr>
            <td>{{ product.id }}</td>
            <td>{{ product.description }}</td>
            <td>{{ product.image }}</td>
            <td>{{ product.price }}</td>
            <td>{{ product.category.name }}</td>
            ...
\end{verbatim}

and add a new column header:

\begin{verbatim}
    <tr>
        <th>Id</th>
        <th>Description</th>
        <th>Image</th>
        <th>Price</th>
        <th>Category</th>
        <th>actions</th>
\end{verbatim}

And we can update the Product show Twig template to show Category as
follows (\texttt{/templates/product/show.html.twig}):

\begin{verbatim}
    <tr>
        <th>Id</th>
        <td>{{ product.id }}</td>
    </tr>
    <tr>
        <th>Description</th>
        <td>{{ product.description }}</td>
    </tr>
    <tr>
        <th>Image</th>
        <td>{{ product.image }}</td>
    </tr>
    <tr>
        <th>Price</th>
        <td>{{ product.price }}</td>
    </tr>

    <tr>
        <th>Cateogry</th>
        <td>{{ product.category.name }}</td>
    </tr>
\end{verbatim}

See Figure \ref{category_dropdown} to see Category for each Product in
the list.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/626240e41f67751ae615eb9716ffa2d9f783b847.png}
\caption{Screenshot of list of Products with their Category names.
\label{product_list_category}}
\end{figure}

\hypertarget{tostring-method}{%
\section{toString() method}\label{tostring-method}}

It is a good idea to have a default \texttt{\_\_toString()} method in
our \texttt{Category} Entity class, so we can write
\texttt{product.category}. So add the following method to Entity class
\texttt{src/Category.php}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function} \FunctionTok{__toString}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->name}\OtherTok{;}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Now change the \texttt{/templates/product/show.html.twig} template to
just output \texttt{product.category}:

\begin{verbatim}
    <tr>
        <th>Cateogry</th>
        <td>{{ product.category }}</td>
    </tr>
\end{verbatim}

\hypertarget{setup-relationship-via-make}{%
\section{\texorpdfstring{Setup relationship via
\texttt{make}}{Setup relationship via make}}\label{setup-relationship-via-make}}

The new improved command line \texttt{make} tool can actually do a lot
of the above work for us automatically, by defining a \texttt{category}
property when making Entity class \texttt{Product}, with a
\texttt{Field\ type} of \texttt{relation} (rather than string etc.).

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{...}\NormalTok{ (make entity Product)}
    
    \ExtensionTok{New}\NormalTok{ property name (press }\OperatorTok{<}\NormalTok{return}\OperatorTok{>}\NormalTok{ to stop adding fields)}\BuiltInTok{:}
    \OperatorTok{>} \ExtensionTok{category}
    
    \ExtensionTok{Field}\NormalTok{ type (enter ? to see all types) [}\ExtensionTok{string}\NormalTok{]:}
    \OperatorTok{>} \ExtensionTok{relation}
    
    \ExtensionTok{What}\NormalTok{ class should this entity be related to?:}
    \OperatorTok{>} \ExtensionTok{Category}
    
    \ExtensionTok{Relation}\NormalTok{ type? [ManyToOne, OneToMany, ManyToMany, OneToOne]:}
    \OperatorTok{>} \ExtensionTok{ManyToOne}
    
    \ExtensionTok{Is}\NormalTok{ the Product.category property allowed to be null (nullable)}\ExtensionTok{?}\NormalTok{ (yes/no) [}\ExtensionTok{yes}\NormalTok{]:}
    \OperatorTok{>} \ExtensionTok{no}
    
    \ExtensionTok{Do}\NormalTok{ you want to add a new property to Category so that you can access/update}
    \FunctionTok{getProducts()}\ExtensionTok{?}\NormalTok{ (yes/no) [}\ExtensionTok{yes}\NormalTok{]:}
    \OperatorTok{>} \FunctionTok{yes}
    
    \ExtensionTok{New}\NormalTok{ field name inside Category [products]:}
    \OperatorTok{>} \ExtensionTok{products}
    
    \ExtensionTok{Do}\NormalTok{ you want to automatically delete orphaned App\textbackslash{}Entity\textbackslash{}Product objects}
    \KeywordTok{(}\ExtensionTok{orphanRemoval}\KeywordTok{)}\ExtensionTok{?}\NormalTok{ (yes/no) [}\ExtensionTok{no}\NormalTok{]:}
    \OperatorTok{>} \ExtensionTok{no}
    
     \ExtensionTok{to}\NormalTok{ stop adding fields)}\BuiltInTok{:}
    \OperatorTok{>}
    \KeywordTok{(}\ExtensionTok{press}\NormalTok{ enter again to finish}\KeywordTok{)}
\end{Highlighting}
\end{Shaded}

Learn more in the Symfony documentation:

\begin{itemize}
\tightlist
\item
  \url{https://symfony.com/doc/current/doctrine/associations.html}
\end{itemize}

\hypertarget{many-to-one-e.g.-products-for-a-single-category}{%
\chapter{Many-to-one (e.g.~Products for a single
Category)}\label{many-to-one-e.g.-products-for-a-single-category}}

\hypertarget{basic-list-products-for-current-category-project-associations02}{%
\section{\texorpdfstring{Basic list products for current Category
(project
\texttt{associations02})}{Basic list products for current Category (project associations02)}}\label{basic-list-products-for-current-category-project-associations02}}

First we'll do the minimum to add a list of all the Projects associated
with a single Category, then later we'll do it in a nicer way \ldots{}

\hypertarget{add-getproducts-for-entity-category}{%
\section{\texorpdfstring{Add \texttt{getProducts()} for Entity
Category}{Add getProducts() for Entity Category}}\label{add-getproducts-for-entity-category}}

We need to add a getter for products in
\texttt{/src/Entity/Category.php} that returns a Doctrine
\texttt{Collection} of objects:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ getProducts}\OtherTok{()}\NormalTok{:Collection}
\NormalTok{    \{}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->products}\OtherTok{;}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

We need to add an appropite \texttt{use} statement for

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}Common\textbackslash{}Collections\textbackslash{}Collection}\OtherTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{add-a-__tostring-for-entity-products}{%
\section{\texorpdfstring{Add a \texttt{\_\_toString()} for Entity
Products}{Add a \_\_toString() for Entity Products}}\label{add-a-__tostring-for-entity-products}}

We need to add a `magic method' \texttt{\_\_toString()} to Entity
Product, since our form builder will need a string for each Product in
its list to display:

Add \texttt{\_\_toString()}to \texttt{/src/Entity/Product.php}. We'll
just list \texttt{id} and \texttt{description}:

\begin{verbatim}
public function __toString()
{
    return $this->id . ': ' . $this->getDescription();
}
\end{verbatim}

\hypertarget{make-category-form-type-add-products-property}{%
\section{\texorpdfstring{Make Category form type add \texttt{products}
property}{Make Category form type add products property}}\label{make-category-form-type-add-products-property}}

Earlier we added the special \texttt{products} property to entity
Category, which is the `many' link to all the Products for the current
Category object. We will now add this property to our Category form
class \texttt{CategoryType}, so that the form created will display all
Products found by automatically following that relationship\footnote{I.e.
  Doctrine will magically run something like `SELECT * FROM product
  WHERE product.category = category.id' for the current Category object.}.

In \texttt{/src/Form/CategoryType.php} add
\texttt{add(\textquotesingle{}products\textquotesingle{})} to our
\texttt{buildForm(\textasciigrave{}\textasciigrave{}\textasciigrave{})}
method:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ buildForm}\OtherTok{(}\NormalTok{FormBuilderInterface }\KeywordTok{$builder}\OtherTok{,} \KeywordTok{array} \KeywordTok{$options}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$builder}
\NormalTok{            ->add}\OtherTok{(}\StringTok{'name'}\OtherTok{)}
\NormalTok{            ->add}\OtherTok{(}\StringTok{'products'}\OtherTok{)}
        \OtherTok{;}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

If we visit the `edit' page for a Category now, we can see a read-only
multiple value list box displayed for \texttt{products}, with all
Products for the current Category selected.

While it doesn't look very nice, our inverse-relationship is all working
fine.

See Figure \ref{category_products}.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/64817d6401ff5203679c0f96b7a8dfe87177e70d.png}
\caption{Screenshot of products list for Category edit.
\label{category_products}}
\end{figure}

\hypertarget{adding-a-nicer-list-of-products-for-category-show-page}{%
\section{Adding a nicer list of Products for Category show
page}\label{adding-a-nicer-list-of-products-for-category-show-page}}

Let's add a \textbf{nice} list of Products for a Category on the
Category show page.

In the Twig \texttt{/src/templates/show.html.twig} we have a reference
to the \texttt{category} object. We can get an array of associated
\texttt{Product} objects by writing simply \texttt{category.products},
so we can loop through this:

\begin{verbatim}
    {% for product in category.products %}
        {{ product.id }} :: {{ product.description }}
        <br>
    {% else %}
        (no products for this category)
    {% endfor %}
\end{verbatim}

This will output some HTML like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    1 :: hammer}
    \KeywordTok{<br>}
\NormalTok{    3 :: bag of nails}
    \KeywordTok{<br>}
\end{Highlighting}
\end{Shaded}

So we can simply add a new HTML table row in our \texttt{show.html.twig}
template, listing Products as follows:

\begin{verbatim}
        <tr>
            <th>Id</th>
            <td>{{ category.id }}</td>
        </tr>
        <tr>
            <th>Name</th>
            <td>{{ category.name }}</td>
        </tr>

        <tr>
            <th>Products for this Category</th>
            <td>
                {% for product in category.products %}
                    {{ product.id }} :: {{ product.description }}
                    <br>
                {% else %}
                    (no products for this category)
                {% endfor %}
            </td>
        </tr>
\end{verbatim}

See Figure \ref{category_show_products}.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/da2e6880336b77fd05eaede35e23517d5465284b.png}
\caption{Screenshot of improved Category show page.
\label{category_show_products}}
\end{figure}

\hypertarget{improving-the-edit-form-project-associations03}{%
\section{\texorpdfstring{Improving the Edit form (project
\texttt{associations03})}{Improving the Edit form (project associations03)}}\label{improving-the-edit-form-project-associations03}}

That multi-selection form element was not very nice for our Edit/New
forms.

Let's refactor template \texttt{/templates/category/\_form.html.twig} to
display the list of products for a Category in a nicer way. This Twig
`partial' is use both for the \textbf{new} Category form and for the
\textbf{edit} category form.

Our Twig form did contain:

\begin{verbatim}
    {{ form_start(form) }}
        {{ form_widget(form) }}

        <button>{{ button_label|default('Save') }}</button>
    {{ form_end(form) }}
\end{verbatim}

Since we want to customise how form elements are displayed, we need to
replace \texttt{\{\{\ form\_widget(form)\ \}\}} with our own form
elements and HTML.

As explained in an earlier chapter on customising Symfony generated
forms, there are 3 parts to a Symfomny form output by
\texttt{\{\{\ form\_widget(form)\ \}\}}:

\begin{verbatim}
    {{ form_start(form) }}
    {{ form_widget(form) }}
    {{ form_end(form) }}
\end{verbatim}

We don't want the default form elements, then we can display them
separately with \texttt{form\_row}, e.g.~we have 2 properties for Entity
class \texttt{Category}, the name and the collection of related
products:

\begin{verbatim}
    {{ form_row(form.name) }}
    {{ form_row(form.products) }}
\end{verbatim}

We wish to keep the default rendering of the \texttt{name} property, so
the start of our customised form will be:

\begin{verbatim}
    {{ form_start(form) }}
    
    {{ form_row(form.name) }}
\end{verbatim}

Now we have to decide how to render the \texttt{products} array. Let's
do something very similar to our show form, and loop through creating
list items for each:

\begin{verbatim}
    <div>
        Products for this Category:
        <ul>
            {% for product in form.vars.value.products %}
                <li>
                    <a href="{{ url('product_show', {'id':product.id}) }}">
                        {{ product.id }} :: {{ product.description }}
                    </a>
                </li>
            {% else %}
                <li>
                    (no products for this category)
                </li>
            {% endfor %}
        </ul>
    </div>
\end{verbatim}

As you can see, we can access the array \texttt{products} of our
Category object with expression:

\begin{verbatim}
    form.vars.value.products
\end{verbatim}

So we can write a \texttt{for}-loop around this array.

Note - we still need to render the \texttt{products} form widget,
otherwise Symfony will end the form HTML with all properties not yet
rendered. So we can \textbf{hide} the default rendering for a selection
element by wrapping an HTML comment around the default HTML
\texttt{select} form element. We also need to display the button
\texttt{Save} button, since we are rendering the form in pieces:

\begin{verbatim}
        <button class="btn">{{ button_label|default('Save') }}</button>
    
    <!--
        {{ form_widget(form.products) }}
    -->
\end{verbatim}

We end with \texttt{\{\{\ form\_end(form)\ \}\}}, so the full listing
for our new/edit form template
\texttt{/templates/category/\_form.html.twig} is:

\begin{verbatim}
    {{ form_start(form) }}
    
    {{ form_row(form.name) }}
    
    <div>
        Products for this Category:
        <ul>
            {% for product in form.vars.value.products %}
                <li>
                    <a href="{{ url('product_show', {'id':product.id}) }}">
                        {{ product.id }} :: {{ product.description }}
                    </a>
                </li>
            {% else %}
                <li>
                    (no products for this category)
                </li>
            {% endfor %}
        </ul>
    </div>
    
        <button class="btn">{{ button_label|default('Save') }}</button>
    
    <!--
        {{ form_widget(form.products) }}
    -->
    
    {{ form_end(form) }}
\end{verbatim}

Figure \ref{category_edit_customised} shows a screenshot of our
customised Edit form.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/33cf51b02966fab507b0e4501f3db4f30e74b0b1.png}
\caption{Screenshot of customised edit form.
\label{category_edit_customised}}
\end{figure}

\hypertarget{creating-related-objects-as-fixtures-project-associations04}{%
\section{\texorpdfstring{Creating related objects as Fixtures (project
\texttt{associations04})}{Creating related objects as Fixtures (project associations04)}}\label{creating-related-objects-as-fixtures-project-associations04}}

A good way to get a feel for how the Doctrine ORM relates objects,
\textbf{not} object IDs, is through fixtures. So we can create a
\texttt{Category} object, and also create a \texttt{Product} object,
whose \texttt{category} property is a reference to the \texttt{Category}
object. E.g. here are 3 categories and one obnject (hammer) linked to
the small items category:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}DataFixtures}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}Bundle\textbackslash{}FixturesBundle\textbackslash{}Fixture}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}Common\textbackslash{}Persistence\textbackslash{}ObjectManager}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Entity\textbackslash{}Category}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Entity\textbackslash{}Product}\OtherTok{;}
    
    \KeywordTok{class}\NormalTok{ CategoryFixtures }\KeywordTok{extends}\NormalTok{ Fixture}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ load}\OtherTok{(}\NormalTok{ObjectManager }\KeywordTok{$manager}\OtherTok{)}
\NormalTok{        \{}
            \CommentTok{// ------ categories ------}
            \KeywordTok{$catDefault}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Category}\OtherTok{();}
            \KeywordTok{$catDefault}\NormalTok{->setName}\OtherTok{(}\StringTok{'(default)'}\OtherTok{);}
    
            \KeywordTok{$catSmall}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Category}\OtherTok{();}
            \KeywordTok{$catSmall}\NormalTok{->setName}\OtherTok{(}\StringTok{'small items'}\OtherTok{);}
    
            \KeywordTok{$catLarge}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Category}\OtherTok{();}
            \KeywordTok{$catLarge}\NormalTok{->setName}\OtherTok{(}\StringTok{'large items'}\OtherTok{);}
    
            \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$catDefault}\OtherTok{);}
            \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$catSmall}\OtherTok{);}
            \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$catLarge}\OtherTok{);}
            
            \CommentTok{// ------- product ----------}
            \KeywordTok{$p1}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Product}\OtherTok{();}
            \KeywordTok{$p1}\NormalTok{->setDescription}\OtherTok{(}\StringTok{'hammer'}\OtherTok{);}
            \KeywordTok{$p1}\NormalTok{->setPrice}\OtherTok{(}\FloatTok{9.99}\OtherTok{);}
            \KeywordTok{$p1}\NormalTok{->setImage}\OtherTok{(}\StringTok{'hammer.png'}\OtherTok{);}
            \KeywordTok{$p1}\NormalTok{->setCategory}\OtherTok{(}\KeywordTok{$catSmall}\OtherTok{);}
    
            \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$p1}\OtherTok{);}
    
            \KeywordTok{$manager}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{using-joins-in-custom-repository-classes}{%
\section{Using Joins in custom Repository
classes}\label{using-joins-in-custom-repository-classes}}

Where Doctrine really shows its worth is when we want to work with
tables joined by related properties.

Below a custom Repository method has been created that lists all houses,
whose related status object has the title `for sale':

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{class}\NormalTok{ HouseRepository }\KeywordTok{extends}\NormalTok{ ServiceEntityRepository}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function} \FunctionTok{__construct}\OtherTok{(}\NormalTok{RegistryInterface }\KeywordTok{$registry}\OtherTok{)}
\NormalTok{        \{}
\NormalTok{            parent::}\FunctionTok{__construct}\OtherTok{(}\KeywordTok{$registry}\OtherTok{,}\NormalTok{ House::}\KeywordTok{class}\OtherTok{);}
\NormalTok{        \}}

        \KeywordTok{public} \KeywordTok{function}\NormalTok{ findAllForSale}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->createQueryBuilder}\OtherTok{(}\StringTok{'house'}\OtherTok{)}
\NormalTok{                ->leftJoin}\OtherTok{(}\StringTok{'house.status'}\OtherTok{,} \StringTok{'status'}\OtherTok{)}

\NormalTok{                ->andWhere}\OtherTok{(}\StringTok{'status.title = :title'}\OtherTok{)}
\NormalTok{                ->setParameter}\OtherTok{(}\StringTok{'title'}\OtherTok{,} \StringTok{'for sale'}\OtherTok{)}
\NormalTok{                ->getQuery}\OtherTok{()}
\NormalTok{            ->execute}\OtherTok{();}

\NormalTok{        \}}

\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

By putting complex queries into custom methods in the Repository class,
the code in our controllers stays very simple, e.g.~below we see an
array of all houses `for sale' is being passed to the default home page
controller method, to list on the website home page:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{class}\NormalTok{ DefaultController }\KeywordTok{extends}\NormalTok{ Controller}
\NormalTok{    \{}
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/",}\CommentTok{ name="home_page")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{(}\NormalTok{HouseRepository }\KeywordTok{$houseRepository}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$houses}\NormalTok{ = }\KeywordTok{$houseRepository}\NormalTok{->findAllForSale}\OtherTok{();}

            \KeywordTok{$template}\NormalTok{ = }\StringTok{'default/index.html.twig'}\OtherTok{;}
            \KeywordTok{$args}\NormalTok{ = }\OtherTok{[}
            \StringTok{'houses'}\NormalTok{ => }\KeywordTok{$houses}
            \OtherTok{];}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{        \}}

\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Once again, we see the power of the Symfony paramconvertor, in that to
get a reference to a HouseRepository object, we just add a method
parameter \texttt{HouseRepository\ \$houseRepository}, and as if by
magic, we can just start using the repository object!

\hypertarget{logged-in-user-stored-as-item-author}{%
\chapter{Logged-in user stored as item
author}\label{logged-in-user-stored-as-item-author}}

\hypertarget{getting-user-object-for-currently-logged-in-user}{%
\section{Getting User object for currently logged-in
user}\label{getting-user-object-for-currently-logged-in-user}}

The Symfony security docs tell us how to get are reference to the
currently logged-in user:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$user}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getUser}\OtherTok{();}
\end{Highlighting}
\end{Shaded}

or using the hinting and the param-converter:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Security\textbackslash{}Core\textbackslash{}Security}\OtherTok{;}
    
    \StringTok{...}
    
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ someMethod}\OtherTok{(}\NormalTok{Security }\KeywordTok{$security}\OtherTok{)} 
\NormalTok{    \{}
        \KeywordTok{$user}\NormalTok{ = }\KeywordTok{$security}\NormalTok{->getUser}\OtherTok{();} 
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Any non-trivial project involving databases involves one-to-many and
many-to-many relationships. the Doctrine ORM system makes it very easy
to declare, and manipulate datasets with foreign-key relationships.

Some useful information sources on this topic include:

\begin{itemize}
\item
  \href{http://symfony.com/doc/current/doctrine/associations.html}{How
  to Work with Doctrine Relations}
\item
  \href{http://symfony.com/doc/current/reference/forms/types/entity.html}{Forms
  EntityType Field}
\end{itemize}

\hypertarget{simple-example-users-and-their-county-associations05}{%
\section{\texorpdfstring{Simple example: Users and their county
(\texttt{associations05})}{Simple example: Users and their county (associations05)}}\label{simple-example-users-and-their-county-associations05}}

First, create, or duplicate a basic user-authenticated secure Symfony
website, e.g.~project 9 with Twig:

\begin{itemize}
\tightlist
\item
  \url{https://github.com/dr-matt-smith/php-symfony4-book-codes-security-09-twig-security}
\end{itemize}

Next, create a \texttt{NewsItem} entity, with fields:

\begin{itemize}
\item
  title
\item
  content
\item
  author (which is a relationship associates to the \texttt{User}
  Entity)
\end{itemize}

Use the \texttt{make} interactive CLI tool for this. Create the Entity
with text \texttt{title} and \texttt{content} properties as usual:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console make:entity NewsItem}
    
     \ExtensionTok{created}\NormalTok{: src/Entity/NewsItem.php}
     \ExtensionTok{created}\NormalTok{: src/Repository/NewsItemRepository.php}
     
     \ExtensionTok{Entity}\NormalTok{ generated! Now let}\StringTok{'s add some fields!}
\StringTok{     You can always add more fields later manually or by re-running this command.}
\StringTok{    }
\StringTok{     New property name (press <return> to stop adding fields):}
\StringTok{     > title}
\StringTok{    }
\StringTok{     Field type (enter ? to see all types) [string]:}
\StringTok{     > }
\StringTok{    }
\StringTok{     Field length [255]:}
\StringTok{     > }
\StringTok{    }
\StringTok{     Can this field be null in the database (nullable) (yes/no) [no]:}
\StringTok{     > }
\StringTok{    }
\StringTok{     updated: src/Entity/NewsItem.php}
\StringTok{    }
\StringTok{     Add another property? Enter the property name (or press <return> to stop adding fields):}
\StringTok{     > content}

\StringTok{    ... etc.}
\end{Highlighting}
\end{Shaded}

Then add a property \texttt{author} linked as a \texttt{relation} Field
Type to Entity \texttt{User} via a many-to-one relationship:

\begin{Shaded}
\begin{Highlighting}[]
     \ExtensionTok{Add}\NormalTok{ another property? Enter the property name (or press }\OperatorTok{<}\NormalTok{return}\OperatorTok{>}\NormalTok{ to stop adding fields)}\BuiltInTok{:}
     \OperatorTok{>} \ExtensionTok{author}
    
     \ExtensionTok{Field}\NormalTok{ type (enter ? to see all types) [}\ExtensionTok{string}\NormalTok{]:}
     \OperatorTok{>} \ExtensionTok{relation}
    
     \ExtensionTok{What}\NormalTok{ class should this entity be related to?:}
     \OperatorTok{>} \ExtensionTok{User}
    
    \ExtensionTok{What}\NormalTok{ type of relationship is this?}
     \ExtensionTok{------------}\NormalTok{ -------------------------------------------------------------------- }
      \ExtensionTok{Type}\NormalTok{         Description                                                         }
     \ExtensionTok{------------}\NormalTok{ -------------------------------------------------------------------- }
      \ExtensionTok{ManyToOne}\NormalTok{    Each NewsItem relates to (has) }\ExtensionTok{one}\NormalTok{ User.                            }
                   \ExtensionTok{Each}\NormalTok{ User can relate to (can have) }\ExtensionTok{many}\NormalTok{ NewsItem objects            }
                                                                                       
      \ExtensionTok{OneToMany}\NormalTok{    Each NewsItem can relate to (can have) }\ExtensionTok{many}\NormalTok{ User objects.           }
                   \ExtensionTok{Each}\NormalTok{ User relates to (has) }\ExtensionTok{one}\NormalTok{ NewsItem                             }
                                                                                       
      \ExtensionTok{ManyToMany}\NormalTok{   Each NewsItem can relate to (can have) }\ExtensionTok{many}\NormalTok{ User objects.           }
                   \ExtensionTok{Each}\NormalTok{ User can also relate to (can also have) }\ExtensionTok{many}\NormalTok{ NewsItem objects  }
                                                                                       
      \ExtensionTok{OneToOne}\NormalTok{     Each NewsItem relates to (has) }\ExtensionTok{exactly}\NormalTok{ one User.                    }
                   \ExtensionTok{Each}\NormalTok{ User also relates to (has) }\ExtensionTok{exactly}\NormalTok{ one NewsItem.               }
     \ExtensionTok{------------}\NormalTok{ -------------------------------------------------------------------- }
    
     \ExtensionTok{Relation}\NormalTok{ type? [ManyToOne, OneToMany, ManyToMany, OneToOne]:}
     \OperatorTok{>} \ExtensionTok{ManyToOne}
    
     \ExtensionTok{Is}\NormalTok{ the NewsItem.author property allowed to be null (nullable)}\ExtensionTok{?}\NormalTok{ (yes/no) [}\ExtensionTok{yes}\NormalTok{]:}
     \OperatorTok{>} \FunctionTok{yes}
    
     \ExtensionTok{Do}\NormalTok{ you want to add a new property to User so that you can access/update NewsItem objects from it - e.g. }\VariableTok{$user}\NormalTok{-}\OperatorTok{>}\NormalTok{getNewsItems()}\ExtensionTok{?}\NormalTok{ (yes/no) [}\ExtensionTok{yes}\NormalTok{]:}
     \OperatorTok{>} \FunctionTok{yes}
    
     \ExtensionTok{A}\NormalTok{ new property will also be added to the User class so that you can access the related NewsItem objects from it.}
    
     \ExtensionTok{New}\NormalTok{ field name inside User [newsItems]:}
     \OperatorTok{>} 
    
     \ExtensionTok{updated}\NormalTok{: src/Entity/NewsItem.php}
     \ExtensionTok{updated}\NormalTok{: src/Entity/User.php}
\end{Highlighting}
\end{Shaded}

Now:

\begin{itemize}
\item
  migrate your new Entity to the database
\item
  generate CRUD for Entity \texttt{NewsItem}
\end{itemize}

\hypertarget{add-tostring-method-to-user}{%
\section{\texorpdfstring{Add toString method to
\texttt{User}}{Add toString method to User}}\label{add-tostring-method-to-user}}

Since our CRUD will wish to list \texttt{User} records to associate with
a new NewsItem, it will expect a \texttt{User} object to have a
\texttt{\_\_toString()} method, for how these users should be shown to
the person creating the new \texttt{NewsItem}. So add the following
\texttt{\_\_toString()} method to Entity class \texttt{User}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function} \FunctionTok{__toString}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{return} \DataTypeTok{(string)}\KeywordTok{$this}\NormalTok{->username}\OtherTok{;}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Test the system, run the webserver and visit the \texttt{/news/item}
pages to test your CRUD.

\hypertarget{use-currently-logged-in-user-as-author}{%
\section{Use currently logged-in user as
author}\label{use-currently-logged-in-user-as-author}}

Let's automatically use the currently logged-in user as the author for a
\texttt{NewsItem}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$user}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getUser}\OtherTok{();}
\end{Highlighting}
\end{Shaded}

So we need to edit the CRUD code for the \texttt{new()} method in
\texttt{src/Controller/NewsItemConbtroller.php} to set the author to the
currently logged-in user:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function} \KeywordTok{new}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}\NormalTok{: Response}
\NormalTok{    \{}
        \KeywordTok{$user}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getUser}\OtherTok{();}

        \KeywordTok{$newsItem}\NormalTok{ = }\KeywordTok{new}\NormalTok{ NewsItem}\OtherTok{();}
        \KeywordTok{$newsItem}\NormalTok{->setAuthor}\OtherTok{(}\KeywordTok{$user}\OtherTok{);}    
\end{Highlighting}
\end{Shaded}

SO the full listing for method \texttt{new()} is now:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/new",}\CommentTok{ name="news_item_new", methods=\{"GET","POST"\})}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function} \KeywordTok{new}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}\NormalTok{: Response}
\NormalTok{    \{}
        \KeywordTok{$user}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getUser}\OtherTok{();}

        \KeywordTok{$newsItem}\NormalTok{ = }\KeywordTok{new}\NormalTok{ NewsItem}\OtherTok{();}
        \KeywordTok{$newsItem}\NormalTok{->setAuthor}\OtherTok{(}\KeywordTok{$user}\OtherTok{);}

        \KeywordTok{$form}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->createForm}\OtherTok{(}\NormalTok{NewsItemType::}\KeywordTok{class}\OtherTok{,} \KeywordTok{$newsItem}\OtherTok{);}
        \KeywordTok{$form}\NormalTok{->handleRequest}\OtherTok{(}\KeywordTok{$request}\OtherTok{);}

        \KeywordTok{if} \OtherTok{(}\KeywordTok{$form}\NormalTok{->isSubmitted}\OtherTok{()}\NormalTok{ && }\KeywordTok{$form}\NormalTok{->isValid}\OtherTok{())}\NormalTok{ \{}
            \KeywordTok{$entityManager}\NormalTok{ = }\KeywordTok{$this}\NormalTok{->getDoctrine}\OtherTok{()}\NormalTok{->getManager}\OtherTok{();}
            \KeywordTok{$entityManager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$newsItem}\OtherTok{);}
            \KeywordTok{$entityManager}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}

            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->redirectToRoute}\OtherTok{(}\StringTok{'news_item_index'}\OtherTok{);}
\NormalTok{        \}}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\StringTok{'news_item/new.html.twig'}\OtherTok{,} \OtherTok{[}
            \StringTok{'news_item'}\NormalTok{ => }\KeywordTok{$newsItem}\OtherTok{,}
            \StringTok{'form'}\NormalTok{ => }\KeywordTok{$form}\NormalTok{->createView}\OtherTok{(),}
        \OtherTok{]);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

When you visit the CRUD for for a new \texttt{NewsItem} you'll see the
author is automatically populated with teh currently logged in user.

As an exercise, try to make this a read-only attribute, so that the
author cannot be changed to a different user \ldots{}

\hypertarget{protect-crud-so-must-be-logged-in}{%
\section{Protect CRUD so must be logged
in}\label{protect-crud-so-must-be-logged-in}}

We'll get an error at present, if we create a \texttt{NewsItem} record
when no logged in. So we need to secure the CRUD controller, requiring a
user to be logged in to be allowed to create a new item.

By adding the \texttt{@IsGranted} annotation before the class
declaration, this security requirement is enforced for \textbf{all}
routes in this controller:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Controller}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Entity\textbackslash{}NewsItem}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Form\textbackslash{}NewsItemType}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Repository\textbackslash{}NewsItemRepository}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Bundle\textbackslash{}FrameworkBundle\textbackslash{}Controller\textbackslash{}AbstractController}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Request}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Response}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Routing\textbackslash{}Annotation\textbackslash{}Route}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Sensio\textbackslash{}Bundle\textbackslash{}FrameworkExtraBundle\textbackslash{}Configuration\textbackslash{}IsGranted}\OtherTok{;}
    
    
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/news/item")}
\CommentTok{     * }\AnnotationTok{@IsGranted("ROLE_ADMIN")}
\CommentTok{     */}
    \KeywordTok{class}\NormalTok{ NewsItemController }\KeywordTok{extends}\NormalTok{ AbstractController}
\NormalTok{    \{}
            \StringTok{...} \KeywordTok{as}\NormalTok{ before}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\part{PHPDocumentor (2)}

\hypertarget{phpdocumentor}{%
\chapter{PHPDocumentor}\label{phpdocumentor}}

\hypertarget{why-document-code}{%
\section{Why document code?}\label{why-document-code}}

Other people will use your code. And you'll forget things after a few
weeks / months / years\ldots{} So we should create documents describing
our code.

There are several good reasons to document your code:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  It makes you \textbf{think} about the code

  You might even improve the code having thought about it
\item
  Writing about code \textbf{before} writing the code may lead to better
  code design
\item
  It makes you remember \textbf{your} code may be used / read by other
  people
\item
  It means you don't have to \textbf{remember} what things do or why
\item
  Automated tools can help check for missing documentation
\item
  It's a handy way to scan your code for TODO comments .
\end{enumerate}

\hypertarget{self-documenting-code}{%
\section{Self-documenting code}\label{self-documenting-code}}

Perhaps the simplest way to document code is to insert special comments
in the code itself - so the source code files are used to generate the
documentation pages about themselves.

`Docblocks' are special comments that \textbf{precede} the element they
describe - they are used by most automated documentation tools.

The PHPDocumentor 2 is a tool to generate HTML documentation pages from
these comments

\begin{itemize}
\tightlist
\item
  and if you use an IDE like PHPStorm to speed up writing these special
  comments\ldots{}
\end{itemize}

There are also other PHP code documentation systems out there, incuding:

\begin{itemize}
\item
  the \href{https://github.com/FriendsOfPHP/sami}{Sami} Friends of PHP
  documentation systems
\item
  \href{https://github.com/ApiGen/ApiGen}{Api Gen}
\item
  and of course \href{http://www.stack.nl/~dimitri/doxygen/}{Doxygen}
\end{itemize}

\hypertarget{phpdocumentor-2}{%
\section{PHPDocumentor 2}\label{phpdocumentor-2}}

There are several automated tools for supporting PHP code documentation,
one of the most popular is PHPDocumentor 2, which is the one described
in this chapter.

Learn more about PHPDocumentor 2 at their website:

\begin{itemize}
\tightlist
\item
  \href{https://www.phpdoc.org/}{phpdoc.org}
\end{itemize}

\hypertarget{installing-phpdocumentor-2---the-phar}{%
\section{Installing PHPDocumentor 2 - the
PHAR}\label{installing-phpdocumentor-2---the-phar}}

THe Composer install is a bit big, so it is recommended to just add the
PHAR (PHP Archive) either to your project, or globally (somewhere in
your system path).

Download the PHAR from their website and either copy into your Symfony
project folder, or to some standard folder that is in your CLI execution
path.

\begin{itemize}
\tightlist
\item
  \href{https://www.phpdoc.org/phpDocumentor.phar}{phpdoc.org/phpDocumentor.phar}
\end{itemize}

\hypertarget{installing-phpdocumentor-2---via-composer}{%
\section{Installing PHPDocumentor 2 - via
Composer}\label{installing-phpdocumentor-2---via-composer}}

Install via Composer with the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ req --dev phpdocumentor/phpdocumentor}
\end{Highlighting}
\end{Shaded}

\hypertarget{docblock-comments}{%
\section{DocBlock comments}\label{docblock-comments}}

The PHPDocumentor is driven by analysing `DocBlock' comments in your
code. A DocBlock comment looks as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * This is a DocBlock.}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ indexController}\OtherTok{()}
\NormalTok{    \{}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

They are multi-line comments that start with a double asterisk
\texttt{/**}.

\hypertarget{generating-the-documentation}{%
\section{Generating the
documentation}\label{generating-the-documentation}}

The PHPDocumentor needs to know at least 2 things:

\begin{itemize}
\item
  where is the PHP source code containing the documentation comments
\item
  where do you want the documentation files to be output
\end{itemize}

These are specified using the \texttt{-d} (PHP source directory), and
\texttt{-t} (output director) as follows.

So, for example, so analyse \textbf{all} files in directory
\texttt{/src} and output to \texttt{/docs} write:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ phpdoc -d src -t docs}
\end{Highlighting}
\end{Shaded}

To limit the code analysed to just \texttt{/src/Controller},
\texttt{/src/Util} and \texttt{/src/Entity} we would give 3 \texttt{-d}
arguemnts as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{php}\NormalTok{ phpdoc.phar -d src/Controller -d src/Entity -d src/Util -t docs}
\end{Highlighting}
\end{Shaded}

\hypertarget{using-an-xml-configuration-file-phpdoc.dist.xml}{%
\section{\texorpdfstring{Using an XML configuration file
\texttt{phpdoc.dist.xml}}{Using an XML configuration file phpdoc.dist.xml}}\label{using-an-xml-configuration-file-phpdoc.dist.xml}}

The simplest way to record your PHPDocumentor configuration options is
with an XML file \texttt{phpdoc.dist.xml}.

Here is a simple config file:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{<phpdoc>}
        \KeywordTok{<parser>}
            \KeywordTok{<target>}\NormalTok{./docs}\KeywordTok{</target>}
        \KeywordTok{</parser>}
        \KeywordTok{<transformer>}
            \KeywordTok{<target>}\NormalTok{./docs}\KeywordTok{</target>}
        \KeywordTok{</transformer>}
        \KeywordTok{<files>}
            \KeywordTok{<directory>}\NormalTok{./src}\KeywordTok{</directory>}
        \KeywordTok{</files>}
        \KeywordTok{<transformations>}
            \KeywordTok{<template}\OtherTok{ name=}\StringTok{"responsive-twig"}\KeywordTok{/>}
        \KeywordTok{</transformations>}
    \KeywordTok{</phpdoc>}
\end{Highlighting}
\end{Shaded}

This will output the HTML documentation pages in the
\texttt{responsive-twig} theme, into directory \texttt{./docs}, for all
PHP classes found in \texttt{./src}.

To limit the code analysed to just \texttt{/src/Controller},
\texttt{/src/Util} and \texttt{/src/Entity} we could use the following
XML file:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{<phpdoc>}
        \KeywordTok{<parser>}
            \KeywordTok{<target>}\NormalTok{./docs}\KeywordTok{</target>}
        \KeywordTok{</parser>}
        \KeywordTok{<transformer>}
            \KeywordTok{<target>}\NormalTok{./docs}\KeywordTok{</target>}
        \KeywordTok{</transformer>}
        \KeywordTok{<files>}
            \KeywordTok{<directory>}\NormalTok{./src/Controller}\KeywordTok{</directory>}
            \KeywordTok{<directory>}\NormalTok{./src/Util}\KeywordTok{</directory>}
            \KeywordTok{<directory>}\NormalTok{./src/Entity}\KeywordTok{</directory>}
        \KeywordTok{</files>}
        \KeywordTok{<transformations>}
            \KeywordTok{<template}\OtherTok{ name=}\StringTok{"responsive-twig"}\KeywordTok{/>}
        \KeywordTok{</transformations>}
    \KeywordTok{</phpdoc>}
\end{Highlighting}
\end{Shaded}

NOTE: If there is also a file \texttt{phpdoc.xml}, any settings in this
will overrided those in \texttt{phpdoc.dist.xml}. So, for example, an
individual might have some particular settings they prefer defined in
their \texttt{phpdoc.xml} file, but then could use the team's or
organisation's default \texttt{phpdoc.dist.xml} for all other
settings\ldots{}

\hypertarget{warning---phpstorm-default-comments}{%
\section{WARNING - PHPStorm default
comments}\label{warning---phpstorm-default-comments}}

Note that the default comments for a new PHP class provided by PHPStorm
will foul-up your documentatin generation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php}
    \CommentTok{/**}
\CommentTok{     * Created by PhpStorm.}
\CommentTok{     * User: matt}
\CommentTok{     * Date: 20/03/2018}
\CommentTok{     * Time: 07:42}
\CommentTok{     */}
\end{Highlighting}
\end{Shaded}

So delete these default file header comments if you are using the
PHPDocumentor.

\hypertarget{todo---special-treatment}{%
\section{TODO - special treatment}\label{todo---special-treatment}}

PHPDocumentor can hoover up special markers, such as \texttt{TODO}, and
report them for you. In fact \texttt{TODO} are so handy they get special
treatment.

You can mark todo's with with:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    * }\KeywordTok{TODO}\NormalTok{: fix that bug }\KeywordTok{for}\NormalTok{ stack overflow}
\end{Highlighting}
\end{Shaded}

or with the \texttt{@todo} annotation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    * }\ErrorTok{@}\NormalTok{todo fix that bug }\KeywordTok{for}\NormalTok{ stack overflow}
\end{Highlighting}
\end{Shaded}

\part{Symfony Testing with Codeception}

\hypertarget{unit-testing-in-symfony-with-codeception}{%
\chapter{Unit testing in Symfony with
Codeception}\label{unit-testing-in-symfony-with-codeception}}

\hypertarget{codeception-open-source-bdd-project}{%
\section{Codeception Open Source BDD
project}\label{codeception-open-source-bdd-project}}

Codeception is a BDD (Behaviour Driver Design) open source project, to
support acceptance (end-to-end, and unit testing for PHP project. The
community supports its close integration with Symfony:

\begin{itemize}
\item
  Github

  \begin{itemize}
  \tightlist
  \item
    \url{https://github.com/codeception/codeception}
  \end{itemize}
\item
  Project home page

  \begin{itemize}
  \tightlist
  \item
    \url{https://codeception.com/}
  \end{itemize}
\item
  Codeception Symfony docs

  \begin{itemize}
  \tightlist
  \item
    \url{https://codeception.com/docs/modules/Symfony}
  \end{itemize}
\end{itemize}

\hypertarget{adding-codeception-to-an-existing-project-project-codeception01}{%
\section{\texorpdfstring{Adding Codeception to an existing project
(project
\texttt{codeception01})}{Adding Codeception to an existing project (project codeception01)}}\label{adding-codeception-to-an-existing-project-project-codeception01}}

For these examples we'll start with an existing project;

\begin{itemize}
\item
  form queries 3

  \begin{itemize}
  \tightlist
  \item
    \url{https://github.com/dr-matt-smith/php-symfony-5-book-codes-security-08-twig-login-nav-links}
  \end{itemize}
\end{itemize}

So do the following:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  open the Symfony project you are going to add testing to

  \begin{itemize}
  \tightlist
  \item
    if it's an older project, then it's always a good idea to run
    \texttt{composer\ update} to ensure your project has the most
    up-to-date libraries in the \texttt{/vendor} folder
  \end{itemize}
\item
  since we are now in a \textbf{TESTING} mode, immediately change the
  \texttt{.env} file adding the suffix \texttt{test} to the database
  name - we don't test on a project's \textbf{production} database !

\begin{verbatim}
    DB_USER=root
    DB_PASSWORD=passpass
    DB_HOST=127.0.0.1
    DB_PORT=3306
    DB_NAME=security5test
    DATABASE_URL=mysql://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}
\end{verbatim}

  \begin{itemize}
  \item
    delete any existing \texttt{/src/Migrations} folder
  \item
    then create the new database with \texttt{doctrine:database:create},
    and make and run a migrationb, and run your fixtures
  \item
    run the webserver, and you should have the project you are about to
    test up and running \ldots{}
  \end{itemize}
\item
  Add Codeception via composer

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ req codeception/codeception --dev}

    \ExtensionTok{Using}\NormalTok{ version ^4.4 for codeception/codeception}
    \ExtensionTok{./composer.json}\NormalTok{ has been updated}
    \ExtensionTok{Loading}\NormalTok{ composer repositories with package information}
    \ExtensionTok{Updating}\NormalTok{ dependencies (including require-dev)}
    \ExtensionTok{Package}\NormalTok{ operations: 118 installs, 0 updates, 0 removals}

      \ExtensionTok{-}\NormalTok{ Installing .... packages ...}

    \ExtensionTok{Writing}\NormalTok{ lock file}
    \ExtensionTok{Generating}\NormalTok{ autoload files}
    \ExtensionTok{Symfony}\NormalTok{ operations: 2 recipes (d7cfe8af216b9f6fdaf106b4fa7854e0)}
      \ExtensionTok{-}\NormalTok{ Configuring phpunit/phpunit (}\OperatorTok{>}\NormalTok{=4.7)}\BuiltInTok{:}\NormalTok{ From github.com/symfony/recipes:master          }
\end{Highlighting}
\end{Shaded}

  \begin{itemize}
  \item
    you'll get a \textbf{WARNING} that you are not installing an
    `official' Symfony package, but one contributed by the open source
    community:

\begin{Shaded}
\begin{Highlighting}[]

  \ExtensionTok{Symfony}\NormalTok{ operations: 2 recipes (2b0042df2af2afd11fad98fcd4c2368b)}
    \ExtensionTok{-}\NormalTok{ Configuring phpunit/phpunit (}\OperatorTok{>}\NormalTok{=4.7)}\BuiltInTok{:}\NormalTok{ From github.com/symfony/recipes:master}
    \ExtensionTok{-}\NormalTok{  WARNING  codeception/codeception (}\OperatorTok{>}\NormalTok{=2.3)}\BuiltInTok{:}\NormalTok{ From github.com/symfony/recipes-contrib:master}
      \ExtensionTok{The}\NormalTok{ recipe for this package comes from the }\StringTok{"contrib"}\NormalTok{ repository, which is open to community contributions.}
      \ExtensionTok{Review}\NormalTok{ the recipe at https://github.com/symfony/recipes-contrib/tree/master/codeception/codeception/2.3}

      \ExtensionTok{Do}\NormalTok{ you want to execute this recipe?}
\NormalTok{      [}\ExtensionTok{y}\NormalTok{] Yes}
\NormalTok{      [}\ExtensionTok{n}\NormalTok{] No}
\NormalTok{      [}\ExtensionTok{a}\NormalTok{] Yes for all packages, only for the current installation session}
\NormalTok{      [}\ExtensionTok{p}\NormalTok{] Yes permanently, never ask again for this project}
      \KeywordTok{(}\ExtensionTok{defaults}\NormalTok{ to n}\KeywordTok{)}\BuiltInTok{:}\NormalTok{ y}
\end{Highlighting}
\end{Shaded}
  \end{itemize}
\item
  answer `y' (YES!):

\begin{Shaded}
\begin{Highlighting}[]
      \ExtensionTok{-}\NormalTok{ Configuring codeception/codeception (}\OperatorTok{>}\NormalTok{=4.1)}\BuiltInTok{:}\NormalTok{ From github.com/symfony/recipes-contrib:master}
    \ExtensionTok{ocramius}\NormalTok{/package-versions:  }\ExtensionTok{Generating}\NormalTok{ version class...}
    \ExtensionTok{ocramius}\NormalTok{/package-versions: }\ExtensionTok{...done}\NormalTok{ generating version class}
    \ExtensionTok{Executing}\NormalTok{ script cache:clear [OK]}
    \ExtensionTok{Executing}\NormalTok{ script assets:install public [OK]}

    \ExtensionTok{Some}\NormalTok{ files may have been created or updated to configure your new packages.}
    \ExtensionTok{Please}\NormalTok{ review, edit and commit them: these files are yours.}


     \ExtensionTok{Adding}\NormalTok{ phpunit/phpunit as a dependency is discouraged in favor of Symfony}\StringTok{'s PHPUnit Bridge. }


\StringTok{      * Instead:}
\StringTok{        1. Remove it now: composer remove --dev phpunit/phpunit}
\StringTok{        2. Use Symfony'}\NormalTok{s bridge: composer require --dev phpunit}
\end{Highlighting}
\end{Shaded}

  \begin{itemize}
  \item
    we see the `bootstrapping' process for Codeception, so you don't
    need to bootstrap it yourself (which may be required if using
    Codeception for a non-Symfony project):

\begin{Shaded}
\begin{Highlighting}[]
     \ExtensionTok{Bootstrapping}\NormalTok{ Codeception }
    \ExtensionTok{File}\NormalTok{ codeception.yaml created       }\OperatorTok{<}\NormalTok{- global configuration}
    \ExtensionTok{tests/unit}\NormalTok{ created                  }\OperatorTok{<}\NormalTok{- unit tests}
    \ExtensionTok{tests/unit.suite.yaml}\NormalTok{ written       }\OperatorTok{<}\NormalTok{- unit tests suite configuration}
    \ExtensionTok{tests/functional}\NormalTok{ created            }\OperatorTok{<}\NormalTok{- functional tests}
    \ExtensionTok{tests/functional.suite.yaml}\NormalTok{ written }\OperatorTok{<}\NormalTok{- functional tests suite configuration}
    \ExtensionTok{tests/acceptance}\NormalTok{ created            }\OperatorTok{<}\NormalTok{- acceptance tests}
    \ExtensionTok{tests/acceptance.suite.yaml}\NormalTok{ written }\OperatorTok{<}\NormalTok{- acceptance tests suite configuration}
    \ExtensionTok{Codeception}\NormalTok{ is installed for acceptance, functional, and unit testing}
    \ExtensionTok{Next}\NormalTok{ steps:}
    \ExtensionTok{1.}\NormalTok{ Edit tests/acceptance.suite.yaml to set url of your application. Change PhpBrowser to WebDriver to enable browser testing}
    \ExtensionTok{2.}\NormalTok{ Edit tests/functional.suite.yaml to enable a Doctrine module if needs.}
    \ExtensionTok{3.}\NormalTok{ Create your first acceptance tests using vendor/bin/codecept g:cest acceptance First}
    \ExtensionTok{4.}\NormalTok{ Write first test in tests/acceptance/FirstCest.php}
    \ExtensionTok{5.}\NormalTok{ Run tests using: vendor/bin/codecept run}
\end{Highlighting}
\end{Shaded}
  \end{itemize}
\item
  Notice the message from Symfony about \texttt{phpunit/phpunit} bneing
  \textbf{discouraged}, saying we should use the Symfony PHPUnit
  \textbf{Bridge}:

\begin{Shaded}
\begin{Highlighting}[]
     \ExtensionTok{Adding}\NormalTok{ phpunit/phpunit as a dependency is discouraged in favor of Symfony}\StringTok{'s PHPUnit Bridge. }

\StringTok{      * Instead:}
\StringTok{        1. Remove it now: composer remove --dev phpunit/phpunit}
\StringTok{        2. Use Symfony'}\NormalTok{s bridge: composer require --dev phpunit    }
\end{Highlighting}
\end{Shaded}

  \begin{itemize}
  \item
    it's always a good idea to do what is recommended, so first run the
    \texttt{composer\ remove\ ...} command:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ remove --dev phpunit/phpunit}

    \ExtensionTok{Nothing}\NormalTok{ to install or update}
\end{Highlighting}
\end{Shaded}
  \item
    then run the \texttt{composer\ require\ ...} command to add the
    Symfony bridge:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ require --dev phpunit  }

    \ExtensionTok{Nothing}\NormalTok{ to install or update}

    \ExtensionTok{...}
\end{Highlighting}
\end{Shaded}
  \item
    however, it looks like PHPUnit wasn't installed as part of
    Codeception (it used to be), so this seems to be an out of date
    warning, still we did what was recommended ..
  \end{itemize}
\end{enumerate}

\hypertarget{installing-the-required-modules}{%
\section{Installing the required
modules}\label{installing-the-required-modules}}

If you test your setup by running Codeception now with
\texttt{/vendor/bin/codecept\ run}, you'll get some error messages about
missing modules. So let's avoid that by adding those modules before
trying to run Codeception.

We need 3 extra Codeception modules to use Codeception with Symfony:

\begin{itemize}
\item
  asserts:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{composer}\NormalTok{ req --dev codeception/module-asserts }
\end{Highlighting}
\end{Shaded}
\item
  phpbrowser

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{composer}\NormalTok{ req --dev codeception/module-phpbrowser}
\end{Highlighting}
\end{Shaded}
\item
  Symfony

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{composer}\NormalTok{ req --dev codeception/module-symfony}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\hypertarget{what-codeception-has-added-to-our-project}{%
\section{What Codeception has added to our
project}\label{what-codeception-has-added-to-our-project}}

You should now have added to your project the following:

\begin{itemize}
\item
  file \texttt{codeception.yaml} in main project folder file:

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{namespace:}\AttributeTok{ App\textbackslash{}Tests}
    \FunctionTok{paths:}
        \FunctionTok{tests:}\AttributeTok{ tests}
        \FunctionTok{output:}\AttributeTok{ tests/_output}
        \FunctionTok{data:}\AttributeTok{ tests/_data}
        \FunctionTok{support:}\AttributeTok{ tests/_support}
        \FunctionTok{envs:}\AttributeTok{ tests/_envs}
    \FunctionTok{actor_suffix:}\AttributeTok{ Tester}
    \FunctionTok{extensions:}
        \FunctionTok{enabled:}
            \KeywordTok{-}\NormalTok{ Codeception\textbackslash{}Extension\textbackslash{}RunFailed}
    \FunctionTok{params:}
        \KeywordTok{-}\NormalTok{ .env}
\end{Highlighting}
\end{Shaded}

  \begin{itemize}
  \tightlist
  \item
    NOTE: the default URL for testing is: \texttt{localhost:8000} - you
    may need to change this if using a web server other than the Symfony
    one \ldots{}
  \end{itemize}
\item
  new folder \texttt{/tests} - you'll create your tests in here
\item
  new folder \texttt{vendor/bin/} containing executable:
  \texttt{codecept}

  \begin{itemize}
  \item
    you run command line Codeception commands with:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{vendor/bin/codecept} \OperatorTok{<}\NormalTok{command}\OperatorTok{>}
\end{Highlighting}
\end{Shaded}
  \end{itemize}
\item
  you may also have a PHPUnit configuration file
  \texttt{phpunit.xml.dist}
\item
  inside the \texttt{/tests} folder you'll find a configuration file for
  Acceptance tests
  `\texttt{containing\ the\ following.\ The\ default\ URL\ for\ testing\ is:}localhost:8000`
  - you may need to change this if using a web server other than the
  Symfony one \ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Codeception Test Suite Configuration}
\CommentTok{#}
\CommentTok{# Suite for acceptance tests.}
\CommentTok{# Perform tests in browser using the WebDriver or PhpBrowser.}
\CommentTok{# If you need both WebDriver and PHPBrowser tests - create a separate suite.}

\FunctionTok{actor:}\AttributeTok{ AcceptanceTester}
\FunctionTok{modules:}
    \FunctionTok{enabled:}
        \KeywordTok{-} \FunctionTok{PhpBrowser:}
            \FunctionTok{url:}\AttributeTok{ http://localhost:8000}
        \KeywordTok{-}\NormalTok{ \textbackslash{}App\textbackslash{}Tests\textbackslash{}Helper\textbackslash{}Acceptance}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\hypertarget{acceptance-tests}{%
\chapter{Acceptance Tests}\label{acceptance-tests}}

\hypertarget{test-for-home-page-text-at-project-codeception02}{%
\section{\texorpdfstring{Test for \texttt{home\ page} text at \texttt{/}
(project
\texttt{codeception02})}{Test for home page text at / (project codeception02)}}\label{test-for-home-page-text-at-project-codeception02}}

The project we started with (\texttt{security09}) has a simple public
home page template:

\begin{verbatim}
    {% extends 'base.html.twig' %}
    
    {% block body %}
        welcome to the home page
    {% endblock %}
\end{verbatim}

So let's generate an \textbf{acceptance} test to simulate a user
visiting \texttt{/} and seeing text \texttt{home\ page}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  generate a new acceptance test, note these classes end with
  \texttt{Cest}, and you use the \texttt{g:cest} parameter, which
  automatically give us access to \texttt{AcceptanceTester\ \$I},
  meaning we can write PHP code that is close to English-pseudocode,
  e.g.~\texttt{\$I-\textgreater{}see(\textquotesingle{}home\ page\textquotesingle{})}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{vendor/bin/codecept}\NormalTok{ g:cest acceptance HomePageCest}

    \ExtensionTok{Test}\NormalTok{ was created in /cept3/tests/acceptance/HomePageCest.php}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  We are given a skeleton Acceptance testing class:

\begin{Shaded}
\begin{Highlighting}[]
   \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Tests}\OtherTok{;}

   \KeywordTok{use}\NormalTok{ App\textbackslash{}Tests\textbackslash{}AcceptanceTester}\OtherTok{;}

   \KeywordTok{class}\NormalTok{ HomePageCest}
\NormalTok{   \{}
       \KeywordTok{public} \KeywordTok{function}\NormalTok{ _before}\OtherTok{(}\NormalTok{AcceptanceTester }\KeywordTok{$I}\OtherTok{)}
\NormalTok{       \{}
\NormalTok{       \}}

       \CommentTok{// tests}
       \KeywordTok{public} \KeywordTok{function}\NormalTok{ tryToTest}\OtherTok{(}\NormalTok{AcceptanceTester }\KeywordTok{$I}\OtherTok{)}
\NormalTok{       \{}
\NormalTok{       \}}
\NormalTok{   \}}
\end{Highlighting}
\end{Shaded}
\item
  Replace the contents of this class with one to test a home page visit:

\begin{Shaded}
\begin{Highlighting}[]
   \KeywordTok{class}\NormalTok{ HomePageCest}
\NormalTok{   \{}
       \KeywordTok{public} \KeywordTok{function}\NormalTok{ homePageContent}\OtherTok{(}\NormalTok{AcceptanceTester }\KeywordTok{$I}\OtherTok{)}
\NormalTok{       \{}
           \KeywordTok{$I}\NormalTok{->amOnPage}\OtherTok{(}\StringTok{'/'}\OtherTok{);}
           \KeywordTok{$I}\NormalTok{->see}\OtherTok{(}\StringTok{'welcome to the home page'}\OtherTok{);}
\NormalTok{       \}}
\NormalTok{   \}}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

There are 2 steps to our home page acceptance test;

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make the browser open URL \texttt{/}
\item
  Assert that somewhere in the text contents of the HTTP Response from
  the server is the text \texttt{welcome\ to\ the\ home\ page}
\end{enumerate}

\hypertarget{run-the-test-fail---server-not-running}{%
\section{Run the test (fail - server not
running)}\label{run-the-test-fail---server-not-running}}

Run the tests - we'll see a failure of our Acceptance test, since the
server isn't running:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{vendor/bin/codecept}\NormalTok{ run}
    
    \ExtensionTok{...}
    
    \ExtensionTok{App}\NormalTok{\textbackslash{}Tests.acceptance Tests (1) }
    
      \ExtensionTok{Testing}\NormalTok{ App\textbackslash{}Tests.acceptance}
    \ExtensionTok{E}\NormalTok{ HomePageCest: Home page content (0.02s)}

    \ExtensionTok{...} 
    
    \ExtensionTok{There}\NormalTok{ was 1 error:}
    
    \ExtensionTok{---------}
    \ExtensionTok{1}\NormalTok{) }\ExtensionTok{HomePageCest}\NormalTok{: Home page content}
     \ExtensionTok{Test}\NormalTok{  tests/acceptance/HomePageCest.php:homePageContent}
                             
\NormalTok{      [}\ExtensionTok{GuzzleHttp}\NormalTok{\textbackslash{}Exception\textbackslash{}ConnectException] cURL error 7: Failed to connect to localhost port 8000: Connection refused (see http://curl.haxx.se/libcurl/c/libcurl-errors.html)  }
\end{Highlighting}
\end{Shaded}

The error details tell us that the connection was refuse to localhost
port 8000.

\hypertarget{run-the-test-pass-when-server-running}{%
\section{Run the test (pass, when server
running)}\label{run-the-test-pass-when-server-running}}

Now run the Symfony server in a CLI terminal window with
\texttt{symfony\ serve}, and in a second CLI window run the Codeception
tests again. This time it should pass:

\begin{Shaded}
\begin{Highlighting}[]
          \ExtensionTok{Testing}\NormalTok{ App\textbackslash{}Tests.acceptance}
    \ExtensionTok{TICK}\NormalTok{ HomePageCest: Home page content (0.36s)}
\end{Highlighting}
\end{Shaded}

\hypertarget{from-red-to-green}{%
\section{From red to green}\label{from-red-to-green}}

Let's add an \texttt{about} page in this project:

\begin{itemize}
\item
  in our DefaultController class
  \texttt{/src/Controller/DefaultController.php} we can define this
  route:

\begin{Shaded}
\begin{Highlighting}[]
      \CommentTok{/**}
\CommentTok{       * }\AnnotationTok{@Route("/about",}\CommentTok{ name="about")}
\CommentTok{       */}
      \KeywordTok{public} \KeywordTok{function}\NormalTok{ about}\OtherTok{()}
\NormalTok{      \{}
          \KeywordTok{$template}\NormalTok{ = }\StringTok{'default/about.html.twig'}\OtherTok{;}
          \KeywordTok{$args}\NormalTok{ = }\OtherTok{[];}

          \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{      \}}
\end{Highlighting}
\end{Shaded}
\item
  and we can create Twig template
  \texttt{/templates/default/about.html.twig}:

\begin{verbatim}
  {% extends 'base.html.twig' %}

  {% block body %}
  <h1>about page</h1>
  <p>
  Welcome to the about page
  </p>
  {% endblock %}
\end{verbatim}
\end{itemize}

However, at present there isn't any \texttt{HREF} link from the home
page to the about page. Let's test this:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{class}\NormalTok{ HomePageCest}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ homePageContent}\OtherTok{(}\NormalTok{AcceptanceTester }\KeywordTok{$I}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$I}\NormalTok{->amOnPage}\OtherTok{(}\StringTok{'/'}\OtherTok{);}
            \KeywordTok{$I}\NormalTok{->see}\OtherTok{(}\StringTok{'home page'}\OtherTok{);}
\NormalTok{        \}}
    
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ homePageLinkToAbout}\OtherTok{(}\NormalTok{AcceptanceTester }\KeywordTok{$I}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$I}\NormalTok{->amOnPage}\OtherTok{(}\StringTok{'/'}\OtherTok{);}
            \KeywordTok{$I}\NormalTok{->click}\OtherTok{(}\StringTok{'about'}\OtherTok{);}
            \KeywordTok{$I}\NormalTok{->seeInCurrentUrl}\OtherTok{(}\StringTok{'/about'}\OtherTok{);}
            \KeywordTok{$I}\NormalTok{->see}\OtherTok{(}\StringTok{'about'}\OtherTok{);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

If we run Codeception again

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{App}\NormalTok{\textbackslash{}Tests.acceptance Tests (2) }
          \ExtensionTok{Testing}\NormalTok{ App\textbackslash{}Tests.acceptance}
    \ExtensionTok{TICK}\NormalTok{  HomePageCest: Home page content (0.20s)}
    \ExtensionTok{CROSS}\NormalTok{ HomePageCest: Home page link to about (0.16s)}
    
    \ExtensionTok{...}
    
    \ExtensionTok{1}\NormalTok{) }\ExtensionTok{HomePageCest}\NormalTok{: Home page link to about}
     \ExtensionTok{Test}\NormalTok{  tests/acceptance/HomePageCest.php:homePageLinkToAbout}
     \ExtensionTok{Step}\NormalTok{  Click }\StringTok{"about"}
     \ExtensionTok{Fail}\NormalTok{  Link or Button by name or CSS or XPath element with }\StringTok{'about'}\NormalTok{ was not found.}
\end{Highlighting}
\end{Shaded}

The details of the failure tells us that no link for text \texttt{about}
could be found on the home page.

\hypertarget{make-green---add-link-to-about-page-in-base-twig-template}{%
\section{\texorpdfstring{Make green - add link to \texttt{about} page in
base Twig
template}{Make green - add link to about page in base Twig template}}\label{make-green---add-link-to-about-page-in-base-twig-template}}

Add a link to the about page in the base Twig template
\texttt{templates/base.html.twig}, just below the existing navigation
link to the home page:

\begin{verbatim}
    <nav>
        <ul>
            <li>
                <a href="{{ url('homepage') }}">home</a>
            </li>
            <li>
                <a href="{{ url('about') }}">about</a>
            </li>
            {% if is_granted('ROLE_ADMIN') %}
                <li>
                    <a href="{{ url('admin') }}">admin home</a>
                </li>
            {% endif %}
        </ul>
    </nav>
\end{verbatim}

Clear the \textbf{cache} - e.g.~just delete folder \texttt{/var/cache},
and run Codeception again.

Now all tests should pass when we run Codeception.

\hypertarget{annotation-style-data-provider-to-test-multiple-data-project-codeception03}{%
\section{\texorpdfstring{Annotation style data provider to test multiple
data (project
\texttt{codeception03})}{Annotation style data provider to test multiple data (project codeception03)}}\label{annotation-style-data-provider-to-test-multiple-data-project-codeception03}}

Let's use the Codeception Doctrine-style Annotation data provider, to
test:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  routes to home page and about page
\item
  our base navigation links, from home page to home page and about page
\end{enumerate}

Create a new \texttt{Cest} acceptance test

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{vendor/bin/codecept}\NormalTok{ g:cest acceptance NavbarCest}
\end{Highlighting}
\end{Shaded}

Replace the skeleton with the following:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Tests}\OtherTok{;}

    \KeywordTok{use}\NormalTok{ App\textbackslash{}Tests\textbackslash{}AcceptanceTester}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Codeception\textbackslash{}Example}\OtherTok{;}
    
    \KeywordTok{class}\NormalTok{ NavbarCest}
\NormalTok{    \{}
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@example}\CommentVarTok{(url="/"}\CommentTok{, heading="Home page")}
\CommentTok{         * }\AnnotationTok{@example}\CommentVarTok{(url="/about"}\CommentTok{, heading="About page")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ staticPageContent}\OtherTok{(}\NormalTok{AcceptanceTester }\KeywordTok{$I}\OtherTok{,}\NormalTok{ Example }\KeywordTok{$example}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$I}\NormalTok{->amOnPage}\OtherTok{(}\KeywordTok{$example}\OtherTok{[}\StringTok{'url'}\OtherTok{]);}
            \KeywordTok{$I}\NormalTok{->see}\OtherTok{(}\KeywordTok{$example}\OtherTok{[}\StringTok{'heading'}\OtherTok{],} \StringTok{'h1'}\OtherTok{);}
\NormalTok{        \}}
    
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@example}\CommentVarTok{(url="/"}\CommentTok{, link="home")}
\CommentTok{         * }\AnnotationTok{@example}\CommentVarTok{(url="/about"}\CommentTok{, link="about")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ staticPageLinks}\OtherTok{(}\NormalTok{AcceptanceTester }\KeywordTok{$I}\OtherTok{,}\NormalTok{ Example }\KeywordTok{$example}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$I}\NormalTok{->amOnPage}\OtherTok{(}\StringTok{'/'}\OtherTok{);}
            \KeywordTok{$I}\NormalTok{->click}\OtherTok{(}\KeywordTok{$example}\OtherTok{[}\StringTok{'link'}\OtherTok{]);}
            \KeywordTok{$I}\NormalTok{->seeCurrentUrlEquals}\OtherTok{(}\KeywordTok{$example}\OtherTok{[}\StringTok{'url'}\OtherTok{]);} \CommentTok{// full URL}
            \KeywordTok{$I}\NormalTok{->seeInCurrentUrl}\OtherTok{(}\KeywordTok{$example}\OtherTok{[}\StringTok{'url'}\OtherTok{]);} \CommentTok{// part of URL}
\NormalTok{        \}    }
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

We see that we are using the \texttt{Codeception\textbackslash{}Example}
class, which allows us to write \texttt{@example} annotations (note
lower case \texttt{e}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    * }\ErrorTok{@}\NormalTok{example}\OtherTok{(}\NormalTok{url=}\StringTok{"/"}\OtherTok{,}\NormalTok{ heading=}\StringTok{"Home page"}\OtherTok{)}
\NormalTok{    * }\ErrorTok{@}\NormalTok{example}\OtherTok{(}\NormalTok{url=}\StringTok{"/about"}\OtherTok{,}\NormalTok{ heading=}\StringTok{"About page"}\OtherTok{)}
\end{Highlighting}
\end{Shaded}

Method \texttt{staticPageContent()} makes use of our custom example
values \texttt{url} and \texttt{heading} (we can name them what we want,
and have as many as we wish). The example data is provided to the
testing method as an associated map array. Each URL is visited, then an
assertion is made that we see the provided level 1 heading text on the
visited page
\texttt{\$I-\textgreater{}see(\$example{[}\textquotesingle{}hading\textquotesingle{}{]},\ \textquotesingle{}h1\textquotesingle{})}.

Method \texttt{staticPageLinks()} makes use of our custom example values
\texttt{url} and \texttt{link}. We start on the home page, attempt to
click a link wrapped around the text of the provided link
\texttt{\$I-\textgreater{}click(\$example{[}\textquotesingle{}link\textquotesingle{}{]})},
and then check the the provided URL is in the browser address bar having
clicked the link.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{     * }\ErrorTok{@}\NormalTok{example}\OtherTok{(}\NormalTok{url=}\StringTok{"/"}\OtherTok{,} \FunctionTok{link}\NormalTok{=}\StringTok{"home"}\OtherTok{)}
\NormalTok{     * }\ErrorTok{@}\NormalTok{example}\OtherTok{(}\NormalTok{url=}\StringTok{"/about"}\OtherTok{,} \FunctionTok{link}\NormalTok{=}\StringTok{"about"}\OtherTok{)}
\end{Highlighting}
\end{Shaded}

Notice, for this example, we test both that the provided \texttt{url}
matches the complete URL
\texttt{\$I-\textgreater{}seeCurrentUrlEquals(\$example{[}\textquotesingle{}url\textquotesingle{}{]})},
and also (a weaker test) is part of the URL string
\texttt{\$I-\textgreater{}seeInCurrentUrl(\$example{[}\textquotesingle{}url\textquotesingle{}{]})}.

\hypertarget{traditional-data-provider-syntax}{%
\section{Traditional Data Provider
syntax}\label{traditional-data-provider-syntax}}

If you prefer the more traditional Data Provided syntax, you can lean
about that at the Codeception documentation pages:

\begin{itemize}
\tightlist
\item
  \url{https://codeception.com/docs/07-AdvancedUsage\#DataProvider-Annotations}
\end{itemize}

\hypertarget{common-assertions-for-acceptance-tests}{%
\section{Common assertions for Acceptance
tests}\label{common-assertions-for-acceptance-tests}}

Here are the more common Codeception assertions for Acceptance tests:

\begin{itemize}
\item
  see / not see text in page (anywhere in HTML received by browser -
  could be in the \texttt{\textless{}head\textgreater{}} so not see by
  user)

  \begin{itemize}
  \item
    \texttt{\$I-\textgreater{}see(\textless{}text\ in\ page\textgreater{})}
  \item
    \texttt{\$I-\textgreater{}dontsee(\textless{}text\ in\ page\textgreater{})}
    - text is \textbf{NOT} present (e.g.~not see `invalid login')
  \end{itemize}
\item
  see / not see text in page in a specific CSS selector:

  \begin{itemize}
  \item
    \texttt{\$I-\textgreater{}see(\textless{}text\ in\ page\textgreater{},\ \textquotesingle{}\textless{}selector\textgreater{})}
  \item
    \texttt{\$I-\textgreater{}dontsee(\textless{}text\ in\ page\textgreater{},\ \textquotesingle{}\textless{}selector\textgreater{}\textquotesingle{})}
    - text is \textbf{NOT} present (e.g.~not see paragraph after valid
    login:
    \texttt{dontsee(\textquotesingle{}invalid\ login\textquotesingle{},\ \textquotesingle{}p\textquotesingle{})}
  \end{itemize}
\item
  see this text as a link

  \begin{itemize}
  \tightlist
  \item
    \texttt{\$I-\textgreater{}seeLink(\textquotesingle{}login\textquotesingle{});}
  \end{itemize}
\item
  click a text link

  \begin{itemize}
  \tightlist
  \item
    \texttt{\$I-\textgreater{}click(\textquotesingle{}login\textquotesingle{});}
  \end{itemize}
\item
  part of URL

  \begin{itemize}
  \tightlist
  \item
    \$I-\textgreater{}seeInCurrentUrl(`/blog');
  \end{itemize}
\item
  match of complete URL

  \begin{itemize}
  \tightlist
  \item
    \$I-\textgreater{}seeCurrentUrlEquals(`/about');
  \end{itemize}
\item
  see / don't see in HTML \texttt{\textless{}title\textgreater{}}:

  \begin{itemize}
  \item
    \texttt{\$I-\textgreater{}seeInTitle(\textquotesingle{}Login\textquotesingle{})}
  \item
    \texttt{\$I-\textgreater{}dontSeeInTitle(\textquotesingle{}Register\textquotesingle{})}
  \end{itemize}
\end{itemize}

More details of what you can do with \texttt{\$I} can be found in the
docs for the \texttt{PhpBrowser} module:

\begin{itemize}
\tightlist
\item
  \url{https://codeception.com/docs/modules/PhpBrowser}
\end{itemize}

\hypertarget{filling-out-forms}{%
\chapter{Filling out forms}\label{filling-out-forms}}

\hypertarget{setup-database-project-codeception04}{%
\section{\texorpdfstring{Setup database (project
\texttt{codeception04})}{Setup database (project codeception04)}}\label{setup-database-project-codeception04}}

Let's generate a \texttt{Recipe} Entity class, and its CRUD - with no
security.

Generate a \texttt{Recipe} Entity class:

\begin{itemize}
\item
  title (string)
\item
  steps (string)
\item
  time (integer)
\end{itemize}

Also generate its CRUD, and migrate it to the database.

There should now be a new recipe form at URL \texttt{/recipe/new}.

\hypertarget{view-the-twig-template-for-a-new-recipe}{%
\section{View the Twig template for a new
Recipe}\label{view-the-twig-template-for-a-new-recipe}}

Open a web browser and enter URL \texttt{/recipe/new}. Then view the
page source and look at the HTML form:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<form}\OtherTok{ name=}\StringTok{"recipe"}\OtherTok{ method=}\StringTok{"post"}\KeywordTok{>}
    \KeywordTok{<div}\OtherTok{ id=}\StringTok{"recipe"}\KeywordTok{><div>}
    \KeywordTok{<label}\OtherTok{ for=}\StringTok{"recipe_title"}\OtherTok{ class=}\StringTok{"required"}\KeywordTok{>}\NormalTok{Title}\KeywordTok{</label>}
    \KeywordTok{<input}\OtherTok{ type=}\StringTok{"text"}\OtherTok{ id=}\StringTok{"recipe_title"}\OtherTok{ name=}\StringTok{"recipe[title]"}\OtherTok{ required=}\StringTok{"required"}\OtherTok{ maxlength=}\StringTok{"255"} \KeywordTok{/>}
    \KeywordTok{</div>}
    \KeywordTok{<div>}
    \KeywordTok{<label}\OtherTok{ for=}\StringTok{"recipe_steps"}\OtherTok{ class=}\StringTok{"required"}\KeywordTok{>}\NormalTok{Steps}\KeywordTok{</label>}
    \KeywordTok{<input}\OtherTok{ type=}\StringTok{"number"}\OtherTok{ id=}\StringTok{"recipe_steps"}\OtherTok{ name=}\StringTok{"recipe[steps]"}\OtherTok{ required=}\StringTok{"required"} \KeywordTok{/>}
    \KeywordTok{</div>}
    
    \KeywordTok{<div><label}\OtherTok{ for=}\StringTok{"recipe_time"}\OtherTok{ class=}\StringTok{"required"}\KeywordTok{>}\NormalTok{Time}\KeywordTok{</label>}
    \KeywordTok{<input}\OtherTok{ type=}\StringTok{"number"}\OtherTok{ id=}\StringTok{"recipe_time"}\OtherTok{ name=}\StringTok{"recipe[time]"}\OtherTok{ required=}\StringTok{"required"} \KeywordTok{/>}
    \KeywordTok{</div>}
    
    \KeywordTok{<input}\OtherTok{ type=}\StringTok{"hidden"}\OtherTok{ id=}\StringTok{"recipe__token"}\OtherTok{ name=}\StringTok{"recipe[_token]"}\OtherTok{ value=}\StringTok{"Su7AJhQM_GiNSjtmEaioeT3X88SUqfWEI9phdE2Ow9Y"} \KeywordTok{/>}
    \KeywordTok{</div>}
    \KeywordTok{<button}\OtherTok{ class=}\StringTok{"btn"}\KeywordTok{>}\NormalTok{Save}\KeywordTok{</button>}
\KeywordTok{</form>}
\end{Highlighting}
\end{Shaded}

The important values here are the \textbf{IDs} of the
\texttt{\textless{}input\textgreater{}} elements:

\begin{itemize}
\tightlist
\item
  \texttt{\#recipe\_title}
\item
  \texttt{\#recipe\_steps}
\item
  \texttt{\#recipe\_time}
\end{itemize}

It's these form element IDs we need to use to create an automated test
to enter data into a form.

Also, we need to know the text for the submit button, which in this
example is:

\begin{itemize}
\tightlist
\item
  \texttt{Save}
\end{itemize}

\hypertarget{cest-to-enter-a-new-recipe}{%
\section{Cest to enter a new recipe}\label{cest-to-enter-a-new-recipe}}

Generate a new \texttt{Cest} to fill in the form for a new recipe:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{vendor/bin/codecept}\NormalTok{ g:cest acceptance RecipeCest}
\end{Highlighting}
\end{Shaded}

Edit the skeleton as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Tests}\OtherTok{;}    
    
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Tests\textbackslash{}AcceptanceTester}\OtherTok{;}
    
    \KeywordTok{class}\NormalTok{ RecipeCest}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ tryToTest}\OtherTok{(}\NormalTok{AcceptanceTester }\KeywordTok{$I}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$I}\NormalTok{->amOnPage}\OtherTok{(}\StringTok{'/recipe/new'}\OtherTok{);}
            \KeywordTok{$I}\NormalTok{->fillField}\OtherTok{(}\StringTok{'#recipe_title'}\OtherTok{,} \StringTok{'Boston Cheesecake'}\OtherTok{);}
            \KeywordTok{$I}\NormalTok{->fillField}\OtherTok{(}\StringTok{'#recipe_steps'}\OtherTok{,} \StringTok{'buy packet - follow instructions'}\OtherTok{);}
            \KeywordTok{$I}\NormalTok{->fillField}\OtherTok{(}\StringTok{'#recipe_time'}\OtherTok{,} \DecValTok{60}\OtherTok{);}
            \KeywordTok{$I}\NormalTok{->click}\OtherTok{(}\StringTok{'Save'}\OtherTok{);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

As you can see we select an HTML form input by its \textbf{id}, so
\texttt{\#recipe\_title} is the form field for the \texttt{title}
property of the new Recipe to be created etc.

When you run the server and run the acceptance tests you'll now see a
new recipe in the database, based on your acceptance tests completion of
the forms.

\hypertarget{codeception-symfony-db-testing}{%
\chapter{Codeception Symfony DB
testing}\label{codeception-symfony-db-testing}}

\hypertarget{adding-symfony-and-doctrine-to-the-settings-project-codeception05}{%
\section{\texorpdfstring{Adding Symfony and Doctrine to the settings
(project
\texttt{codeception05})}{Adding Symfony and Doctrine to the settings (project codeception05)}}\label{adding-symfony-and-doctrine-to-the-settings-project-codeception05}}

Let's configure Codeception to use Doctrine for DB work, and to
recognise Symfony controllers.

Note - by stating \texttt{cleanup:true} for the Doctrine2 module, we are
asking Codeception to create a database \textbf{transaction} before each
test runs, and then to roll-back the translation after the test runs. So
the database should be in the same state \textbf{after} each test as it
was \textbf{before}. Thus, our tests are not linked and do not rely on
running in a set sequence.

We need to edit file \texttt{/tests/acceptance.yml.suite} to add the
following:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{-} \FunctionTok{Symfony:}
        \FunctionTok{app_path:}\AttributeTok{ }\StringTok{'src'}
        \FunctionTok{environment:}\AttributeTok{ }\StringTok{'test'}
    \KeywordTok{-} \FunctionTok{Doctrine2:}
        \FunctionTok{depends:}\AttributeTok{ Symfony}
        \FunctionTok{cleanup:}\AttributeTok{ }\CharTok{true}
    \KeywordTok{-}\NormalTok{ Asserts}
\end{Highlighting}
\end{Shaded}

So it should now contain:

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{actor:}\AttributeTok{ AcceptanceTester}
    \FunctionTok{modules:}
        \FunctionTok{enabled:}
            \KeywordTok{-} \FunctionTok{PhpBrowser:}
                \FunctionTok{url:}\AttributeTok{ http://localhost:8000}
            \KeywordTok{-}\NormalTok{ \textbackslash{}App\textbackslash{}Tests\textbackslash{}Helper\textbackslash{}Acceptance}
            \KeywordTok{-} \FunctionTok{Symfony:}
                \FunctionTok{app_path:}\AttributeTok{ }\StringTok{'src'}
                \FunctionTok{environment:}\AttributeTok{ }\StringTok{'test'}
            \KeywordTok{-} \FunctionTok{Doctrine2:}
                \FunctionTok{depends:}\AttributeTok{ Symfony}
                \FunctionTok{cleanup:}\AttributeTok{ }\CharTok{true}
            \KeywordTok{-}\NormalTok{ Asserts}
\end{Highlighting}
\end{Shaded}

\hypertarget{test-users-in-db-from-fixtures}{%
\section{Test Users in DB from
Fixtures}\label{test-users-in-db-from-fixtures}}

To work with databases we need to add the Doctrine Codeception module:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{composer}\NormalTok{ req codeception/module-doctrine2 --dev }
\end{Highlighting}
\end{Shaded}

Generate a new Acceptance test \texttt{UserCest}:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{codecept}\NormalTok{ g:cest acceptance UserCest}
\end{Highlighting}
\end{Shaded}

Edit this new file \texttt{/tests/acceptance/UserCest.php} to contain
the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php }\KeywordTok{namespace}\NormalTok{ App\textbackslash{}Tests}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Tests\textbackslash{}AcceptanceTester}\OtherTok{;}
    
    \KeywordTok{class}\NormalTok{ UserCest}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ testUsersInDb}\OtherTok{(}\NormalTok{AcceptanceTester }\KeywordTok{$I}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{$I}\NormalTok{->seeInRepository}\OtherTok{(}\StringTok{'App\textbackslash{}Entity\textbackslash{}User'}\OtherTok{,} \OtherTok{[}
                \StringTok{'email'}\NormalTok{ => }\StringTok{'user@user.com'}
            \OtherTok{]);}
            \KeywordTok{$I}\NormalTok{->seeInRepository}\OtherTok{(}\StringTok{'App\textbackslash{}Entity\textbackslash{}User'}\OtherTok{,} \OtherTok{[}
                \StringTok{'email'}\NormalTok{ => }\StringTok{'admin@admin.com'}
            \OtherTok{]);}
            \KeywordTok{$I}\NormalTok{->seeInRepository}\OtherTok{(}\StringTok{'App\textbackslash{}Entity\textbackslash{}User'}\OtherTok{,} \OtherTok{[}
                \StringTok{'email'}\NormalTok{ => }\StringTok{'matt.smith@smith.com'}
            \OtherTok{]);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

NOTE: If we had created a Security \texttt{User} entity using
\texttt{username} for login rather than \texttt{email} we'd write
something like this to test for them in the DB:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testUsersInDb}\OtherTok{(}\NormalTok{AcceptanceTester }\KeywordTok{$I}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$I}\NormalTok{->seeInRepository}\OtherTok{(}\StringTok{'App\textbackslash{}Entity\textbackslash{}User'}\OtherTok{,} \OtherTok{[}
            \StringTok{'username'}\NormalTok{ => }\StringTok{'user'}
        \OtherTok{]);}
        \KeywordTok{$I}\NormalTok{->seeInRepository}\OtherTok{(}\StringTok{'App\textbackslash{}Entity\textbackslash{}User'}\OtherTok{,} \OtherTok{[}
            \StringTok{'username'}\NormalTok{ => }\StringTok{'admin'}
        \OtherTok{]);}
        \KeywordTok{$I}\NormalTok{->seeInRepository}\OtherTok{(}\StringTok{'App\textbackslash{}Entity\textbackslash{}User'}\OtherTok{,} \OtherTok{[}
            \StringTok{'username'}\NormalTok{ => }\StringTok{'matt'}
        \OtherTok{]);}
\end{Highlighting}
\end{Shaded}

When you run the test should pass (assuming these users are in the DB
from the Fixtures setup).

And, of course, we could tidy this up using data providers as in a
previous chapter \ldots{}

\hypertarget{check-db-reset-after-each-test}{%
\section{Check DB reset after each
test}\label{check-db-reset-after-each-test}}

The \texttt{AcceptanceTester} method \texttt{haveInRepository(...)}
INSERTS an object into the database for testing. This is to be
distinguished from the very similarly named
\texttt{seeInRepository(...)} which tests whether an object already
EXISTS in the database.

Add 2 more test methods, one to create a new user, and test it exists,
and then one to check that that new user was removed when its test
finished running:

\begin{Shaded}
\begin{Highlighting}[]
    
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testAddToDatabase}\OtherTok{(}\NormalTok{AcceptanceTester }\KeywordTok{$I}\OtherTok{)}
\NormalTok{    \{}
        \CommentTok{// INSERT new user `userTemp@temp.com` into the User table }
        \KeywordTok{$I}\NormalTok{->haveInRepository}\OtherTok{(}\StringTok{'App\textbackslash{}Entity\textbackslash{}User'}\OtherTok{,} \OtherTok{[}
            \StringTok{'email'}\NormalTok{ => }\StringTok{'userTemp@temp.com'}\OtherTok{,}
            \StringTok{'password'}\NormalTok{ => }\StringTok{'simplepassword'}\OtherTok{,}
            \StringTok{'roles'}\NormalTok{ => }\OtherTok{[}\StringTok{'ROLE_USER'}\OtherTok{]}
        \OtherTok{]);}

        \CommentTok{// test whether user `userTemp@temp.com`  can be FOUND in the table}
        \KeywordTok{$I}\NormalTok{->seeInRepository}\OtherTok{(}\StringTok{'App\textbackslash{}Entity\textbackslash{}User'}\OtherTok{,} \OtherTok{[}
            \StringTok{'email'}\NormalTok{ => }\StringTok{'userTemp@temp.com'}\OtherTok{,}
        \OtherTok{]);}
\NormalTok{    \}}

    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testTEMPNoLongerInDatabase}\OtherTok{(}\NormalTok{AcceptanceTester }\KeywordTok{$I}\OtherTok{)}
\NormalTok{    \{}
        \CommentTok{// since we are RESETTING db after each test, the temporary user should NOT still be in the repository...}
        \KeywordTok{$I}\NormalTok{->dontSeeInRepository}\OtherTok{(}\StringTok{'App\textbackslash{}Entity\textbackslash{}User'}\OtherTok{,} \OtherTok{[}
            \StringTok{'email'}\NormalTok{ => }\StringTok{'userTemp@temp.com'}\OtherTok{,}
        \OtherTok{]);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{add-db-counts-to-our-form-filling-acceptance-test-project-codeception06}{%
\section{\texorpdfstring{Add DB counts to our form-filling Acceptance
test (project
\texttt{codeception06})}{Add DB counts to our form-filling Acceptance test (project codeception06)}}\label{add-db-counts-to-our-form-filling-acceptance-test-project-codeception06}}

Let's add code to count number of recipes int he DB before and after
filling in the form to cfreatge a new recipe.

First, let's ensure there is one recipe in the data through a fixture:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}DataFixtures}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}Bundle\textbackslash{}FixturesBundle\textbackslash{}Fixture}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Doctrine\textbackslash{}Common\textbackslash{}Persistence\textbackslash{}ObjectManager}\OtherTok{;}
    
    \KeywordTok{use}\NormalTok{ App\textbackslash{}Entity\textbackslash{}Recipe}\OtherTok{;}
    
    \KeywordTok{class}\NormalTok{ RecipeFixtures }\KeywordTok{extends}\NormalTok{ Fixture}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ load}\OtherTok{(}\NormalTok{ObjectManager }\KeywordTok{$manager}\OtherTok{)}
\NormalTok{        \{}
             \KeywordTok{$recipe}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Recipe}\OtherTok{();}
             \KeywordTok{$recipe}\NormalTok{->setTitle}\OtherTok{(}\StringTok{'Boston Cheesecake'}\OtherTok{);}
             \KeywordTok{$recipe}\NormalTok{->setSteps}\OtherTok{(}\StringTok{'open package - follow instructions'}\OtherTok{);}
             \KeywordTok{$recipe}\NormalTok{->setTime}\OtherTok{(}\DecValTok{120}\OtherTok{);}
    
             \KeywordTok{$manager}\NormalTok{->persist}\OtherTok{(}\KeywordTok{$recipe}\OtherTok{);}
    
            \KeywordTok{$manager}\NormalTok{->}\FunctionTok{flush}\OtherTok{();}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

And load the fixtures via the Symfony console Doctrine command.

Now we can add to our Recipe form-filling acceptance test to count 1
recipe initially, then 2 after the new one has been created by filling
in the form:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ tryToTest}\OtherTok{(}\NormalTok{AcceptanceTester }\KeywordTok{$I}\OtherTok{)}
\NormalTok{    \{}
        \CommentTok{// --- expect 1 in DB from fixtures}
        \KeywordTok{$expectedCount}\NormalTok{ = }\DecValTok{1}\OtherTok{;}
        \KeywordTok{$recipes}\NormalTok{ = }\KeywordTok{$I}\NormalTok{->grabEntitiesFromRepository}\OtherTok{(}\StringTok{'App\textbackslash{}Entity\textbackslash{}Recipe'}\OtherTok{);}
        \KeywordTok{$numRecipes}\NormalTok{ = }\FunctionTok{count}\OtherTok{(}\KeywordTok{$recipes}\OtherTok{);}

        \CommentTok{// assert}
        \KeywordTok{$I}\NormalTok{->assertEquals}\OtherTok{(}\KeywordTok{$expectedCount}\OtherTok{,} \KeywordTok{$numRecipes}\OtherTok{);}

        \CommentTok{// --- create new recipe via FORM}
        \CommentTok{// title suffix RANDOM numbner: 'Boston Cheesecake<randNum>'}
        \KeywordTok{$randomNumber}\NormalTok{ = }\FunctionTok{rand}\OtherTok{(}\DecValTok{1}\OtherTok{,}\DecValTok{100}\OtherTok{);}
        \KeywordTok{$recipeTitle}\NormalTok{ = }\StringTok{'Boston Cheesecake'}\NormalTok{ . }\KeywordTok{$randomNumber}\OtherTok{;}

        \KeywordTok{$I}\NormalTok{->amOnPage}\OtherTok{(}\StringTok{'/recipe/new'}\OtherTok{);}
        \KeywordTok{$I}\NormalTok{->fillField}\OtherTok{(}\StringTok{'#recipe_title'}\OtherTok{,} \KeywordTok{$recipeTitle}\OtherTok{);}
        \KeywordTok{$I}\NormalTok{->fillField}\OtherTok{(}\StringTok{'#recipe_steps'}\OtherTok{,} \StringTok{'buy packet - follow instructions'}\OtherTok{);}
        \KeywordTok{$I}\NormalTok{->fillField}\OtherTok{(}\StringTok{'#recipe_time'}\OtherTok{,} \DecValTok{60}\OtherTok{);}
        \KeywordTok{$I}\NormalTok{->click}\OtherTok{(}\StringTok{'Save'}\OtherTok{);}

        \CommentTok{// ---- check added to repository}
        \KeywordTok{$I}\NormalTok{->seeInRepository}\OtherTok{(}\StringTok{'App\textbackslash{}Entity\textbackslash{}Recipe'}\OtherTok{,} \OtherTok{[}
            \StringTok{'title'}\NormalTok{ => }\KeywordTok{$recipeTitle}
        \OtherTok{]);}


        \CommentTok{// --- now should be 2 in DB}
        \KeywordTok{$expectedCount}\NormalTok{ = }\DecValTok{2}\OtherTok{;}
        \KeywordTok{$recipes}\NormalTok{ = }\KeywordTok{$I}\NormalTok{->grabEntitiesFromRepository}\OtherTok{(}\StringTok{'App\textbackslash{}Entity\textbackslash{}Recipe'}\OtherTok{);}
        \KeywordTok{$numRecipes}\NormalTok{ = }\FunctionTok{count}\OtherTok{(}\KeywordTok{$recipes}\OtherTok{);}

        \CommentTok{// assert}
        \KeywordTok{$I}\NormalTok{->assertEquals}\OtherTok{(}\KeywordTok{$expectedCount}\OtherTok{,} \KeywordTok{$numRecipes}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\part{Symfony Testing}

\hypertarget{unit-testing-in-symfony}{%
\chapter{Unit testing in Symfony}\label{unit-testing-in-symfony}}

\hypertarget{testing-in-symfony}{%
\section{Testing in Symfony}\label{testing-in-symfony}}

Symfony is built by an open source community. There is a lot of
information about how to test Symfony in the official documentation
pages:

\begin{itemize}
\item
  \href{http://symfony.com/doc/current/testing.html}{Symfony testing}
\item
  \href{http://symfony.com/doc/current/testing/simulating_authentication.html}{Testing
  with user authentication tokens}
\item
  \href{http://symfony.com/doc/current/testing/http_authentication.html}{How
  to Simulate HTTP Authentication in a Functional Test}
\end{itemize}

\hypertarget{installing-simple-phpunit-project-test01}{%
\section{\texorpdfstring{Installing Simple-PHPUnit (project
\texttt{test01})}{Installing Simple-PHPUnit (project test01)}}\label{installing-simple-phpunit-project-test01}}

Symfony has as special `bridge' to work with PHPUnit. Add this to your
project as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ req --dev simple-phpunit}
\end{Highlighting}
\end{Shaded}

You should now see a \texttt{/tests} directory created. Let's create a
simple test (1 + 1 = 2!) to check everything is working okay.

Create a new class \texttt{/tests/SimpleTest.php} containing the
following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php}
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Test}\OtherTok{;}

    \KeywordTok{use}\NormalTok{ PHPUnit\textbackslash{}Framework\textbackslash{}TestCase}\OtherTok{;}

    \KeywordTok{class}\NormalTok{ SimpleTest }\KeywordTok{extends}\NormalTok{ TestCase}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ testOnePlusOneEqualsTwo}\OtherTok{()}
\NormalTok{        \{}
            \CommentTok{// Arrange}
            \KeywordTok{$num1}\NormalTok{ = }\DecValTok{1}\OtherTok{;}
            \KeywordTok{$num2}\NormalTok{ = }\DecValTok{1}\OtherTok{;}
            \KeywordTok{$expectedResult}\NormalTok{ = }\DecValTok{2}\OtherTok{;}

            \CommentTok{// Act}
            \KeywordTok{$result}\NormalTok{ = }\KeywordTok{$num1}\NormalTok{ + }\KeywordTok{$num2}\OtherTok{;}

            \CommentTok{// Assert}
            \KeywordTok{$this}\NormalTok{->assertEquals}\OtherTok{(}\KeywordTok{$expectedResult}\OtherTok{,} \KeywordTok{$result}\OtherTok{);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Note the following:

\begin{itemize}
\item
  test classes are located in directory \texttt{/tests}
\item
  test classes end with the suffix \texttt{Test},
  e.g.~\texttt{SimpleTest}
\item
  simple test classes extend the superclass
  \texttt{\textbackslash{}PHPUnit\textbackslash{}Framework\textbackslash{}TestCase}

  -- if we add a \texttt{uses} statement
  \texttt{use\ PHPUnit\textbackslash{}Framework\textbackslash{}TestCase}
  then we can simple extend \texttt{TestCase}
\item
  simple test classes are in namespace \texttt{App\textbackslash{}Test}

  -- the names and namespaces of test classes testing a class in
  \texttt{/src} will reflect the namespace of the class being tested

  -- i.e.~If we write a class to test
  \texttt{/src/Controller/DefaultController.php} it will be
  \texttt{/tests/Controller/DefaultControllerTest.php}, and it will be
  in namespace
  \texttt{App\textbackslash{}Controller\textbackslash{}Test}

  -- so our testing class architecture directly matches our source code
  architecture
\end{itemize}

\hypertarget{completing-the-installation}{%
\section{Completing the
installation}\label{completing-the-installation}}

The first time you run Simple-PHPUnit it will probably need to install
some more files.

There is an executable file in \texttt{/vendor/bin} named
\texttt{simple-phpunit}. To run it just type
\texttt{vendor/bin/simple-phpunit} (or for Windows, to run the BATch
file, type
\texttt{vendor\textbackslash{}bin\textbackslash{}simple-phpunit} - with
backslashes since this is a Windows file path):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{vendor/bin/simple-phpunit}
    \ExtensionTok{./composer.json}\NormalTok{ has been updated}
    \ExtensionTok{Loading}\NormalTok{ composer repositories with package information}
    \ExtensionTok{Updating}\NormalTok{ dependencies}
    \ExtensionTok{Package}\NormalTok{ operations: 19 installs, 0 updates, 0 removals}
      \ExtensionTok{-}\NormalTok{ Installing sebastian/recursion-context (2.0.0)}\BuiltInTok{:}\NormalTok{ Loading from cache}
      \ExtensionTok{...}
      \ExtensionTok{-}\NormalTok{ Installing symfony/phpunit-bridge (dev-master)}\BuiltInTok{:}\NormalTok{ Symlinking from /Users/matt/Library/Mobile Documents/com~apple~CloudDocs/11_Books/symfony/php-symfony4-book-codes/part-testing/test01_simple/vendor/symfony/phpunit-bridge}
    \ExtensionTok{Writing}\NormalTok{ lock file}
    \ExtensionTok{Generating}\NormalTok{ optimized autoload files}
\end{Highlighting}
\end{Shaded}

NOTE: Error message about missing \texttt{ext-mbstring}:

\begin{itemize}
\item
  if you get a message about ``ext mbstring'' required - when trying to
  work in Windows with Simple PHP Unit or make:
\item
  simple solution - in your php.ini file

  -- Just as you did for pdo\_mysql, remove the semi-colon in front of
  the statement in the php.ini file:

  -- e.g.~change \texttt{;extension=mbstring} to:
  \texttt{extension=mbstring}
\end{itemize}

\hypertarget{running-simple-phpunit}{%
\section{Running Simple-PHPUnit}\label{running-simple-phpunit}}

Let's run the tests (using the default configuration settings, in
\texttt{phpunit.dist.xml}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{vendor/bin/simple-phpunit}
    \ExtensionTok{PHPUnit}\NormalTok{ 5.7.27 by Sebastian Bergmann and contributors.}
    \ExtensionTok{Testing}\NormalTok{ Project Test Suite}
    \BuiltInTok{.}                                                                   \ExtensionTok{1}\NormalTok{ / 1 (100%)}

    \ExtensionTok{Time}\NormalTok{: 93 ms, Memory: 4.00MB}
    \ExtensionTok{OK}\NormalTok{ (1 test, 1 assertion)}
\end{Highlighting}
\end{Shaded}

Dots are good. For each passed test you'll see a full stop. Then after
all tests have run, you'll see a summary:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{1}\NormalTok{ / 1 (100%)}
\end{Highlighting}
\end{Shaded}

This tells us how many passed, out of how many, and what the pass
percentage was. In our case, 1 out of 1 passed = 100\%.

\hypertarget{testing-other-classes-project-test02}{%
\section{\texorpdfstring{Testing other classes (project
\texttt{test02})}{Testing other classes (project test02)}}\label{testing-other-classes-project-test02}}

\textbf{our testing structure mirrors the code we are testing}

Let's create a very simple class \texttt{Calculator.php} in
\texttt{/src/Util}\footnote{Short for `Utilty' - i.e.~useful stuff!},
and then write a class to test our class. Our simple class will be a
very simple calculator:

\begin{itemize}
\item
  method \texttt{add(...)} accepts 2 numbers and returns the result of
  adding them
\item
  method \texttt{subtract()} accepts 2 numbers and returns the result of
  subtractingt the second from the first
\end{itemize}

so our \texttt{Calculator} class is as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php}
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Util}\OtherTok{;}

    \KeywordTok{class}\NormalTok{ Calculator}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ add}\OtherTok{(}\KeywordTok{$n1}\OtherTok{,} \KeywordTok{$n2}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{return} \KeywordTok{$n1}\NormalTok{ + }\KeywordTok{$n2}\OtherTok{;}
\NormalTok{        \}}

        \KeywordTok{public} \KeywordTok{function}\NormalTok{ subtract}\OtherTok{(}\KeywordTok{$n1}\OtherTok{,} \KeywordTok{$n2}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{return} \KeywordTok{$n1}\NormalTok{ - }\KeywordTok{$n2}\OtherTok{;}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-class-to-test-our-calculator}{%
\section{The class to test our
calculator}\label{the-class-to-test-our-calculator}}

We now need to write a test class to test our calculator class. Since
our source code class is \texttt{/src/Util/Calculator.php} then our
testing class will be \texttt{/tests/Util/Calculator.php}. And since the
namespace of our source code class was \texttt{App\textbackslash{}Util}
then the namespace of our testing class will be
\texttt{App\textbackslash{}Util\textbackslash{}Test}. Let's test making
an instance-object of our class \texttt{Calculator}, and we will make 2
assertions:

\begin{itemize}
\item
  the reference to the new object is not NULL
\item
  invoking the \texttt{add(...)} method with arguments of (1,1) and
  returns the correct answer (2!)
\end{itemize}

Here's the listing for our class \texttt{CalculatorTest}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Util\textbackslash{}Test}\OtherTok{;}

    \KeywordTok{use}\NormalTok{ App\textbackslash{}Util\textbackslash{}Calculator}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ PHPUnit\textbackslash{}Framework\textbackslash{}TestCase}\OtherTok{;}

    \KeywordTok{class}\NormalTok{ CalculatorTest }\KeywordTok{extends}\NormalTok{ TestCase}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ testCanCreateObject}\OtherTok{()}
\NormalTok{        \{}
            \CommentTok{// Arrange}
            \KeywordTok{$calculator}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Calculator}\OtherTok{();}

            \CommentTok{// Act}

            \CommentTok{// Assert}
            \KeywordTok{$this}\NormalTok{->assertNotNull}\OtherTok{(}\KeywordTok{$calculator}\OtherTok{);}
\NormalTok{        \}}

        \KeywordTok{public} \KeywordTok{function}\NormalTok{ testAddOneAndOne}\OtherTok{()}
\NormalTok{        \{}
            \CommentTok{// Arrange}
            \KeywordTok{$calculator}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Calculator}\OtherTok{();}
            \KeywordTok{$num1}\NormalTok{ = }\DecValTok{1}\OtherTok{;}
            \KeywordTok{$num2}\NormalTok{ = }\DecValTok{1}\OtherTok{;}
            \KeywordTok{$expectedResult}\NormalTok{ = }\DecValTok{2}\OtherTok{;}

            \CommentTok{// Act}
            \KeywordTok{$result}\NormalTok{ = }\KeywordTok{$calculator}\NormalTok{->add}\OtherTok{(}\KeywordTok{$num1}\OtherTok{,} \KeywordTok{$num2}\OtherTok{);}

            \CommentTok{// Assert}
            \KeywordTok{$this}\NormalTok{->assertEquals}\OtherTok{(}\KeywordTok{$expectedResult}\OtherTok{,} \KeywordTok{$result}\OtherTok{);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Note:

\begin{itemize}
\tightlist
\item
  we had to add \texttt{use} statements for the class we are testing
  (\texttt{App\textbackslash{}Util\textbackslash{}Calculator}) and the
  PHP Unit TestCase class we are extending
  (\texttt{use\ PHPUnit\textbackslash{}Framework\textbackslash{}TestCase})
\end{itemize}

Run the tests - if all goes well we should see 3 out of 3 tests passing:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{vendor/bin/simple-phpunit}
    \ExtensionTok{PHPUnit}\NormalTok{ 5.7.27 by Sebastian Bergmann and contributors.}
    \ExtensionTok{Testing}\NormalTok{ Project Test Suite}
    \ExtensionTok{...}\NormalTok{                                                                 3 / 3 (100%)}

    \ExtensionTok{Time}\NormalTok{: 64 ms, Memory: 4.00MB}
    \ExtensionTok{OK}\NormalTok{ (3 tests, 3 assertions)}
\end{Highlighting}
\end{Shaded}

\hypertarget{using-a-data-provider-to-test-with-multiple-datasets-project-test03}{%
\section{\texorpdfstring{Using a data provider to test with multiple
datasets (project
\texttt{test03})}{Using a data provider to test with multiple datasets (project test03)}}\label{using-a-data-provider-to-test-with-multiple-datasets-project-test03}}

Rather than writing lots of methods to test different additions, let's
use a \textbf{data provider} (via an annotation comment), to provide a
single method with many sets of input and expected output values:

Here is our testing method:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@dataProvider}\CommentTok{ additionProvider}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testAdditionsWithProvider}\OtherTok{(}\KeywordTok{$num1}\OtherTok{,} \KeywordTok{$num2}\OtherTok{,} \KeywordTok{$expectedResult}\OtherTok{)}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$calculator}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Calculator}\OtherTok{();}

        \CommentTok{// Act}
        \KeywordTok{$result}\NormalTok{ = }\KeywordTok{$calculator}\NormalTok{->add}\OtherTok{(}\KeywordTok{$num1}\OtherTok{,} \KeywordTok{$num2}\OtherTok{);}

        \CommentTok{// Assert}
        \KeywordTok{$this}\NormalTok{->assertEquals}\OtherTok{(}\KeywordTok{$expectedResult}\OtherTok{,} \KeywordTok{$result}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

and here is the data provider (an array of arrays, with the right number
of values for the parameters of \texttt{testAdditionsWithProvider(...)}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ additionProvider}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{return} \OtherTok{[}
            \OtherTok{[}\DecValTok{1}\OtherTok{,} \DecValTok{1}\OtherTok{,} \DecValTok{2}\OtherTok{],}
            \OtherTok{[}\DecValTok{2}\OtherTok{,} \DecValTok{2}\OtherTok{,} \DecValTok{4}\OtherTok{],}
            \OtherTok{[}\DecValTok{0}\OtherTok{,} \DecValTok{1}\OtherTok{,} \DecValTok{1}\OtherTok{],}
        \OtherTok{];}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Take special note of the annotation comment immediately before method
\texttt{testAdditionsWithProvider(...)}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@dataProvider}\CommentTok{ additionProvider}
\CommentTok{     */}
\end{Highlighting}
\end{Shaded}

The special comment starts with \texttt{/**}, and declares an annotation
\texttt{@dataProvider}, followed by the name (identifier) of the method.
Note especially that there are no parentheses \texttt{()} after the
method name.

When we run Simple-PHPUnit now we see lots of tests being executed,
repeatedly invoking \texttt{testAdditionsWithProvider(...)} with
different arguments from the provider:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{vendor/bin/simple-phpunit}
    \ExtensionTok{PHPUnit}\NormalTok{ 5.7.27 by Sebastian Bergmann and contributors.}

    \ExtensionTok{Testing}\NormalTok{ Project Test Suite}
    \ExtensionTok{......}\NormalTok{                                                              6 / 6 (100%)}

    \ExtensionTok{Time}\NormalTok{: 65 ms, Memory: 4.00MB}

    \ExtensionTok{OK}\NormalTok{ (6 tests, 6 assertions)}
\end{Highlighting}
\end{Shaded}

\hypertarget{configuring-testing-reports-project-test04}{%
\section{\texorpdfstring{Configuring testing reports (project
\texttt{test04})}{Configuring testing reports (project test04)}}\label{configuring-testing-reports-project-test04}}

In additional to instant reporting at the command line, PHPUnit offers
several different methods of recording test output text-based files.

PHPUnit (when run with Symfony's Simple-PHPUnit) reads configuration
settings from file \texttt{phpunit.dist.xml}. Most of the contents of
this file (created as part of the installation of the Simple-PHPUnit
package) can be left as their defaults. But we can add a range of logs
by adding the following `logging' element in this file.

Many projects follow a convention where testing output files are stored
in a directory named \texttt{build}. We'll follow that convention below
- but of course change the name and location of the test logs to
anywhere you want.

Add the following into file \texttt{phpunit.dist.xml}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{<logging>}
        \KeywordTok{<log}\OtherTok{ type=}\StringTok{"junit"}\OtherTok{ target=}\StringTok{"./build/logfile.xml"}\KeywordTok{/>}
        \KeywordTok{<log}\OtherTok{ type=}\StringTok{"testdox-html"}\OtherTok{ target=}\StringTok{"./build/testdox.html"}\KeywordTok{/>}
        \KeywordTok{<log}\OtherTok{ type=}\StringTok{"testdox-text"}\OtherTok{ target=}\StringTok{"./build/testdox.txt"}\KeywordTok{/>}
        \KeywordTok{<log}\OtherTok{ type=}\StringTok{"tap"}\OtherTok{ target=}\StringTok{"./build/logfile.tap"}\KeywordTok{/>}
    \KeywordTok{</logging>}
\end{Highlighting}
\end{Shaded}

Figure \ref{build_contents} shows a screenshot of the contents of the
created \texttt{/build} directory after Simple-PHPUnit has been run.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/e0508a47b2041a4c34c618a5a380b62a392b0dc4.png}
\caption{Contents of directory \texttt{/build}. \label{build_contents}}
\end{figure}

The \texttt{.txt} file version of \textbf{testdox} is perhaps the
simplest output - showing \texttt{{[}x{]}} next to a passed method and
\texttt{{[}\ {]}} for a test that didn't pass. The text output turns the
test method names into more English-like sentences:

\begin{verbatim}
    App\Test\Simple
     [x] One plus one equals two

    App\Util\Test\Calculator
     [x] Can create object
     [x] Add one and one
     [x] Additions with provider
\end{verbatim}

Another easy to understand logging format is the TAP (Test-Anywhere
Protocol). Although official deprecated by PHPUnit it still seems to
work. What is nice about the TAP format is that repeated invocations of
test methods iterating through a data-provider are enumerated, with the
values. So we can see how many times, and their successes, a method was
invoked with test data. This file is named (by our XML configuration
above) \texttt{logfile.tap}:

\begin{verbatim}
    TAP version 13
    ok 1 - App\Test\SimpleTest::testOnePlusOneEqualsTwo
    ok 2 - App\Util\Test\CalculatorTest::testCanCreateObject
    ok 3 - App\Util\Test\CalculatorTest::testAddOneAndOne
    ok 4 - App\Util\Test\CalculatorTest::testAdditionsWithProvider with data set #0 (1, 1, 2)
    ok 5 - App\Util\Test\CalculatorTest::testAdditionsWithProvider with data set #1 (2, 2, 4)
    ok 6 - App\Util\Test\CalculatorTest::testAdditionsWithProvider with data set #2 (0, 1, 1)
    1..6
\end{verbatim}

\hypertarget{testing-for-exceptions-project-test07}{%
\section{\texorpdfstring{Testing for exceptions (project
\texttt{test07})}{Testing for exceptions (project test07)}}\label{testing-for-exceptions-project-test07}}

If our code throws an \textbf{Exception} while a test is being executed,
and it was not caught, then we'll get an \textbf{Error} when we run our
test.

For example, let's add a \texttt{divide(...)} method to our utility
\texttt{Calculator} class:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ divide}\OtherTok{(}\KeywordTok{$n}\OtherTok{,} \KeywordTok{$divisor}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{if}\OtherTok{(}\KeywordTok{empty}\OtherTok{(}\KeywordTok{$divisor}\OtherTok{))}\NormalTok{\{}
            \KeywordTok{throw} \KeywordTok{new}\NormalTok{ \textbackslash{}}\KeywordTok{InvalidArgumentException}\OtherTok{(}\StringTok{"Divisor must be a number"}\OtherTok{);}
\NormalTok{        \}}

        \KeywordTok{return} \KeywordTok{$n}\NormalTok{ / }\KeywordTok{$divisor}\OtherTok{;}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

In the code above we are throwing an
\texttt{\textbackslash{}InvalidArgumentException} when our
\texttt{\$divisor} argument is empty (0, null etc.).

Let's write a valid test (1/1 = 1) in class \texttt{CalculatorTest}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testDivideOneAndOne}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$calculator}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Calculator}\OtherTok{();}
        \KeywordTok{$num1}\NormalTok{ = }\DecValTok{1}\OtherTok{;}
        \KeywordTok{$num2}\NormalTok{ = }\DecValTok{1}\OtherTok{;}
        \KeywordTok{$expectedResult}\NormalTok{ = }\DecValTok{1}\OtherTok{;}

        \CommentTok{// Act}
        \KeywordTok{$result}\NormalTok{ = }\KeywordTok{$calculator}\NormalTok{->divide}\OtherTok{(}\KeywordTok{$num1}\OtherTok{,} \KeywordTok{$num2}\OtherTok{);}

        \CommentTok{// Assert}
        \KeywordTok{$this}\NormalTok{->assertEquals}\OtherTok{(}\KeywordTok{$expectedResult}\OtherTok{,} \KeywordTok{$result}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

This should pass.

Now let's try to write a test for 1 divided by zero. Not knowing how to
deal with exceptions we might write something with a \texttt{fail(...)}
instead of an \texttt{assert...}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testDivideOneAndZero}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$calculator}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Calculator}\OtherTok{();}
        \KeywordTok{$num1}\NormalTok{ = }\DecValTok{1}\OtherTok{;}
        \KeywordTok{$num2}\NormalTok{ = }\DecValTok{0}\OtherTok{;}
        \KeywordTok{$expectedResult}\NormalTok{ = }\DecValTok{1}\OtherTok{;}

        \CommentTok{// Act}
        \KeywordTok{$result}\NormalTok{ = }\KeywordTok{$calculator}\NormalTok{->divide}\OtherTok{(}\KeywordTok{$num1}\OtherTok{,} \KeywordTok{$num2}\OtherTok{);}

        \CommentTok{// Assert - FAIL - should not get here!}
        \KeywordTok{$this}\NormalTok{->fail}\OtherTok{(}\StringTok{'should not have got here - divide by zero not permitted'}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

But when we run simple-phpunit we'll get an error since the (uncaught)
Exceptions is thrown before our \texttt{fail(...)} statement is reached:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{vendor/bin/simple-phpunit}
    \ExtensionTok{PHPUnit}\NormalTok{ 5.7.27 by Sebastian Bergmann and contributors.}

    \ExtensionTok{Warning}\NormalTok{:       Deprecated TAP test listener used}

    \ExtensionTok{Testing}\NormalTok{ Project Test Suite}
    \ExtensionTok{.........E}\NormalTok{                                                        10 / 10 (100%)}

    \ExtensionTok{Time}\NormalTok{: 1.21 seconds, Memory: 10.00MB}

    \ExtensionTok{There}\NormalTok{ was 1 error:}

    \ExtensionTok{1}\NormalTok{) }\ExtensionTok{App}\NormalTok{\textbackslash{}Util\textbackslash{}Test\textbackslash{}CalculatorTest::testDivideOneAndZero}
    \ExtensionTok{InvalidArgumentException}\NormalTok{: Divisor must be a number}

    \ExtensionTok{.../src/Util}\NormalTok{/Calculator.php:}\ExtensionTok{21}
    \ExtensionTok{/Users/matt/Library/Mobile}\NormalTok{ Documents/com~apple~CloudDocs/11_Books/symfony/php-symfony4-book-codes/part-testing/test07_exceptions/tests/Util/CalculatorTest.php:84}

    \ExtensionTok{ERRORS}\NormalTok{!}
    \ExtensionTok{Tests}\NormalTok{: 10, Assertions: 9, Errors: 1.}
\end{Highlighting}
\end{Shaded}

And our logs will confirm the failure:

\begin{verbatim}
    App\Tests\Controller\DefaultController
     [x] Homepage response code okay
     [x] Homepage content contains hello world

    App\Test\Simple
     [x] One plus one equals two

    App\Util\Test\Calculator
     [x] Can create object
     [x] Add one and one
     [x] Additions with provider
     [x] Divide one and one
     [ ] Divide one and zero
\end{verbatim}

\hypertarget{phpunit-expectexception...}{%
\section{\texorpdfstring{PHPUnit
\texttt{expectException(...)}}{PHPUnit expectException(...)}}\label{phpunit-expectexception...}}

PHPUnit allows us to declare that we expect an exception - but we must
declare this \textbf{before} we invoke the method that will throw the
exception.

Here is our improved method, with \texttt{expectException(...)} and a
better \texttt{fail(...)} statement, that tells us which exception was
expected and not thrown:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testDivideOneAndZero}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$calculator}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Calculator}\OtherTok{();}
        \KeywordTok{$num1}\NormalTok{ = }\DecValTok{1}\OtherTok{;}
        \KeywordTok{$num2}\NormalTok{ = }\DecValTok{0}\OtherTok{;}
        \KeywordTok{$expectedResult}\NormalTok{ = }\DecValTok{1}\OtherTok{;}

        \CommentTok{// Expect exception - BEFORE you Act!}
        \KeywordTok{$this}\NormalTok{->expectException}\OtherTok{(}\NormalTok{\textbackslash{}}\KeywordTok{InvalidArgumentException}\NormalTok{::}\KeywordTok{class}\OtherTok{);}

        \CommentTok{// Act}
        \KeywordTok{$result}\NormalTok{ = }\KeywordTok{$calculator}\NormalTok{->divide}\OtherTok{(}\KeywordTok{$num1}\OtherTok{,} \KeywordTok{$num2}\OtherTok{);}

        \CommentTok{// Assert - FAIL - should not get here!}
        \KeywordTok{$this}\NormalTok{->fail}\OtherTok{(}\StringTok{"Expected exception \{\textbackslash{}InvalidArgumentException::class\} not thrown"}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Now all our tests pass:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{vendor/bin/simple-phpunit}
    \ExtensionTok{PHPUnit}\NormalTok{ 5.7.27 by Sebastian Bergmann and contributors.}

    \ExtensionTok{Warning}\NormalTok{:       Deprecated TAP test listener used}

    \ExtensionTok{Testing}\NormalTok{ Project Test Suite}
    \ExtensionTok{..........}\NormalTok{                                                        10 / 10 (100%)}
\end{Highlighting}
\end{Shaded}

\hypertarget{phpunit-annotation-comment-expectedexception}{%
\section{\texorpdfstring{PHPUnit annotation comment
\texttt{@expectedException}}{PHPUnit annotation comment @expectedException}}\label{phpunit-annotation-comment-expectedexception}}

PHPUnit allows us to use an annotation comment to state that we expect
an exception to be thrown during the execution of a particular test.
This is a nice way to keep our test logic simple.

Since annotation comments are declared immediately \textbf{before} the
method, some programmers (I do!) prefer the annotation way of declaring
that we expect a test method to result in an exception being thrown:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@expectedException}\CommentTok{ }\AnnotationTok{\textbackslash{}InvalidArgumentException}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testDivideOneAndZeroAnnotation}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$calculator}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Calculator}\OtherTok{();}
        \KeywordTok{$num1}\NormalTok{ = }\DecValTok{1}\OtherTok{;}
        \KeywordTok{$num2}\NormalTok{ = }\DecValTok{0}\OtherTok{;}

        \CommentTok{// Act}
        \KeywordTok{$result}\NormalTok{ = }\KeywordTok{$calculator}\NormalTok{->divide}\OtherTok{(}\KeywordTok{$num1}\OtherTok{,} \KeywordTok{$num2}\OtherTok{);}

        \CommentTok{// Assert - FAIL - should not get here!}
        \KeywordTok{$this}\NormalTok{->fail}\OtherTok{(}\StringTok{"Expected exception \{\textbackslash{}InvalidArgumentException::class\} not thrown"}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

NOTE: You must ensure the exception class is fully namespaced in the
annotation comment (no \texttt{::class} shortcuts!).

\hypertarget{testing-for-custom-exception-classes}{%
\section{Testing for custom Exception
classes}\label{testing-for-custom-exception-classes}}

While the built-in PHP Exceptions are find for simple projects, it is
very useful to create custom exception classes for each project you
create. Working with, and testing for, objects of custom Exception
classes is very simple in Symfony:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create your custom Exception class in \texttt{/src/Exception}, in the
  namespace \texttt{App\textbackslash{}Exception}. For example you might
  create a custom Exception class for an invalid Currency in a money
  exchange system as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{// file: /src/Exception/UnknownCurrencyException.php}

    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}}\KeywordTok{Exception}\OtherTok{;}

    \KeywordTok{use} \KeywordTok{Exception}\OtherTok{;}

    \KeywordTok{class}\NormalTok{ UnknownCurrencyException }\KeywordTok{extends} \KeywordTok{Exception}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function} \FunctionTok{__construct}\OtherTok{(}\KeywordTok{$message}\NormalTok{ = }\KeywordTok{null}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{if}\OtherTok{(}\KeywordTok{empty}\OtherTok{(}\KeywordTok{$message}\OtherTok{))}\NormalTok{ \{}
                \KeywordTok{$message}\NormalTok{ = }\StringTok{'Unknown currency'}\OtherTok{;}
\NormalTok{            \}}
\NormalTok{            parent::}\FunctionTok{__construct}\OtherTok{(}\KeywordTok{$message}\OtherTok{);}
\NormalTok{        \}}

\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}
\item
  Ensure your source code throws an instance of your custom Exception.
  For example:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{use}\NormalTok{ App\textbackslash{}}\KeywordTok{Exception}\NormalTok{\textbackslash{}UnknownCurrencyException}\OtherTok{;}

    \StringTok{...}

    \KeywordTok{public} \KeywordTok{function}\NormalTok{ euroOnlyExchange}\OtherTok{(}\KeywordTok{$currency}\OtherTok{)}
\NormalTok{    \{}
        \KeywordTok{$currency}\NormalTok{ = }\FunctionTok{strtolower}\OtherTok{(}\KeywordTok{$currency}\OtherTok{);}
        \KeywordTok{if}\OtherTok{(}\StringTok{'euro'}\NormalTok{ != }\KeywordTok{$currency}\OtherTok{))}\NormalTok{\{}
            \KeywordTok{throw} \KeywordTok{new}\NormalTok{ UnknownCurrencyException}\OtherTok{();}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}
\item
  In your tests your must check for the expected custom Exception class.
  E.g. using the annotation approach:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@expectedException}\CommentTok{ App}\AnnotationTok{\textbackslash{}Exception\textbackslash{}UnknownCurrencyException}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testInvalidCurrencyException}\OtherTok{()}
\NormalTok{    \{}
        \StringTok{...}\NormalTok{ code here to trigger }\KeywordTok{exception}\NormalTok{ to be thrown }\StringTok{...}

        \CommentTok{// Assert - FAIL - should not get here!}
        \KeywordTok{$this}\NormalTok{->fail}\OtherTok{(}\StringTok{"Expected exception \{\textbackslash{}Exception\} not thrown"}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\textbf{NOTE}: You have to provide the full namespace in the annotation
comment,
i.e.~\texttt{App\textbackslash{}Exception\textbackslash{}UnknownCurrencyException}.
Having a \texttt{use} statement above will not work properly

\hypertarget{checking-types-with-assertions}{%
\section{Checking Types with
assertions}\label{checking-types-with-assertions}}

Sometimes we need to check the \textbf{type} of a variable. We can do
this using the \texttt{assertInternalType(...)} method.

For example:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$result}\NormalTok{ = }\DecValTok{1}\NormalTok{ + }\DecValTok{2}\OtherTok{;}

    \CommentTok{// check result is an interger}
    \KeywordTok{$this}\NormalTok{->assertInternalType}\OtherTok{(}\StringTok{'int'}\OtherTok{,} \KeywordTok{$result}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

Learn more in the PHPUnit documentation:

\begin{itemize}
\tightlist
\item
  \url{https://phpunit.de/manual/6.5/en/appendixes.assertions.html\#appendixes.assertions.assertInternalType}
\end{itemize}

\hypertarget{same-vs.-equals}{%
\section{Same vs.~Equals}\label{same-vs.-equals}}

There are 2 similar assertions in PHPUnit:

\begin{itemize}
\tightlist
\item
  \texttt{assertSame(...)}: works like the \texttt{===} identity
  operator in PHP
\item
  \texttt{assertEquals(...)}: works like the \texttt{==} comparison
\end{itemize}

When we want to know if the values inside (or referred to) by two
variables or expressions are equivalent, we use the weaker \texttt{==}
or \texttt{assertEquals(...)}. For example, do two variables refer to
object-instances that contain the same property values, but may be
different objects in memory.

When we want to know if the values inside (or referred to) by two
variables are exactly the same, we use the stronger \texttt{===} or
\texttt{assertSame(...)}. For example, do two variables both refer to
the same object in memory.

The use of \texttt{assertSame(...)} is useful in unit testing to check
the types of values - since the value returned by a function must refer
to the same numeric or string (or whatever) literal. So we could write
another way to test that a function returns an integer result as
follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$expectedResult}\NormalTok{ = }\DecValTok{3}\OtherTok{;}
    \KeywordTok{$result}\NormalTok{ = }\DecValTok{1}\NormalTok{ + }\DecValTok{2}\OtherTok{;}

    \CommentTok{// check result is an interger}
    \KeywordTok{$this}\NormalTok{->assertSame}\OtherTok{(}\KeywordTok{$expectedResult}\OtherTok{,} \KeywordTok{$result}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

\hypertarget{code-coverage-and-xdebug}{%
\chapter{Code coverage and xDebug}\label{code-coverage-and-xdebug}}

\hypertarget{code-coverage}{%
\section{Code Coverage}\label{code-coverage}}

It's good to know how \textbf{much} of our code we have tested, e.g.~how
many methods or logic paths (e.g.~if-else- branches) we have and have
not tested.

Code coverage reports can be text, XML or nice-looking HTML. See Figure
\ref{default_page} for a screenshot of an HTML coverage report for a
\texttt{Util} class with 4 methods. We can see that while \texttt{add}
and \texttt{divide} have been fully (100\%) covered by tests, methods
\texttt{subtract} and \texttt{process} are insufficiently covered.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/093ea6f2954df63fe293cf27e03e06b550d6c326.png}
\caption{Screenshot of HTML coverage report. \label{coverage_html}}
\end{figure}

This is known as code coverage, and easily achieved by:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adding a line to the PHPUnit configuration file (\texttt{php.ini})
\item
  Ensuring the \textbf{xDebug} PHP debugger is installed and activated
\end{enumerate}

See Appendix \ref{appendix_xdebug} for these stesp.

\hypertarget{generating-code-coverage-html-report}{%
\section{Generating Code Coverage HTML
report}\label{generating-code-coverage-html-report}}

Add the following element as a child to the
\texttt{\textless{}logging\textgreater{}} element in file
\texttt{phpuninit.xml.dist}:

\begin{Shaded}
\begin{Highlighting}[]
        \KeywordTok{<log}\OtherTok{ type=}\StringTok{"coverage-html"}\OtherTok{ target=}\StringTok{"./build/report"}\KeywordTok{/>}
\end{Highlighting}
\end{Shaded}

So the full content of the \texttt{\textless{}logging\textgreater{}}
element is now:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{<logging>}
        \KeywordTok{<log}\OtherTok{ type=}\StringTok{"coverage-html"}\OtherTok{ target=}\StringTok{"./build/report"}\KeywordTok{/>}
        \KeywordTok{<log}\OtherTok{ type=}\StringTok{"junit"}\OtherTok{ target=}\StringTok{"./build/logfile.xml"}\KeywordTok{/>}
        \KeywordTok{<log}\OtherTok{ type=}\StringTok{"testdox-html"}\OtherTok{ target=}\StringTok{"./build/testdox.html"}\KeywordTok{/>}
        \KeywordTok{<log}\OtherTok{ type=}\StringTok{"testdox-text"}\OtherTok{ target=}\StringTok{"./build/testdox.txt"}\KeywordTok{/>}
        \KeywordTok{<log}\OtherTok{ type=}\StringTok{"tap"}\OtherTok{ target=}\StringTok{"./build/logfile.tap"}\KeywordTok{/>}
    \KeywordTok{</logging>}
\end{Highlighting}
\end{Shaded}

Now when you run \texttt{vendor/bin/simple-phpunit} you'll see a new
directory \texttt{report} inside \texttt{/build}. Open the
\texttt{index.html} file in \texttt{/build/report} and you'll see the
main page of your coverage report. See Figure \ref{build_files}.

\begin{figure}
\centering
\includegraphics[width=0.75\textwidth,height=\textheight]{./tex2pdf.-65f13e14688ab55b/6d9bd18e008151ecb77d2f17729d4c6cfe5c431e.png}
\caption{Build files showing \texttt{index.html} in
\texttt{/build/report}. \label{build_files}}
\end{figure}

\hypertarget{tailoring-the-whitelist}{%
\section{Tailoring the `whitelist'}\label{tailoring-the-whitelist}}

PHPUnit decides which soruces file to analyse and build coverage reports
for by using a `whitelist' - i.e.~a list of just those files and/or
directories that we are interested in at this point in time. The
whitelist is inside the \texttt{\textless{}filter\textgreater{}} element
in PHPUnity configuration file `phpunit.xml.dist'.

the default whitelist is \texttt{./src} - i.e \textbf{all} files in our
source directory. But, for example, this will include Kernel, which we
generally don't touch. So if you want to go \textbf{GREEN} for
everything in your coverage report, then you can list only those
directories inside \texttt{/src} that you are interested in.

For our example above we were working with classes in \texttt{/src/Util}
and \texttt{src/Controller}, so that's what we can list in our
`whitelist'. You can always `disable' lines in XML by wrapping an XML
command around them \texttt{\textless{}-\/-\ ...\ -\/-\textgreater{}},
which we've done below to the default \texttt{./src/} white list
element:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{<filter>}
        \KeywordTok{<whitelist>}
            \CommentTok{<!--}
\CommentTok{                // ignore this element for now ...}
\CommentTok{                <directory>./src/</directory>}
\CommentTok{            -->}
            \KeywordTok{<directory>}\NormalTok{./src/Controller}\KeywordTok{</directory>}
            \KeywordTok{<directory>}\NormalTok{./src/Util}\KeywordTok{</directory>}
        \KeywordTok{</whitelist>}
    \KeywordTok{</filter>}
\end{Highlighting}
\end{Shaded}

\hypertarget{web-testing}{%
\chapter{Web testing}\label{web-testing}}

\hypertarget{testing-controllers-with-webtestcase-project-test05}{%
\section{\texorpdfstring{Testing controllers with \texttt{WebTestCase}
(project
\texttt{test05})}{Testing controllers with WebTestCase (project test05)}}\label{testing-controllers-with-webtestcase-project-test05}}

Symfony provides a package for simulating web clients so we can
(functionally) test the contents of HTTP Responses output by our
controllers.

First we need to add 2 packages to the project development environment:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{composer}\NormalTok{ req --dev browser-kit css-selector}
\end{Highlighting}
\end{Shaded}

Note - these next steps assume your project has Twig, annotations and
the Symfony maker packages available, so you may need to add these to
your project as well:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{composer}\NormalTok{ req twig annotations make}
\end{Highlighting}
\end{Shaded}

Let's make a new \texttt{DefaultController} class:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{php}\NormalTok{ bin/console make:controller Default}
\end{Highlighting}
\end{Shaded}

Let's edit the generated template to include the message
\texttt{Hello\ World}. Edit \texttt{/templates/default/index.html.twig}:

\begin{verbatim}
    {% extends 'base.html.twig' %}

    {% block body %}
    <h1>Welcome</h1>

    Hello World from the default controller
    {% endblock %}
\end{verbatim}

Let's also set the URL to simply \texttt{/} for this route in
\texttt{/src/Controller/DefaultController.php}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{class}\NormalTok{ DefaultController }\KeywordTok{extends}\NormalTok{ Controller}
\NormalTok{    \{}
        \CommentTok{/**}
\CommentTok{         * }\AnnotationTok{@Route("/",}\CommentTok{ name="default")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\StringTok{'default/index.html.twig'}\OtherTok{,} \OtherTok{[}
                \StringTok{'controller_name'}\NormalTok{ => }\StringTok{'DefaultController'}\OtherTok{,}
            \OtherTok{]);}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

If we run a web server and visit the home page we should see our `hello
world' message in a browser - see Figure \ref{homepage}.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/a97f353efafa2faa98064075e63812a2b1cec288.png}
\caption{Contents of directory \texttt{/build}. \label{homepage}}
\end{figure}

\hypertarget{automating-a-test-for-the-home-page-contents}{%
\section{Automating a test for the home page
contents}\label{automating-a-test-for-the-home-page-contents}}

Let's write a test class for our \texttt{DefaultController} class. So we
create a new test class
\texttt{/tests/Controller/DefaultControllerTest.php}. We'll write 2
tests, one to check that we get a 200 OK HTTP success code when we try
to request \texttt{/}, and secondly that the content received in the
HTTP Reponse contains the text \texttt{Hello\ World}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Tests\textbackslash{}Controller}\OtherTok{;}

    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Bundle\textbackslash{}FrameworkBundle\textbackslash{}Test\textbackslash{}WebTestCase}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Response}\OtherTok{;}

    \KeywordTok{class}\NormalTok{ DefaultControllerTest }\KeywordTok{extends}\NormalTok{ WebTestCase}
\NormalTok{    \{}
        \CommentTok{// methods go here}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

We see our class must extend \texttt{WebTestCase} from package
\texttt{Symfony\textbackslash{}Bundle\textbackslash{}FrameworkBundle\textbackslash{}Test\textbackslash{}},
and also makes use of the Symfony Foundation \texttt{Response} class.

Our method to test for a 200 OK Reponse code is as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testHomepageResponseCodeOkay}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$url}\NormalTok{ = }\StringTok{'/'}\OtherTok{;}
        \KeywordTok{$httpMethod}\NormalTok{ = }\StringTok{'GET'}\OtherTok{;}
        \KeywordTok{$client}\NormalTok{ = }\KeywordTok{static}\NormalTok{::createClient}\OtherTok{();}

        \CommentTok{// Assert}
        \KeywordTok{$client}\NormalTok{->request}\OtherTok{(}\KeywordTok{$httpMethod}\OtherTok{,} \KeywordTok{$url}\OtherTok{);}

        \CommentTok{// Assert}
        \KeywordTok{$this}\NormalTok{->assertSame}\OtherTok{(}
\NormalTok{            Response::}\KeywordTok{HTTP_OK}\OtherTok{,}
            \KeywordTok{$client}\NormalTok{->getResponse}\OtherTok{()}\NormalTok{->getStatusCode}\OtherTok{()}
        \OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

We see how a web client object \texttt{\$client} is created and makes a
GET requerst to \texttt{/}. We see how we can interrogate the contents
of the HTTP Response recevied using the \texttt{getResponse()} method,
and within that we can extract the status code, and compare with the
class constant \texttt{HTTP\_OK} (200).

Here is our method to test for a 200 OK Reponse code is as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testHomepageContentContainsHelloWorld}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$url}\NormalTok{ = }\StringTok{'/'}\OtherTok{;}
        \KeywordTok{$httpMethod}\NormalTok{ = }\StringTok{'GET'}\OtherTok{;}
        \KeywordTok{$client}\NormalTok{ = }\KeywordTok{static}\NormalTok{::createClient}\OtherTok{();}
        \KeywordTok{$searchText}\NormalTok{ = }\StringTok{'Hello World'}\OtherTok{;}

        \CommentTok{// Act}
        \KeywordTok{$client}\NormalTok{->request}\OtherTok{(}\KeywordTok{$httpMethod}\OtherTok{,} \KeywordTok{$url}\OtherTok{);}

        \CommentTok{// Assert}
        \KeywordTok{$this}\NormalTok{->assertContains}\OtherTok{(}
            \KeywordTok{$searchText}\OtherTok{,}
            \KeywordTok{$client}\NormalTok{->getResponse}\OtherTok{()}\NormalTok{->getContent}\OtherTok{()}
        \OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

We see how we can use the \texttt{assertContains} string method to
search for the string \texttt{Hello\ World} in the content of the HTTP
Response.

When we run Simple-PHPUnit we can see success both from the full-stops
at the CLI, and in our log files, e.g.:

\begin{verbatim}
    App\Tests\Controller\DefaultController
     [x] Homepage response code okay
     [x] Homepage content contains hello world

    ...
\end{verbatim}

\hypertarget{normalise-content-to-lowercase-project-test06}{%
\section{\texorpdfstring{Normalise content to lowercase (project
\texttt{test06})}{Normalise content to lowercase (project test06)}}\label{normalise-content-to-lowercase-project-test06}}

I lost 30 minutes thinking my web app wasn't working! This was due to
the difference between \texttt{Hello\ world} and \texttt{Hello\ World}
(\texttt{w} vs \texttt{W}).

This kind of problem can be avoided if we \textbf{normalise} the content
from the Response, e.g.~making all letters \textbf{lower-case}. This
only makes sense if you are happy (at this stage) to not worry about the
case of text content in your pages (you could always write some specific
spelling / grammar checker tests for that \ldots{})

The solution is to use the built-in PHP function \texttt{strtolower()}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testHomepageContentContainsHelloWorld}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$url}\NormalTok{ = }\StringTok{'/'}\OtherTok{;}
        \KeywordTok{$httpMethod}\NormalTok{ = }\StringTok{'GET'}\OtherTok{;}
        \KeywordTok{$client}\NormalTok{ = }\KeywordTok{static}\NormalTok{::createClient}\OtherTok{();}
        \KeywordTok{$searchText}\NormalTok{ = }\StringTok{'Hello World'}\OtherTok{;}

        \CommentTok{// Act}
        \KeywordTok{$client}\NormalTok{->request}\OtherTok{(}\KeywordTok{$httpMethod}\OtherTok{,} \KeywordTok{$url}\OtherTok{);}
        \KeywordTok{$content}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->getResponse}\OtherTok{()}\NormalTok{->getContent}\OtherTok{();}

        \CommentTok{// to lower case}
        \KeywordTok{$searchTextLowerCase}\NormalTok{ = }\FunctionTok{strtolower}\OtherTok{(}\KeywordTok{$searchText}\OtherTok{);}
        \KeywordTok{$contentLowerCase}\NormalTok{ = }\FunctionTok{strtolower}\OtherTok{(}\KeywordTok{$content}\OtherTok{);}

        \CommentTok{// Assert}
        \KeywordTok{$this}\NormalTok{->assertContains}\OtherTok{(}
            \KeywordTok{$searchTextLowerCase}\OtherTok{,}
            \KeywordTok{$contentLowerCase}
        \OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{test-multiple-pages-with-a-data-provider}{%
\section{Test multiple pages with a data
provider}\label{test-multiple-pages-with-a-data-provider}}

Avoid duplicating code when only the values change, by writing a testing
method fed by arrays of test input / expected values from a data
provider method:

\begin{Shaded}
\begin{Highlighting}[]

    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@dataProvider}\CommentTok{ basicPagesTextProvider}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testPublicPagesContainBasicText}\OtherTok{(}\KeywordTok{$url}\OtherTok{,} \KeywordTok{$exepctedLowercaseText}\OtherTok{)}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$httpMethod}\NormalTok{ = }\StringTok{'GET'}\OtherTok{;}
        \KeywordTok{$client}\NormalTok{ = }\KeywordTok{static}\NormalTok{::createClient}\OtherTok{();}

        \CommentTok{// Act}
        \KeywordTok{$client}\NormalTok{->request}\OtherTok{(}\KeywordTok{$httpMethod}\OtherTok{,} \KeywordTok{$url}\OtherTok{);}
        \KeywordTok{$content}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->getResponse}\OtherTok{()}\NormalTok{->getContent}\OtherTok{();}
        \KeywordTok{$statusCode}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->getResponse}\OtherTok{()}\NormalTok{->getStatusCode}\OtherTok{();}

        \CommentTok{// to lower case}
        \KeywordTok{$contentLowerCase}\NormalTok{ = }\FunctionTok{strtolower}\OtherTok{(}\KeywordTok{$content}\OtherTok{);}

        \CommentTok{// Assert - status code 200}
        \KeywordTok{$this}\NormalTok{->assertSame}\OtherTok{(}\NormalTok{Response::}\KeywordTok{HTTP_OK}\OtherTok{,} \KeywordTok{$statusCode}\OtherTok{);}

        \CommentTok{// Assert - expected content}
        \KeywordTok{$this}\NormalTok{->assertContains}\OtherTok{(}
            \KeywordTok{$exepctedLowercaseText}\OtherTok{,}
            \KeywordTok{$contentLowerCase}
        \OtherTok{);}
\NormalTok{    \}}

    \KeywordTok{public} \KeywordTok{function}\NormalTok{ basicPagesTextProvider}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{return} \OtherTok{[}
            \OtherTok{[}\StringTok{'/'}\OtherTok{,} \StringTok{'home page'}\OtherTok{],}
            \OtherTok{[}\StringTok{'/about'}\OtherTok{,} \StringTok{'about'}\OtherTok{],}
        \OtherTok{];}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{testing-links-project-test08}{%
\section{\texorpdfstring{Testing links (project
\texttt{test08})}{Testing links (project test08)}}\label{testing-links-project-test08}}

We can test links with our web crawler as follows:

\begin{itemize}
\item
  get reference to crawler object when you make the initial request

\begin{verbatim}
$httpMethod = 'GET';
$url = '/about';
$crawler = $client->request($httpMethod, $url);
\end{verbatim}
\item
  select a link with:

\begin{verbatim}
$linkText = 'login';
$link = $crawler->selectLink($linkText)->link();
\end{verbatim}
\item
  click the link with:

\begin{verbatim}
$client->click($link);
\end{verbatim}
\item
  then check the content of the new request

\begin{verbatim}
$content = $client->getResponse()->getContent();

// set $expectedText to what should in page when link has been followed ...
$this->assertContains(
    $exepctedText,
    $content
);
\end{verbatim}
\end{itemize}

For example, if we create a new `about' page Twig template
`/templates/default/about.html.twig':

\begin{verbatim}
    {% extends 'base.html.twig' %}

    {% block body %}
    <h1>About page</h1>

        <p>
            About this great website!
        </p>

    {% endblock %}
\end{verbatim}

and a \texttt{DefaultController} method to display this page when the
route matches \texttt{/about}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/about",}\CommentTok{ name="about")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ aboutAction}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{$template}\NormalTok{ = }\StringTok{'default/about.html.twig'}\OtherTok{;}
        \KeywordTok{$args}\NormalTok{ = }\OtherTok{[];}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

If we add to our base Twig template links to the homepage and the about,
in template \texttt{/templates/base.html.twig}:

\begin{verbatim}
    <!DOCTYPE html>
    <html>
        <head>
            <meta charset="UTF-8">
            <title>{% block title %}Welcome!{% endblock %}</title>
            {% block stylesheets %}{% endblock %}
        </head>
        <body>

        <nav>
            <ul>
                <li>
                    <a href="{{ url('homepage') }}">home</a>
                </li>
                <li>
                    <a href="{{ url('about') }}">about</a>
                </li>
            </ul>
        </nav>

            {% block body %}{% endblock %}
            {% block javascripts %}{% endblock %}
        </body>
    </html>
\end{verbatim}

We can now write a test method to:

\begin{itemize}
\item
  request the homepage \texttt{/}
\item
  select and click the \texttt{about} link
\item
  test that the content of the new response is the `about' page if it
  contains `about page'
\end{itemize}

Here is our test method:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testHomePageLinkToAboutWorks}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$url}\NormalTok{ = }\StringTok{'/'}\OtherTok{;}
        \KeywordTok{$httpMethod}\NormalTok{ = }\StringTok{'GET'}\OtherTok{;}
        \KeywordTok{$client}\NormalTok{ = }\KeywordTok{static}\NormalTok{::createClient}\OtherTok{();}
        \KeywordTok{$searchText}\NormalTok{ = }\StringTok{'about page'}\OtherTok{;}
        \KeywordTok{$linkText}\NormalTok{ = }\StringTok{'about'}\OtherTok{;}

        \CommentTok{// Act}
        \KeywordTok{$crawler}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->request}\OtherTok{(}\KeywordTok{$httpMethod}\OtherTok{,} \KeywordTok{$url}\OtherTok{);}
        \KeywordTok{$link}\NormalTok{ = }\KeywordTok{$crawler}\NormalTok{->selectLink}\OtherTok{(}\KeywordTok{$linkText}\OtherTok{)}\NormalTok{->}\FunctionTok{link}\OtherTok{();}
        \KeywordTok{$client}\NormalTok{->click}\OtherTok{(}\KeywordTok{$link}\OtherTok{);}
        \KeywordTok{$content}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->getResponse}\OtherTok{()}\NormalTok{->getContent}\OtherTok{();}

        \CommentTok{// to lower case}
        \KeywordTok{$searchTextLowerCase}\NormalTok{ = }\FunctionTok{strtolower}\OtherTok{(}\KeywordTok{$searchText}\OtherTok{);}
        \KeywordTok{$contentLowerCase}\NormalTok{ = }\FunctionTok{strtolower}\OtherTok{(}\KeywordTok{$content}\OtherTok{);}

        \CommentTok{// Assert}
        \KeywordTok{$this}\NormalTok{->assertContains}\OtherTok{(}\KeywordTok{$searchTextLowerCase}\OtherTok{,} \KeywordTok{$contentLowerCase}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{issue-with-routes-that-end-with-a-forward-slash}{%
\section{\texorpdfstring{Issue with routes that end with a forward slash
\texttt{/}}{Issue with routes that end with a forward slash /}}\label{issue-with-routes-that-end-with-a-forward-slash}}

Often we write (or generate) a controller that adds URL and route name
\textbf{prefixes} - by writing a route annotation commend immediately
before the class declaration. For example, look at the first 2 routes of
this simple calculator class:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * controller for calculator functions}
\CommentTok{     *}
\CommentTok{     * }\AnnotationTok{@Route("/calc",}\CommentTok{ name="calc_")}
\CommentTok{     */}
    \KeywordTok{class}\NormalTok{ CalcController }\KeywordTok{extends}\NormalTok{ Controller}
\NormalTok{    \{}
        \CommentTok{/**}
\CommentTok{         * home page for calc pages}
\CommentTok{         * }\AnnotationTok{@Route("/",}\CommentTok{ name="home")}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ index}\OtherTok{()}
\NormalTok{        \{}
            \KeywordTok{$template}\NormalTok{ = }\StringTok{'calc/index.html.twig'}\OtherTok{;}
            \KeywordTok{$args}\NormalTok{ = }\OtherTok{[];}
            \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\KeywordTok{$template}\OtherTok{,} \KeywordTok{$args}\OtherTok{);}
\NormalTok{        \}}

        \CommentTok{/**}
\CommentTok{         * process the calc stuff}
\CommentTok{         *}
\CommentTok{         * }\AnnotationTok{@Route("/process",}\CommentTok{ name="process")}
\CommentTok{         *}
\CommentTok{         * }\AnnotationTok{@param}\CommentTok{ }\CommentVarTok{Request}\CommentTok{ $request}
\CommentTok{         * }\AnnotationTok{@return}\CommentTok{ }\AnnotationTok{\textbackslash{}Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Response}
\CommentTok{         */}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ processAction}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}
\NormalTok{        \{}
            \StringTok{...}
\end{Highlighting}
\end{Shaded}

However, a consequence of this is that often the index route for this
controller will be defined as having a trailing forward slash
\texttt{/}. For example look at this route list:

\begin{verbatim}
    $ php bin/console debug:router
     ------------------ -------- -------- ------ --------------------------
      Name               Method   Scheme   Host   Path
     ------------------ -------- -------- ------ --------------------------
      calc_home          ANY      ANY      ANY    /calc/
      calc_process       ANY      ANY      ANY    /calc/process
\end{verbatim}

As we can see the home calculator page URL route is `/calc/'. When
running the site with a server and visiting this page with a web browser
client, the server will usually simply redirect \texttt{/calc/} to
\texttt{/calc} if the initial request doesn't match any routes. However,
when \textbf{controller testing} such controllers if there is not a
complete match between the URL being tested and the route pattern, the
test will fail.

For example, a test in this form will \textbf{FAIL} for the route
\texttt{/calc/} as defined above:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testExchangePage}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{$httpMethod}\NormalTok{ = }\StringTok{'GET'}\OtherTok{;}
        \KeywordTok{$url}\NormalTok{ = }\StringTok{'/calc'}\OtherTok{;}
        \KeywordTok{$client}\NormalTok{ = }\KeywordTok{static}\NormalTok{::createClient}\OtherTok{();}
        \KeywordTok{$client}\NormalTok{->request}\OtherTok{(}\KeywordTok{$httpMethod}\OtherTok{,} \KeywordTok{$url}\OtherTok{);}
        \KeywordTok{$this}\NormalTok{->assertSame}\OtherTok{(}\NormalTok{Response::}\KeywordTok{HTTP_OK}\OtherTok{,} \KeywordTok{$client}\NormalTok{->getResponse}\OtherTok{()}\NormalTok{->getStatusCode}\OtherTok{());}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{solution-1-ensure-url-pattern-in-test-method-exactly-matches-router-url-pattern}{%
\subsection{Solution 1: Ensure url pattern in test method exactly
matches router url
pattern}\label{solution-1-ensure-url-pattern-in-test-method-exactly-matches-router-url-pattern}}

One solution to this problem is to ensure the URL in our test method
exactly matches the URL in the applications router. So for our
calculator home page we need to ensure the URL passed to the client ends
with this trailing forward slash \texttt{/} character":

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testExchangePage}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{$httpMethod}\NormalTok{ = }\StringTok{'GET'}\OtherTok{;}
        \KeywordTok{$url}\NormalTok{ = }\StringTok{'/calc/'}\OtherTok{;} \CommentTok{// <<<<<<<<<<<<<<<<<<<<< /calc/}
        \KeywordTok{$client}\NormalTok{ = }\KeywordTok{static}\NormalTok{::createClient}\OtherTok{();}
        \KeywordTok{$client}\NormalTok{->request}\OtherTok{(}\KeywordTok{$httpMethod}\OtherTok{,} \KeywordTok{$url}\OtherTok{);}
        \KeywordTok{$this}\NormalTok{->assertSame}\OtherTok{(}\NormalTok{Response::}\KeywordTok{HTTP_OK}\OtherTok{,} \KeywordTok{$client}\NormalTok{->getResponse}\OtherTok{()}\NormalTok{->getStatusCode}\OtherTok{());}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{solution-2-instruct-client-to-follow-redirects}{%
\subsection{Solution 2: Instruct client to `follow
redirects'}\label{solution-2-instruct-client-to-follow-redirects}}

An alternative solution is to instruct our tester's web crawler client
to \textbf{follow redirects}, so that the request is re-processed if the
request with no trailing forward slash \texttt{/} failed:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testExchangePage}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{$httpMethod}\NormalTok{ = }\StringTok{'GET'}\OtherTok{;}
        \KeywordTok{$url}\NormalTok{ = }\StringTok{'/calc'}\OtherTok{;}
        \KeywordTok{$client}\NormalTok{ = }\KeywordTok{static}\NormalTok{::createClient}\OtherTok{();}
        \KeywordTok{$client}\NormalTok{->followRedirects}\OtherTok{(}\KeywordTok{true}\OtherTok{);} \CommentTok{// <<<<<<<<<<<<<<<< follow redirects}
        \KeywordTok{$client}\NormalTok{->request}\OtherTok{(}\KeywordTok{$httpMethod}\OtherTok{,} \KeywordTok{$url}\OtherTok{);}
        \KeywordTok{$this}\NormalTok{->assertSame}\OtherTok{(}\NormalTok{Response::}\KeywordTok{HTTP_OK}\OtherTok{,} \KeywordTok{$client}\NormalTok{->getResponse}\OtherTok{()}\NormalTok{->getStatusCode}\OtherTok{());}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{testing-web-forms}{%
\chapter{Testing web forms}\label{testing-web-forms}}

\hypertarget{testing-forms-project-test09}{%
\section{\texorpdfstring{Testing forms (project
\texttt{test09})}{Testing forms (project test09)}}\label{testing-forms-project-test09}}

Testing forms is similar to testing links, in that we need to get a
reference to the form (via its submit button), then insert out data,
then submit the form, and examine the content of the new response
received after the form submission.

Assume we have a Calculator class as follows in
\texttt{/src/Util/Calculator.php}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Util}\OtherTok{;}

    \KeywordTok{class}\NormalTok{ Calculator}
\NormalTok{    \{}
        \KeywordTok{public} \KeywordTok{function}\NormalTok{ add}\OtherTok{(}\KeywordTok{$n1}\OtherTok{,} \KeywordTok{$n2}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{return} \KeywordTok{$n1}\NormalTok{ + }\KeywordTok{$n2}\OtherTok{;}
\NormalTok{        \}}

        \KeywordTok{public} \KeywordTok{function}\NormalTok{ subtract}\OtherTok{(}\KeywordTok{$n1}\OtherTok{,} \KeywordTok{$n2}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{return} \KeywordTok{$n1}\NormalTok{ - }\KeywordTok{$n2}\OtherTok{;}
\NormalTok{        \}}

        \KeywordTok{public} \KeywordTok{function}\NormalTok{ divide}\OtherTok{(}\KeywordTok{$n}\OtherTok{,} \KeywordTok{$divisor}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{if}\OtherTok{(}\KeywordTok{empty}\OtherTok{(}\KeywordTok{$divisor}\OtherTok{))}\NormalTok{\{}
                \KeywordTok{throw} \KeywordTok{new}\NormalTok{ \textbackslash{}}\KeywordTok{InvalidArgumentException}\OtherTok{(}\StringTok{"Divisor must be a number"}\OtherTok{);}
\NormalTok{            \}}

            \KeywordTok{return} \KeywordTok{$n}\NormalTok{ / }\KeywordTok{$divisor}\OtherTok{;}
\NormalTok{        \}}

        \KeywordTok{public} \KeywordTok{function}\NormalTok{ process}\OtherTok{(}\KeywordTok{$n1}\OtherTok{,} \KeywordTok{$n2}\OtherTok{,} \KeywordTok{$process}\OtherTok{)}
\NormalTok{        \{}
            \KeywordTok{switch}\OtherTok{(}\KeywordTok{$process}\OtherTok{)}\NormalTok{\{}
                \KeywordTok{case }\StringTok{'subtract'}\OtherTok{:}
                    \KeywordTok{return} \KeywordTok{$this}\NormalTok{->subtract}\OtherTok{(}\KeywordTok{$n1}\OtherTok{,} \KeywordTok{$n2}\OtherTok{);}
                    \KeywordTok{break}\OtherTok{;}
                \KeywordTok{case }\StringTok{'divide'}\OtherTok{:}
                    \KeywordTok{return} \KeywordTok{$this}\NormalTok{->divide}\OtherTok{(}\KeywordTok{$n1}\OtherTok{,} \KeywordTok{$n2}\OtherTok{);}
                    \KeywordTok{break}\OtherTok{;}
                \KeywordTok{case }\StringTok{'add'}\OtherTok{:}
                \KeywordTok{default:}
                    \KeywordTok{return} \KeywordTok{$this}\NormalTok{->add}\OtherTok{(}\KeywordTok{$n1}\OtherTok{,} \KeywordTok{$n2}\OtherTok{);}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Assume we also have a \texttt{CalculatorController} class in
\texttt{/src/Controller/}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{namespace}\NormalTok{ App\textbackslash{}Controller}\OtherTok{;}

    \KeywordTok{use}\NormalTok{ App\textbackslash{}Util\textbackslash{}Calculator}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}Routing\textbackslash{}Annotation\textbackslash{}Route}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Bundle\textbackslash{}FrameworkBundle\textbackslash{}Controller\textbackslash{}Controller}\OtherTok{;}
    \KeywordTok{use}\NormalTok{ Symfony\textbackslash{}Component\textbackslash{}HttpFoundation\textbackslash{}Request}\OtherTok{;}

    \KeywordTok{class}\NormalTok{ CalcController }\KeywordTok{extends}\NormalTok{ Controller}
\NormalTok{    \{}
        \StringTok{...}\NormalTok{ methods go here }\StringTok{...}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

There is a calculator home page that displays the form Twig template at
\texttt{/templates/calc/index.html.twig}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/calc",}\CommentTok{ name="calc_home")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ indexAction}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}\StringTok{'calc/index.html.twig'}\OtherTok{,} \OtherTok{[]);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

and a `process' controller method to recevied the form data (n1, n2,
operator) and process it: There is a calculator home page that displays
the form Twig template at \texttt{/templates/calc/index.html.twig}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/calc/process",}\CommentTok{ name="calc_process")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ processAction}\OtherTok{(}\NormalTok{Request }\KeywordTok{$request}\OtherTok{)}
\NormalTok{    \{}
        \CommentTok{// extract name values from POST data}
        \KeywordTok{$n1}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'num1'}\OtherTok{);}
        \KeywordTok{$n2}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'num2'}\OtherTok{);}
        \KeywordTok{$operator}\NormalTok{ = }\KeywordTok{$request}\NormalTok{->request->get}\OtherTok{(}\StringTok{'operator'}\OtherTok{);}

        \KeywordTok{$calc}\NormalTok{ = }\KeywordTok{new}\NormalTok{ Calculator}\OtherTok{();}
        \KeywordTok{$answer}\NormalTok{ = }\KeywordTok{$calc}\NormalTok{->process}\OtherTok{(}\KeywordTok{$n1}\OtherTok{,} \KeywordTok{$n2}\OtherTok{,} \KeywordTok{$operator}\OtherTok{);}

        \KeywordTok{return} \KeywordTok{$this}\NormalTok{->render}\OtherTok{(}
            \StringTok{'calc/result.html.twig'}\OtherTok{,}
            \OtherTok{[}
                \StringTok{'n1'}\NormalTok{ => }\KeywordTok{$n1}\OtherTok{,}
                \StringTok{'n2'}\NormalTok{ => }\KeywordTok{$n2}\OtherTok{,}
                \StringTok{'operator'}\NormalTok{ => }\KeywordTok{$operator}\OtherTok{,}
                \StringTok{'answer'}\NormalTok{ => }\KeywordTok{$answer}
            \OtherTok{]}
        \OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

The Twig template to display our form looks as follows
\texttt{/templates/calc/index.html.twig}:

\begin{verbatim}
    {% extends 'base.html.twig' %}

    {% block body %}
    <h1>Calculator home</h1>

        <form method="post" action="{{ url('calc_process') }}">
            <p>
                Num 1:
                <input type="text" name="num1" value="1">
            </p>
            <p>
                Num 2:
                <input type="text" name="num2" value="1">
            </p>
            <p>
                Operation:
                <br>
                ADD
                <input type="radio" name="operator" value="add" checked>
                <br>
                SUBTRACT
                <input type="radio" name="operator" value="subtract">
                <br>
                DIVIDE
                <input type="radio" name="operator" value="divide">
            </p>

            <p>
                <input type="submit" name="calc_submit">
            </p>
        </form>

    {% endblock %}
\end{verbatim}

and the Twig template to confirm received values, and display the answer
\texttt{result.html.twig} contains:

\begin{verbatim}
    <h1>Calc RESULT</h1>
    <p>
        Your inputs were:
        <br>
        n1 = {{ n1 }}
        <br>
        n2 = {{ n2 }}
        <br>
        operator = {{ operator }}
    <p>
        answer = {{ answer }}
\end{verbatim}

\hypertarget{test-we-can-get-a-reference-to-the-form}{%
\section{Test we can get a reference to the
form}\label{test-we-can-get-a-reference-to-the-form}}

Let's test that can see the form page

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testHomepageResponseCodeOkay}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$url}\NormalTok{ = }\StringTok{'/calc'}\OtherTok{;}
        \KeywordTok{$httpMethod}\NormalTok{ = }\StringTok{'GET'}\OtherTok{;}
        \KeywordTok{$client}\NormalTok{ = }\KeywordTok{static}\NormalTok{::createClient}\OtherTok{();}
        \KeywordTok{$expectedResult}\NormalTok{ = Response::}\KeywordTok{HTTP_OK}\OtherTok{;}

        \CommentTok{// Assert}
        \KeywordTok{$client}\NormalTok{->request}\OtherTok{(}\KeywordTok{$httpMethod}\OtherTok{,} \KeywordTok{$url}\OtherTok{);}
        \KeywordTok{$statusCode}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->getResponse}\OtherTok{()}\NormalTok{->getStatusCode}\OtherTok{();}

        \CommentTok{// Assert}
        \KeywordTok{$this}\NormalTok{->assertSame}\OtherTok{(}\KeywordTok{$expectedResult}\OtherTok{,} \KeywordTok{$statusCode}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

Let's test that we can get a reference to the form on this page, via its
`submit' button:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testFormReferenceNotNull}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$url}\NormalTok{ = }\StringTok{'/calc'}\OtherTok{;}
        \KeywordTok{$httpMethod}\NormalTok{ = }\StringTok{'GET'}\OtherTok{;}
        \KeywordTok{$client}\NormalTok{ = }\KeywordTok{static}\NormalTok{::createClient}\OtherTok{();}
        \KeywordTok{$crawler}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->request}\OtherTok{(}\KeywordTok{$httpMethod}\OtherTok{,} \KeywordTok{$url}\OtherTok{);}
        \KeywordTok{$buttonName}\NormalTok{ = }\StringTok{'calc_submit'}\OtherTok{;}

        \CommentTok{// Act}
        \KeywordTok{$buttonCrawlerNode}\NormalTok{ = }\KeywordTok{$crawler}\NormalTok{->selectButton}\OtherTok{(}\KeywordTok{$buttonName}\OtherTok{);}
        \KeywordTok{$form}\NormalTok{ = }\KeywordTok{$buttonCrawlerNode}\NormalTok{->form}\OtherTok{();}

        \CommentTok{// Assert}
        \KeywordTok{$this}\NormalTok{->assertNotNull}\OtherTok{(}\KeywordTok{$form}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

NOTE: We have to give each form button we wish to test either a
\texttt{name} or \texttt{id} attribute. In our example we gave our
calculator form the \texttt{name} attribute with value
\texttt{calc\_submit}:

\begin{verbatim}
    <input type="submit" name="calc_submit">
\end{verbatim}

\hypertarget{submitting-the-form}{%
\section{Submitting the form}\label{submitting-the-form}}

Assuming our form has some default values, we can test submitting the
form by then checking if the content of the response after clicking the
submit button contains test `Calc RESULT':

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testCanSubmitAndSeeResultText}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$url}\NormalTok{ = }\StringTok{'/calc'}\OtherTok{;}
        \KeywordTok{$httpMethod}\NormalTok{ = }\StringTok{'GET'}\OtherTok{;}
        \KeywordTok{$client}\NormalTok{ = }\KeywordTok{static}\NormalTok{::createClient}\OtherTok{();}
        \KeywordTok{$crawler}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->request}\OtherTok{(}\KeywordTok{$httpMethod}\OtherTok{,} \KeywordTok{$url}\OtherTok{);}
        \KeywordTok{$expectedContentAfterSubmission}\NormalTok{ = }\StringTok{'Calc RESULT'}\OtherTok{;}
        \KeywordTok{$expectedContentLowerCase}\NormalTok{ = }\FunctionTok{strtolower}\OtherTok{(}\KeywordTok{$expectedContentAfterSubmission}\OtherTok{);}
        \KeywordTok{$buttonName}\NormalTok{ = }\StringTok{'calc_submit'}\OtherTok{;}

        \CommentTok{// Act}
        \KeywordTok{$buttonCrawlerNode}\NormalTok{ = }\KeywordTok{$crawler}\NormalTok{->selectButton}\OtherTok{(}\KeywordTok{$buttonName}\OtherTok{);}
        \KeywordTok{$form}\NormalTok{ = }\KeywordTok{$buttonCrawlerNode}\NormalTok{->form}\OtherTok{();}

        \CommentTok{// submit the form}
        \KeywordTok{$client}\NormalTok{->submit}\OtherTok{(}\KeywordTok{$form}\OtherTok{);}

        \CommentTok{// get content from next Response & make lower case}
        \KeywordTok{$content}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->getResponse}\OtherTok{()}\NormalTok{->getContent}\OtherTok{();}
        \KeywordTok{$contentLowerCase}\NormalTok{ = }\FunctionTok{strtolower}\OtherTok{(}\KeywordTok{$content}\OtherTok{);}

        \CommentTok{// Assert}
        \KeywordTok{$this}\NormalTok{->assertContains}\OtherTok{(}\KeywordTok{$expectedContentLowerCase}\OtherTok{,} \KeywordTok{$contentLowerCase}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{entering-form-values-then-submitting}{%
\section{Entering form values then
submitting}\label{entering-form-values-then-submitting}}

Once we have a reference to a form (\texttt{\$form}) entering values is
completed as array entry:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$form}\OtherTok{[}\StringTok{'num1'}\OtherTok{]}\NormalTok{ = }\DecValTok{1}\OtherTok{;}
    \KeywordTok{$form}\OtherTok{[}\StringTok{'num2'}\OtherTok{]}\NormalTok{ = }\DecValTok{2}\OtherTok{;}
    \KeywordTok{$form}\OtherTok{[}\StringTok{'operator'}\OtherTok{]}\NormalTok{ = }\StringTok{'add'}\OtherTok{;}
\end{Highlighting}
\end{Shaded}

So we can now test that we can enter some values, submit the form, and
check the values in the response generated.

Let's submit 1, 2 and \texttt{add}:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testSubmitOneAndTwoAndValuesConfirmed}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$url}\NormalTok{ = }\StringTok{'/calc'}\OtherTok{;}
        \KeywordTok{$httpMethod}\NormalTok{ = }\StringTok{'GET'}\OtherTok{;}
        \KeywordTok{$client}\NormalTok{ = }\KeywordTok{static}\NormalTok{::createClient}\OtherTok{();}
        \KeywordTok{$crawler}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->request}\OtherTok{(}\KeywordTok{$httpMethod}\OtherTok{,} \KeywordTok{$url}\OtherTok{);}
        \KeywordTok{$buttonName}\NormalTok{ = }\StringTok{'calc_submit'}\OtherTok{;}


        \CommentTok{// Act}
        \KeywordTok{$buttonCrawlerNode}\NormalTok{ = }\KeywordTok{$crawler}\NormalTok{->selectButton}\OtherTok{(}\KeywordTok{$buttonName}\OtherTok{);}
        \KeywordTok{$form}\NormalTok{ = }\KeywordTok{$buttonCrawlerNode}\NormalTok{->form}\OtherTok{();}

        \KeywordTok{$form}\OtherTok{[}\StringTok{'num1'}\OtherTok{]}\NormalTok{ = }\DecValTok{1}\OtherTok{;}
        \KeywordTok{$form}\OtherTok{[}\StringTok{'num2'}\OtherTok{]}\NormalTok{ = }\DecValTok{2}\OtherTok{;}
        \KeywordTok{$form}\OtherTok{[}\StringTok{'operator'}\OtherTok{]}\NormalTok{ = }\StringTok{'add'}\OtherTok{;}

        \CommentTok{// submit the form & get content}
        \KeywordTok{$crawler}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->submit}\OtherTok{(}\KeywordTok{$form}\OtherTok{);}
        \KeywordTok{$content}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->getResponse}\OtherTok{()}\NormalTok{->getContent}\OtherTok{();}
        \KeywordTok{$contentLowerCase}\NormalTok{ = }\FunctionTok{strtolower}\OtherTok{(}\KeywordTok{$content}\OtherTok{);}

        \CommentTok{// Assert}
        \KeywordTok{$this}\NormalTok{->assertContains}\OtherTok{(}
            \StringTok{'1'}\OtherTok{,}
            \KeywordTok{$contentLowerCase}
        \OtherTok{);}
        \KeywordTok{$this}\NormalTok{->assertContains}\OtherTok{(}
            \StringTok{'2'}\OtherTok{,}
            \KeywordTok{$contentLowerCase}
        \OtherTok{);}
        \KeywordTok{$this}\NormalTok{->assertContains}\OtherTok{(}
            \StringTok{'add'}\OtherTok{,}
            \KeywordTok{$contentLowerCase}
        \OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

The test above tests that after submitting the form we see the values
submitted confirmed back to us.

\hypertarget{testing-we-get-the-correct-result-via-form-submission}{%
\section{Testing we get the correct result via form
submission}\label{testing-we-get-the-correct-result-via-form-submission}}

Assuming all our \texttt{Calculator}, methods have been inidividudally
\textbf{unit tested}, we can now test that after submitting some values
via our web form, we get the correct result returned to the user in the
final response.

Let's submit 1, 2 and \texttt{add}, and look for \texttt{3} in the final
response:

\begin{Shaded}
\begin{Highlighting}[]

    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testSubmitOneAndTwoAndResultCorrect}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$url}\NormalTok{ = }\StringTok{'/calc'}\OtherTok{;}
        \KeywordTok{$httpMethod}\NormalTok{ = }\StringTok{'GET'}\OtherTok{;}
        \KeywordTok{$client}\NormalTok{ = }\KeywordTok{static}\NormalTok{::createClient}\OtherTok{();}
        \KeywordTok{$num1}\NormalTok{ = }\DecValTok{1}\OtherTok{;}
        \KeywordTok{$num2}\NormalTok{ = }\DecValTok{2}\OtherTok{;}
        \KeywordTok{$operator}\NormalTok{ = }\StringTok{'add'}\OtherTok{;}
        \KeywordTok{$expectedResult}\NormalTok{ = }\DecValTok{3}\OtherTok{;}
        \CommentTok{// must be string for string search}
        \KeywordTok{$expectedResultString}\NormalTok{ = }\KeywordTok{$expectedResult}\NormalTok{ . }\StringTok{''}\OtherTok{;}
        \KeywordTok{$buttonName}\NormalTok{ = }\StringTok{'calc_submit'}\OtherTok{;}

        \CommentTok{// Act}

        \CommentTok{// (1) get form page}
        \KeywordTok{$crawler}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->request}\OtherTok{(}\KeywordTok{$httpMethod}\OtherTok{,} \KeywordTok{$url}\OtherTok{);}

        \CommentTok{// (2) get reference to the form}
        \KeywordTok{$buttonCrawlerNode}\NormalTok{ = }\KeywordTok{$crawler}\NormalTok{->selectButton}\OtherTok{(}\KeywordTok{$buttonName}\OtherTok{);}
        \KeywordTok{$form}\NormalTok{ = }\KeywordTok{$buttonCrawlerNode}\NormalTok{->form}\OtherTok{();}

        \CommentTok{// (3) insert form data}
        \KeywordTok{$form}\OtherTok{[}\StringTok{'num1'}\OtherTok{]}\NormalTok{ = }\KeywordTok{$num1}\OtherTok{;}
        \KeywordTok{$form}\OtherTok{[}\StringTok{'num2'}\OtherTok{]}\NormalTok{ = }\KeywordTok{$num2}\OtherTok{;}
        \KeywordTok{$form}\OtherTok{[}\StringTok{'operator'}\OtherTok{]}\NormalTok{ = }\KeywordTok{$operator}\OtherTok{;}

        \CommentTok{// (4) submit the form}
        \KeywordTok{$crawler}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->submit}\OtherTok{(}\KeywordTok{$form}\OtherTok{);}
        \KeywordTok{$content}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->getResponse}\OtherTok{()}\NormalTok{->getContent}\OtherTok{();}

        \CommentTok{// Assert}
        \KeywordTok{$this}\NormalTok{->assertContains}\OtherTok{(}\KeywordTok{$expectedResultString}\OtherTok{,} \KeywordTok{$content}\OtherTok{);}
\end{Highlighting}
\end{Shaded}

That's it - we can now select forms, enter values, submit the form and
interrogate the response after the submitted form has been processed.

\hypertarget{selecting-form-entering-values-and-submitting-in-one-step}{%
\section{Selecting form, entering values and submitting in one
step}\label{selecting-form-entering-values-and-submitting-in-one-step}}

Using the \textbf{fluent} interface,, Symfony allows us to combine the
steps of selecting the form, setting form values and submitting the
form. E.g.:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{$client}\NormalTok{->submit}\OtherTok{(}\KeywordTok{$client}\NormalTok{->request}\OtherTok{(}\KeywordTok{$httpMethod}\OtherTok{,} \KeywordTok{$url}\OtherTok{)}\NormalTok{->selectButton}\OtherTok{(}\KeywordTok{$buttonName}\OtherTok{)}\NormalTok{->form}\OtherTok{([}
        \StringTok{'num1'}\NormalTok{  => }\KeywordTok{$num1}\OtherTok{,}
        \StringTok{'num2'}\NormalTok{  => }\KeywordTok{$num2}\OtherTok{,}
        \StringTok{'operator'}\NormalTok{  => }\KeywordTok{$operator}\OtherTok{,}
    \OtherTok{]));}
\end{Highlighting}
\end{Shaded}

So we can write a test with fewer steps if we wish:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ testSelectSetValuesSubmitInOneGo}\OtherTok{()}
\NormalTok{    \{}
        \CommentTok{// Arrange}
        \KeywordTok{$url}\NormalTok{ = }\StringTok{'/calc'}\OtherTok{;}
        \KeywordTok{$httpMethod}\NormalTok{ = }\StringTok{'GET'}\OtherTok{;}
        \KeywordTok{$client}\NormalTok{ = }\KeywordTok{static}\NormalTok{::createClient}\OtherTok{();}
        \KeywordTok{$num1}\NormalTok{ = }\DecValTok{1}\OtherTok{;}
        \KeywordTok{$num2}\NormalTok{ = }\DecValTok{2}\OtherTok{;}
        \KeywordTok{$operator}\NormalTok{ = }\StringTok{'add'}\OtherTok{;}
        \KeywordTok{$expectedResult}\NormalTok{ = }\DecValTok{3}\OtherTok{;}
        \CommentTok{// must be string for string search}
        \KeywordTok{$expectedResultString}\NormalTok{ = }\KeywordTok{$expectedResult}\NormalTok{ . }\StringTok{''}\OtherTok{;}
        \KeywordTok{$buttonName}\NormalTok{ = }\StringTok{'calc_submit'}\OtherTok{;}

        \CommentTok{// Act}
        \KeywordTok{$client}\NormalTok{->submit}\OtherTok{(}\KeywordTok{$client}\NormalTok{->request}\OtherTok{(}\KeywordTok{$httpMethod}\OtherTok{,} \KeywordTok{$url}\OtherTok{)}\NormalTok{->selectButton}\OtherTok{(}\KeywordTok{$buttonName}\OtherTok{)}\NormalTok{->form}\OtherTok{([}
                \StringTok{'num1'}\NormalTok{  => }\KeywordTok{$num1}\OtherTok{,}
                \StringTok{'num2'}\NormalTok{  => }\KeywordTok{$num2}\OtherTok{,}
                \StringTok{'operator'}\NormalTok{  => }\KeywordTok{$operator}\OtherTok{,}
        \OtherTok{]));}
        \KeywordTok{$content}\NormalTok{ = }\KeywordTok{$client}\NormalTok{->getResponse}\OtherTok{()}\NormalTok{->getContent}\OtherTok{();}

        \CommentTok{// Assert}
        \KeywordTok{$this}\NormalTok{->assertContains}\OtherTok{(}\KeywordTok{$expectedResultString}\OtherTok{,} \KeywordTok{$content}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\part{Appendices}

\appendix

\hypertarget{software-required-for-symfony-development}{%
\chapter{\texorpdfstring{Software required for Symfony
development\label{appendix_software}}{Software required for Symfony development}}\label{software-required-for-symfony-development}}

\hypertarget{dont-confuse-different-software-tools}{%
\section{Don't confuse different software
tools}\label{dont-confuse-different-software-tools}}

Please do not confuse the following:

\begin{itemize}
\tightlist
\item
  Git and Github
\item
  PHP and PHPStorm
\end{itemize}

Here is a short description of each:

\begin{itemize}
\item
  Git: A version control system - can run locally or on networked
  computer. There are several website that support Git projects,
  including:

  \begin{itemize}
  \tightlist
  \item
    Github (perhaps the most well known)
  \item
    Gitlab
  \item
    Bitbucket
  \item
    you can also create and run your own Git web server \ldots{}
  \end{itemize}
\item
  Github: A commercial (but free for students!) cloud service for
  storing and working with projects using the Git version control system
\item
  PHP: A computer programming language, maintained by an international
  Open Source community and published at \texttt{php.net}
\item
  PHPStorm: A great (and free for student!) IDE - Interactive
  Development Enviroment. I.e. a really clever text editor created just
  for working with PHP projects. PHPStorm is one of the professional
  software tools offered by the \textbf{Jetbrains} company.
\end{itemize}

So in summary, Git and PHP are open source core software. Github and
PHPStorm are commercial (but free for students!) tools that support
development using Git and PHP.

\hypertarget{software-tools}{%
\section{Software tools}\label{software-tools}}

Ensure you have the following setup for developing Symfony software on
your local machine

\begin{itemize}
\tightlist
\item
  PHP 7.2.5 or later (free, open source)
\item
  Composer (up-to-date with \texttt{composer\ self-update})(free, open
  source - a PHP program!)
\item
  PHPStorm (with educational free account if you're a student!) - or
  some other editor of your choice
\item
  MySQL Workbench (Community Edition free)
\item
  Git (free, open source)
\end{itemize}

See Appendix \ref{appendix_php} for checking, and if necessary,
installing PHP on your computer. See Appendix \ref{appendix_software}
for details about other software needed for working with PHP projects.

\hypertarget{test-software-by-creating-a-new-symfony-4-project}{%
\section{Test software by creating a new Symfony 4
project}\label{test-software-by-creating-a-new-symfony-4-project}}

Test your software by using PHP and Composer to create a new Symfony 4
project. We'll follow the steps at the
\href{https://symfony.com/doc/current/setup.html}{Symfony setup} web
page.

Follow the steps in Appendix \ref{appendix_sf_basic}.

\hypertarget{php-windows-setup}{%
\chapter{\texorpdfstring{PHP Windows
setup\label{appendix_php}}{PHP Windows setup}}\label{php-windows-setup}}

\hypertarget{check-if-you-have-php-installed-and-working}{%
\section{Check if you have PHP installed and
working}\label{check-if-you-have-php-installed-and-working}}

You need PHP version 7.2.5 or later.

Check your PHP version at the command line with:

\begin{Shaded}
\begin{Highlighting}[]
    \OperatorTok{>} \ExtensionTok{php}\NormalTok{ -v}
    \ExtensionTok{PHP}\NormalTok{ 7.3.1 (cli) }\KeywordTok{(}\ExtensionTok{built}\NormalTok{: May  9 2018 19:49:10}\KeywordTok{)}
    \ExtensionTok{Copyright}\NormalTok{ (c) }\ExtensionTok{1997-2017}\NormalTok{ The PHP Group}
    \ExtensionTok{Zend}\NormalTok{ Engine v3.1.0, Copyright (c) }\ExtensionTok{1998-2017}\NormalTok{ Zend Technologies}
\end{Highlighting}
\end{Shaded}

If your version is older than 7.2.5, or you get an error about command
not understood, then complete the steps below.

\hypertarget{download-the-latest-version-of-php}{%
\subsection{Download the latest version of
PHP}\label{download-the-latest-version-of-php}}

Get the latest (7.4 at the time of writing) PHP Windows ZIP from:

\begin{itemize}
\tightlist
\item
  \href{http://php.net/downloads.php}{php.net} click the \textbf{Windows
  Downloads} link
\end{itemize}

NOTE: If installing on Windows ensure you are \textbf{displaying file
extensions}, e.g.~so you see \texttt{php.exe} and \texttt{php.ini} not
just \texttt{php} - Don't relyon Windows to show the right icon while
\emph{hiding the full filename}\ldots{}

Figure \ref{windows_zip} shows a screenshot of the \texttt{php.net}
general and Windows downloads page. The \texttt{ZIP} file to download
(containing \texttt{php.exe} \ldots{} don't download the source code
version unless you want to build the file from code \ldots{}):

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/54ea2bd7518c42f7055083e08168bc8498c402b7.png}
\caption{PHP.net / Windows ZIP download pages. \label{windows_zip}}
\end{figure}

Do the following:

\begin{itemize}
\item
  unzip the PHP folder into: \texttt{C:\textbackslash{}php}
\item
  so you should now have a file \texttt{php.exe} inside
  \texttt{C:\textbackslash{}php}, along with lots of other files
\item
  make a copy the file
  \texttt{C:\textbackslash{}php\textbackslash{}php.ini-development},
  naming the copy \texttt{C:\textbackslash{}php\textbackslash{}php.ini}
\end{itemize}

\hypertarget{add-the-path-to-php.exe-to-your-system-environment-variables}{%
\section{\texorpdfstring{Add the \textbf{path} to \texttt{php.exe} to
your System environment
variables}{Add the path to php.exe to your System environment variables}}\label{add-the-path-to-php.exe-to-your-system-environment-variables}}

Whenever you type a command at the CLI (Command Line Interface) Windows
searches through all the directories in its \texttt{path} environment
variable. In order to use PHP at the CLI we need to add
\texttt{c:\textbackslash{}php} to the \texttt{path} environment variable
so the \texttt{php.exe} executable can be found.

Via the System Properties editor, open your Windows Evironment Variables
editor. The \textbf{system} environment variablesa re in the lower half
of the Environment Variables editor. If there is already a system
variable named \texttt{Path}, then select it and click the \textbf{Edit}
button. If none exists, then click the \textbf{New} button, naming the
new variable \textbf{path}. Add a new value to the \textbf{path}
variable with the value \texttt{c:\textbackslash{}php}. Then click all
the \textbf{Okay} buttons needed to close all these windows.

Now open a windows \textbf{Cmd} window and try the \texttt{php\ -v} -
hopefully you'll see confirmation that your system now has PHP installed
and in the \textbf{path} for CLI commands.

Figure \ref{env2} shows a screenshot of the Windows system and
environment variables editor.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/eb1ab9d21c784b824e4103ff64f0448e7b0e6122.png}
\caption{The Windows Environment Variables editor. \label{env2}}
\end{figure}

\hypertarget{check-your-php.ini-file}{%
\section{\texorpdfstring{Check your \texttt{php.ini}
file}{Check your php.ini file}}\label{check-your-php.ini-file}}

Open a new terminal CLI window (so new settings are loaded) and run
\texttt{php\ -\/-ini} to confirm the location of the \texttt{php.ini}
file that you've just created. Note the following for a Mac - for
Windows it should (hopefully) tell you it found the ini file in
\texttt{c:\textbackslash{}php\textbackslash{}php.ini}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ --ini}
    \ExtensionTok{Configuration}\NormalTok{ File (php.ini) }\ExtensionTok{Path}\NormalTok{: /Applications/MAMP/bin/php/php7.1.8/conf}
    \ExtensionTok{Loaded}\NormalTok{ Configuration File:         /Applications/MAMP/bin/php/php7.1.8/conf/php.ini}
    \ExtensionTok{Scan}\NormalTok{ for additional .ini files in: (none)}
    \ExtensionTok{Additional}\NormalTok{ .ini files parsed:      (none)}
\end{Highlighting}
\end{Shaded}

\hypertarget{php-info-sql-driver-test}{%
\section{PHP Info \& SQL driver test}\label{php-info-sql-driver-test}}

For database work we need to enable the PDO\footnote{PDO = PHP Database
  Objects, the modern library for managing PHP program communications
  with databases. Avoid using old libries like \texttt{mysql} (security
  issues) and even \texttt{mysqli} (just for MySQL). PDO offers an
  object-oriented, standardized way to communicate with many different
  database systems. So a project could change the databse management
  system (e.g.~from Oracle to MySQL to SQLite), and only the database
  connetion optins need to change - all other PDO code will work with
  the new database system!} options for MySQL and SQLite (see later
database exercises for how to do this)

Although PHP may have been installed, and its SQL drivers too, they may
have not been enabled. For this module we'll be using the SQLite and
MySQL drivers for PHP -- to talk to databases. The function
\texttt{phpinfo()} is very useful since it displays many of the settings
of the PHP installation on your computer / website.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the current (or a temporary) direcotry, create file
  \texttt{info.php} containing just the following 2 lines of code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php}
    \KeywordTok{print} \FunctionTok{phpinfo}\OtherTok{();}
\end{Highlighting}
\end{Shaded}
\item
  At the CLI run the built-in PHP web server to serve this page, and
  visit: \texttt{localhost:8000/info.php} in your web browser

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{php}\NormalTok{ -S localhost:8000}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

In the PDO section of the web page (\texttt{CTL-F} and search for
\texttt{pdo} \ldots{}) we are looking for \textbf{mysql} and
\textbf{sqlite}. If you see these then great!

Figure \ref{info} shows a screenshot the Windows system and environment
variables editor.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/23f96bdd9781fe840d266ef37cf21f53375d2ee1.png}
\caption{The PDO section of the \texttt{phpinfo()} information page.
\label{info}}
\end{figure}

But, if you see ``no value'' under the PDO drivers section, then we'll
need to edit file \texttt{c:\textbackslash{}php\textbackslash{}php.ini}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  In a text editor open file
  \texttt{c:\textbackslash{}php\textbackslash{}php.ini} and locate the
  ``Dynamic Extensions'' section in this file (e.g.~use the editor
  Search feature - or you could just search for \texttt{pdo})
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/1d5fcbd6fa656ccd94d4e29a62daf0a1df5dae28.png}
\caption{SQLite being enabled in php.ini in the Notepad++ editor.}
\end{figure}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Now remove the semi-colon \texttt{;} comment character at the
  beginning of the lines for the SQLite and MySQL DLLs to enable them as
  shown here:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    ;;;;;;;;;;;;;;;;;;;;;;}
\NormalTok{    ; }\ExtensionTok{Dynamic}\NormalTok{ Extensions }\KeywordTok{;}
\NormalTok{    ;;;;;;;;;;;;;;;;;;;;;;}

    \ExtensionTok{..}\NormalTok{ other lines here ...}
    \VariableTok{extension=}\NormalTok{php_pdo_mysql }\OperatorTok{<<<<<<<<<<} \ExtensionTok{here}\NormalTok{ is the PDO MYSQL driver line}
\NormalTok{    ;}\VariableTok{extension=}\NormalTok{php_pdo_oci}
\NormalTok{    ;}\VariableTok{extension=}\NormalTok{php_pdo_odbc}
\NormalTok{    ;}\VariableTok{extension=}\NormalTok{php_pdo_pgsql}
    \VariableTok{extension=}\NormalTok{php_pdo_sqlite }\OperatorTok{<<<<<<<<  here} \ExtensionTok{is}\NormalTok{ the PDO SQLITE driver line}
\end{Highlighting}
\end{Shaded}
\item
  Save the file. Close your Command Prompt, and re-open it (to ensure
  new settings are used).

  -- Run the webserver again and visit: \texttt{localhost:8000/info.php}
  to check the PDO drivers.
\end{enumerate}

NOTE: Knowing how to view \texttt{phpinfo()} is very handy when checking
server features.

\hypertarget{the-composer-andd-symfonhy-command-line-tools}{%
\chapter{\texorpdfstring{The Composer andd Symfonhy command line
tools\label{cli_tools}}{The Composer andd Symfonhy command line tools}}\label{the-composer-andd-symfonhy-command-line-tools}}

\hypertarget{composer}{%
\section{Composer}\label{composer}}

Composer is a \textbf{fantastic} PHP tool for managing project
dependencies (the libraries and class packages used by OO PHP projects).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  ensure that Composer is up to date by running:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{composer}\NormalTok{ self-update}
\end{Highlighting}
\end{Shaded}
\item
  enable the PDO options for MySQL and SQLite (see Appendix
  \ref{appendix_php} for how to do this by editing ther
  \texttt{c:\textbackslash{}php\textbackslash{}php.ini} file \ldots{})
\end{enumerate}

The Composer tool is actually a \textbf{PHAR} (PHP Archive) - i.e.~a PHP
application packaged into a single file. So ensure you have PHP
installed and in your environment \textbf{path} before attempting to
install or use Composer.

Ensure you have (or install) an up-to-date version of the Composer PHP
package manager.

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{composer}\NormalTok{ self-update}
\end{Highlighting}
\end{Shaded}

\hypertarget{windows-composer-install}{%
\subsection{Windows Composer install}\label{windows-composer-install}}

Get the latest version of Composer from

\begin{itemize}
\item
  \href{https://getcomposer.org/}{getcomposer.org}
\item
  run the provided \textbf{Composer-Setup.exe} installer (just accept
  all the default options - do NOT tick the developer mode)

  -- \url{https://getcomposer.org/doc/00-intro.md\#installation-windows}
  \#\# The Composer PHP library tool
\end{itemize}

The Composer tool is actually a \textbf{PHAR} (PHP Archive) - i.e.~a PHP
application packaged into a single file. So ensure you have PHP
installed and in your environment \textbf{path} before attempting to
install or use Composer.

Ensure you have (or install) an up-to-date version of the Composer PHP
package manager.

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{composer}\NormalTok{ self-update}
\end{Highlighting}
\end{Shaded}

\hypertarget{windows-composer-install-1}{%
\subsection{Windows Composer install}\label{windows-composer-install-1}}

Get the latest version of Composer from

\begin{itemize}
\item
  \href{https://getcomposer.org/}{getcomposer.org}
\item
  run the provided \textbf{Composer-Setup.exe} installer (just accept
  all the default options - do NOT tick the developer mode)

  -- \url{https://getcomposer.org/doc/00-intro.md\#installation-windows}
\end{itemize}

\hypertarget{symfony-command-line-tool}{%
\section{Symfony command line tool}\label{symfony-command-line-tool}}

\hypertarget{software-tools-1}{%
\chapter{\texorpdfstring{Software
tools\label{appendix_software_setup}}{Software tools}}\label{software-tools-1}}

NOTE: All the following should already available on the college
computers.

\hypertarget{phpstorm-editor}{%
\section{PHPStorm editor}\label{phpstorm-editor}}

Ensure you have your free education Jetbrains licence from:

\begin{itemize}
\tightlist
\item
  \href{https://www.jetbrains.com/shop/eform/students}{Students form:
  https://www.jetbrains.com/shop/eform/students} (ensure you use your
  ITB student email address)
\end{itemize}

Downdload and install PHPStorm from:

\begin{itemize}
\tightlist
\item
  \url{https://www.jetbrains.com/phpstorm/download/}
\end{itemize}

To save lots of typing, try to install the following useful PHPStorm
plugins:

\begin{itemize}
\tightlist
\item
  Twig
\item
  Symfony
\item
  Annotations
\end{itemize}

\hypertarget{mysql-workbench}{%
\section{MySQL Workbench}\label{mysql-workbench}}

While you can work with SQLite and other database management systems,
many ITB modules use MySQLWorkbench for database work, and it's fine, so
that's what we'll use (and, of course, it is already installed on the
ITB windows computers \ldots{})

Download and install MySQL Workbench from:

\begin{itemize}
\tightlist
\item
  \url{https://dev.mysql.com/downloads/workbench/}
\end{itemize}

\hypertarget{git}{%
\section{Git}\label{git}}

Git is a fantastic (and free!) DVCS - Distributed Version Control
System. It has free installers for Windows, Mac, Linus etc.

Check is Git in installed on your computer by typing \texttt{git} at the
CLI terminal:

\begin{Shaded}
\begin{Highlighting}[]
    \OperatorTok{>} \FunctionTok{git}
    \ExtensionTok{usage}\NormalTok{: git [--version] [--help] [-C }\OperatorTok{<}\NormalTok{path}\OperatorTok{>}\NormalTok{] [-c name=value]}
\NormalTok{               [}\ExtensionTok{--exec-path}\NormalTok{[=}\OperatorTok{<}\NormalTok{path}\OperatorTok{>}\NormalTok{]] [--html-path] [--man-path] [--info-path]}
\NormalTok{               [}\ExtensionTok{-p} \KeywordTok{|} \ExtensionTok{--paginate} \KeywordTok{|} \ExtensionTok{--no-pager}\NormalTok{] [--no-replace-objects] [--bare]}
\NormalTok{               [}\ExtensionTok{--git-dir}\NormalTok{=}\OperatorTok{<}\NormalTok{path}\OperatorTok{>}\NormalTok{] [--work-tree=}\OperatorTok{<}\NormalTok{path}\OperatorTok{>}\NormalTok{] [--namespace=}\OperatorTok{<}\NormalTok{name}\OperatorTok{>}\NormalTok{]}
               \OperatorTok{<}\BuiltInTok{command}\OperatorTok{>}\NormalTok{ [}\OperatorTok{<}\NormalTok{args}\OperatorTok{>}\NormalTok{]}

    \ExtensionTok{These}\NormalTok{ are common Git commands used in various situations:}

    \ExtensionTok{start}\NormalTok{ a working area (see also: git help tutorial)}
       \ExtensionTok{clone}\NormalTok{      Clone a repository into a new directory}
       \ExtensionTok{init}\NormalTok{       Create an empty Git repository or reinitialize an existing one}

    \ExtensionTok{...}

    \ExtensionTok{collaborate}\NormalTok{ (see also: git help workflows)}
       \ExtensionTok{fetch}\NormalTok{      Download objects and refs from another repository}
       \ExtensionTok{pull}\NormalTok{       Fetch from and integrate with another repository or a local branch}
       \ExtensionTok{push}\NormalTok{       Update remote refs along with associated objects}

    \StringTok{'git help -a'} \ExtensionTok{and} \StringTok{'git help -g'}\NormalTok{ list available subcommands and some}
    \ExtensionTok{concept}\NormalTok{ guides. See }\StringTok{'git help <command>'}\NormalTok{ or }\StringTok{'git help <concept>'}
    \ExtensionTok{to}\NormalTok{ read about a specific subcommand or concept.}

    \OperatorTok{>}
\end{Highlighting}
\end{Shaded}

If you don't see a list of \textbf{Git} commands like the above, then
you need to install Git on your computer.

\hypertarget{git-windows-installation}{%
\section{Git Windows installation}\label{git-windows-installation}}

Visit this page to run the Windows Git installer.

\begin{itemize}
\tightlist
\item
  \url{https://git-scm.com/downloads}
\end{itemize}

NOTE: Do \textbf{not} use a GUI-git client. Do all your Git work at the
command line. It's the best way to learn, and it means you can work with
Git on other computers, for remote terminal sessions (e.g.~to work on
remote web servers) and so on.

\hypertarget{the-fully-featured-symfony-4-demo}{%
\chapter{\texorpdfstring{The fully-featured Symfony 4
demo\label{appendix_sf_demo}}{The fully-featured Symfony 4 demo}}\label{the-fully-featured-symfony-4-demo}}

\hypertarget{visit-github-repo-for-full-symfony-demo}{%
\section{Visit Github repo for full Symfony
demo}\label{visit-github-repo-for-full-symfony-demo}}

Visit the project code repository on Github at:
\url{https://github.com/symfony/demo}

\hypertarget{git-steps-for-download-clone}{%
\section{Git steps for download
(clone)}\label{git-steps-for-download-clone}}

If you have Git setup on your computer (it is on the college computers)
then do the following:

\begin{itemize}
\item
  copy the clone URL into the clipboard
\item
  open a CLI (Command Line Interface) window
\item
  navigate (using \texttt{cd}) to the location you wish to
  clone\footnote{For a throw-away exercise like this I just create a
    directry named \texttt{temp} (with \texttt{mkdir\ temp}) and
    \texttt{cd} into that\ldots{}}
\item
  use \texttt{git\ clone\ \textless{}url\textgreater{}} to make a copy
  of the project on your computer
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{lab01}\NormalTok{ $ git clone https://github.com/symfony/demo.git}
    \ExtensionTok{Cloning}\NormalTok{ into }\StringTok{'demo'}\NormalTok{...}
    \ExtensionTok{remote}\NormalTok{: Counting objects: 7165, done.}
    \ExtensionTok{remote}\NormalTok{: Compressing objects: 100% (13/13), }\KeywordTok{done}\ExtensionTok{.}
    \ExtensionTok{remote}\NormalTok{: Total 7165 (delta 4), }\ExtensionTok{reused}\NormalTok{ 8 (delta 2), }\ExtensionTok{pack-reused}\NormalTok{ 7150}
    \ExtensionTok{Receiving}\NormalTok{ objects: 100% (7165/7165), }\ExtensionTok{6.79}\NormalTok{ MiB }\KeywordTok{|} \ExtensionTok{1.41}\NormalTok{ MiB/s, done.}
    \ExtensionTok{Resolving}\NormalTok{ deltas: 100% (4178/4178), }\KeywordTok{done}\ExtensionTok{.}

    \ExtensionTok{lab01}\NormalTok{ $}
\end{Highlighting}
\end{Shaded}

\hypertarget{non-git-download}{%
\section{Non-git download}\label{non-git-download}}

If you don't have Git on your computer, just download and \textbf{unzip}
the project to your computer (and make a note to get \textbf{Git}
installed a.s.a.p.!)

\hypertarget{install-dependencies}{%
\section{Install dependencies}\label{install-dependencies}}

Install any required 3rd party components by typing \texttt{cd}ing into
folder \texttt{demo} and typing CLI command \texttt{composer\ install}.
A \textbf{lot} of dependencies will be downloaded and installed!

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{lab01/demo}\NormalTok{ $ composer install}
    \ExtensionTok{Loading}\NormalTok{ composer repositories with package information}
    \ExtensionTok{Installing}\NormalTok{ dependencies (including require-dev) }\ExtensionTok{from}\NormalTok{ lock file}
    \ExtensionTok{Package}\NormalTok{ operations: 89 installs, 0 updates, 0 removals}
      \ExtensionTok{-}\NormalTok{ Installing ocramius/package-versions (1.2.0)}\BuiltInTok{:}\NormalTok{ Loading from cache}
      \ExtensionTok{-}\NormalTok{ Installing symfony/flex (v1.0.65)}\BuiltInTok{:}\NormalTok{ Loading from cache}
      \ExtensionTok{...}
      \ExtensionTok{-}\NormalTok{ Installing symfony/phpunit-bridge (v4.0.3)}\BuiltInTok{:}\NormalTok{ Loading from cache}
      \ExtensionTok{-}\NormalTok{ Installing symfony/web-profiler-bundle (v4.0.3)}\BuiltInTok{:}\NormalTok{ Loading from cache}
      \ExtensionTok{-}\NormalTok{ Installing symfony/web-server-bundle (v4.0.3)}\BuiltInTok{:}\NormalTok{ Loading from cache}
    \ExtensionTok{Generating}\NormalTok{ autoload files}
    \ExtensionTok{ocramius}\NormalTok{/package-versions:  }\ExtensionTok{Generating}\NormalTok{ version class...}
    \ExtensionTok{ocramius}\NormalTok{/package-versions: }\ExtensionTok{...done}\NormalTok{ generating version class}
\end{Highlighting}
\end{Shaded}

\hypertarget{run-the-demo}{%
\section{Run the demo}\label{run-the-demo}}

Run the demo with \texttt{php\ bin\textbackslash{}console\ server:run}

(Windows) You may just need to type
\texttt{bin\textbackslash{}console\ \ server:run} since I think there is
a \texttt{.bat} file in \texttt{\textbackslash{}bin}:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{lab01/demo}\NormalTok{$ }\ExtensionTok{php}\NormalTok{ bin/console server:run}

\NormalTok{     [}\ExtensionTok{OK}\NormalTok{] Server listening on http://127.0.0.1:8000}

     \ExtensionTok{//}\NormalTok{ Quit the server with CONTROL-C.}

    \ExtensionTok{PHP}\NormalTok{ 7.1.8 Development Server started at Tue Jan 23 08:19:05 2018}
    \ExtensionTok{Listening}\NormalTok{ on http://127.0.0.1:8000}
    \ExtensionTok{Document}\NormalTok{ root is /Users/matt/Library/Mobile Documents/com~apple~CloudDocs/91_UNITS/UNITS_PHP_4_frmwrks/lab_sheets/web3-lab-sheets-codes/lab01/demo/public}
    \ExtensionTok{Press}\NormalTok{ Ctrl-C to quit.}
\end{Highlighting}
\end{Shaded}

\hypertarget{view-demo-in-browser}{%
\section{View demo in browser}\label{view-demo-in-browser}}

Open a browswer to \texttt{localhost:8000} and play around with the
website. Figure \ref{sf_demo} shows a screenshot of the default Symfony
page for a new, empty project.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/cfaa2bf57de0672ec4d1e8d596a1e09a900425de.png}
\caption{Default Symfony 4 demo project \label{sf_demo}}
\end{figure}

\hypertarget{explore-the-code-in-phpstorm}{%
\section{Explore the code in
PHPStorm}\label{explore-the-code-in-phpstorm}}

Open the code for the project in PHPStorm, and look especially in the
\texttt{/controllers} and \texttt{/templates} directories, to work out
what is going on

\hypertarget{switch-demo-from-sqlite-to-mysql}{%
\section{Switch demo from SQLite to
MySQL}\label{switch-demo-from-sqlite-to-mysql}}

At present the Symfony demo uses the SQLite driver, working with a
databse `file' in \texttt{/var/data}.

Let's change this project to work with a MySQL database schema named
\texttt{demo}.

Do the following:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Run MySQL Workbench
\item
  Change the \textbf{URL} for the projects data in \texttt{.env} from:

  \texttt{DATABASE\_URL=sqlite:///\%kernel.project\_dir\%/var/data/blog.sqlite}

  to

  \texttt{DATABASE\_URL="mysql://root:pass@127.0.0.1:3306/demo"}
\item
  Get the Symfony CLI to create the new database schema, type
  \texttt{php\ bin/console\ doctrine:database:create}:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{demo}\NormalTok{ (master) $ }\ExtensionTok{php}\NormalTok{ bin/console doctrine:database:create}
    \ExtensionTok{Created}\NormalTok{ database }\KeywordTok{`}\ExtensionTok{demo}\KeywordTok{`}\NormalTok{ for connection named default}

    \ExtensionTok{demo}\NormalTok{ (master) $}
\end{Highlighting}
\end{Shaded}
\item
  Get the Symfony CLI to note any changes that need to happen to the
  databast to make it match Entites and relationships defined by the
  project's classes, by typing
  \texttt{php\ bin/console\ doctrine:migrations:diff}:

\begin{verbatim}
    demo (master) $ php bin/console doctrine:migrations:diff
    Generated new migration class to "/Users/matt/Library/Mobile Documents/com~apple~CloudDocs/91_UNITS/UNITS_PHP_4_frmwrks/lab_sheets/web3-lab-sheets-codes/lab01/demo/src/Migrations/Version20180127081633.php" from schema differences.

    demo (master) $
\end{verbatim}

  A migration file has now been created.
\item
  Run the migration file, by typing
  \texttt{php\ bin/console\ doctrine:migrations:migrate} and then typing
  \texttt{y}:

\begin{Shaded}
\begin{Highlighting}[]
     \ExtensionTok{demo}\NormalTok{ (master) $ }\ExtensionTok{php}\NormalTok{ bin/console doctrine:migrations:migrate}

     \ExtensionTok{Application}\NormalTok{ Migrations}


     \ExtensionTok{WARNING}\NormalTok{! You are about to execute a database migration that could result in schema changes and data lost. Are you sure you wish to continue? (y/n)}\ExtensionTok{y}
     \ExtensionTok{Migrating}\NormalTok{ up to 20180127081633 from 0}

       \ExtensionTok{++}\NormalTok{ migrating 20180127081633}

          \ExtensionTok{-}\OperatorTok{>}\NormalTok{ CREATE TABLE symfony_demo_comment (id INT AUTO_INCREMENT NOT NULL, post_id INT NOT NULL, author_id INT NOT NULL, content LONGTEXT NOT NULL, published_at DATETIME NOT NULL, INDEX IDX_53AD8F834B89032C (post_id), }\ExtensionTok{INDEX}\NormalTok{ IDX_53AD8F83F675F31B (author_id), }\ExtensionTok{PRIMARY}\NormalTok{ KEY(id)) }\ExtensionTok{DEFAULT}\NormalTok{ CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB}
          \ExtensionTok{-}\OperatorTok{>}\NormalTok{ CREATE TABLE symfony_demo_post (id INT AUTO_INCREMENT NOT NULL, author_id INT NOT NULL, title VARCHAR(255) }\ExtensionTok{NOT}\NormalTok{ NULL, slug VARCHAR(255) }\ExtensionTok{NOT}\NormalTok{ NULL, summary VARCHAR(255) }\ExtensionTok{NOT}\NormalTok{ NULL, content LONGTEXT NOT NULL, published_at DATETIME NOT NULL, INDEX IDX_58A92E65F675F31B (author_id), }\ExtensionTok{PRIMARY}\NormalTok{ KEY(id)) }\ExtensionTok{DEFAULT}\NormalTok{ CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB}
          \ExtensionTok{-}\OperatorTok{>}\NormalTok{ CREATE TABLE symfony_demo_post_tag (post_id INT NOT NULL, tag_id INT NOT NULL, INDEX IDX_6ABC1CC44B89032C (post_id), }\ExtensionTok{INDEX}\NormalTok{ IDX_6ABC1CC4BAD26311 (tag_id), }\ExtensionTok{PRIMARY}\NormalTok{ KEY(post_id, tag_id)) }\ExtensionTok{DEFAULT}\NormalTok{ CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB}
          \ExtensionTok{-}\OperatorTok{>}\NormalTok{ CREATE TABLE symfony_demo_tag (id INT AUTO_INCREMENT NOT NULL, name VARCHAR(255) }\ExtensionTok{NOT}\NormalTok{ NULL, UNIQUE INDEX UNIQ_4D5855405E237E06 (name), }\ExtensionTok{PRIMARY}\NormalTok{ KEY(id)) }\ExtensionTok{DEFAULT}\NormalTok{ CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB}
          \ExtensionTok{-}\OperatorTok{>}\NormalTok{ CREATE TABLE symfony_demo_user (id INT AUTO_INCREMENT NOT NULL, full_name VARCHAR(255) }\ExtensionTok{NOT}\NormalTok{ NULL, username VARCHAR(255) }\ExtensionTok{NOT}\NormalTok{ NULL, email VARCHAR(255) }\ExtensionTok{NOT}\NormalTok{ NULL, password VARCHAR(255) }\ExtensionTok{NOT}\NormalTok{ NULL, roles LONGTEXT NOT NULL COMMENT }\StringTok{'(DC2Type:json)'}\NormalTok{, UNIQUE INDEX UNIQ_8FB094A1F85E0677 (username), }\ExtensionTok{UNIQUE}\NormalTok{ INDEX UNIQ_8FB094A1E7927C74 (email), }\ExtensionTok{PRIMARY}\NormalTok{ KEY(id)) }\ExtensionTok{DEFAULT}\NormalTok{ CHARACTER SET utf8 COLLATE utf8_unicode_ci ENGINE = InnoDB}
          \ExtensionTok{-}\OperatorTok{>}\NormalTok{ ALTER TABLE symfony_demo_comment ADD CONSTRAINT FK_53AD8F834B89032C FOREIGN KEY (post_id) }\ExtensionTok{REFERENCES}\NormalTok{ symfony_demo_post (id)}
          \ExtensionTok{-}\OperatorTok{>}\NormalTok{ ALTER TABLE symfony_demo_comment ADD CONSTRAINT FK_53AD8F83F675F31B FOREIGN KEY (author_id) }\ExtensionTok{REFERENCES}\NormalTok{ symfony_demo_user (id)}
          \ExtensionTok{-}\OperatorTok{>}\NormalTok{ ALTER TABLE symfony_demo_post ADD CONSTRAINT FK_58A92E65F675F31B FOREIGN KEY (author_id) }\ExtensionTok{REFERENCES}\NormalTok{ symfony_demo_user (id)}
          \ExtensionTok{-}\OperatorTok{>}\NormalTok{ ALTER TABLE symfony_demo_post_tag ADD CONSTRAINT FK_6ABC1CC44B89032C FOREIGN KEY (post_id) }\ExtensionTok{REFERENCES}\NormalTok{ symfony_demo_post (id) }\ExtensionTok{ON}\NormalTok{ DELETE CASCADE}
          \ExtensionTok{-}\OperatorTok{>}\NormalTok{ ALTER TABLE symfony_demo_post_tag ADD CONSTRAINT FK_6ABC1CC4BAD26311 FOREIGN KEY (tag_id) }\ExtensionTok{REFERENCES}\NormalTok{ symfony_demo_tag (id) }\ExtensionTok{ON}\NormalTok{ DELETE CASCADE}

       \ExtensionTok{++}\NormalTok{ migrated (0.44s)}

       \ExtensionTok{------------------------}

       \ExtensionTok{++}\NormalTok{ finished in 0.44s}
       \ExtensionTok{++}\NormalTok{ 1 migrations executed}
       \ExtensionTok{++}\NormalTok{ 10 sql queries}

     \ExtensionTok{demo}\NormalTok{ (master) $}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{running-the-tests-in-the-sf4-demo}{%
\section{Running the tests in the SF4
demo}\label{running-the-tests-in-the-sf4-demo}}

The project comes with configuration for \texttt{simple-phpuit}. Run
this once to download the depedencies:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{lab01/demo}\NormalTok{ $ vendor/bin/simple-phpunit}
       \ExtensionTok{./composer.json}\NormalTok{ has been updated}
       \ExtensionTok{Loading}\NormalTok{ composer repositories with package information}
       \ExtensionTok{Updating}\NormalTok{ dependencies}
       \ExtensionTok{Package}\NormalTok{ operations: 19 installs, 0 updates, 0 removals}
         \ExtensionTok{-}\NormalTok{ Installing sebastian/recursion-context (2.0.0)}\BuiltInTok{:}\NormalTok{ Loading from cache}
         \ExtensionTok{...}
         \ExtensionTok{-}\NormalTok{ Installing symfony/phpunit-bridge (5.7.99)}\BuiltInTok{:}\NormalTok{ Symlinking from /Users/matt/lab01/demo/vendor/symfony/phpunit-bridge}
       \ExtensionTok{Writing}\NormalTok{ lock file}
       \ExtensionTok{Generating}\NormalTok{ optimized autoload files}

    \ExtensionTok{lab01/demo}\NormalTok{ $}
\end{Highlighting}
\end{Shaded}

\hypertarget{run-the-tests}{%
\section{Run the tests}\label{run-the-tests}}

Run the tests, by typing
\texttt{vendor\textbackslash{}bin\textbackslash{}simple-phpunit}\footnote{The
  backlash-forward slash thing is annoying. In a nutshell, for file
  paths for Windows machines, use backslashes, for everything else use
  forward slashes. So it's all forward slashes with Linux/Mac machines
  :-)}

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{lab01/demo}\NormalTok{ $ vendor/bin/simple-phpunit}
    \ExtensionTok{PHPUnit}\NormalTok{ 5.7.26 by Sebastian Bergmann and contributors.}

    \ExtensionTok{Testing}\NormalTok{ Project Test Suite}
    \ExtensionTok{.................................................}\NormalTok{                 49 / 49 (100%)}

    \ExtensionTok{Time}\NormalTok{: 27.65 seconds, Memory: 42.00MB}

    \ExtensionTok{OK}\NormalTok{ (49 tests, 88 assertions)}
    \ExtensionTok{matt@matts-MacBook-Pro}\NormalTok{ demo (master) $}
\end{Highlighting}
\end{Shaded}

\hypertarget{explore-directory-tests}{%
\section{\texorpdfstring{Explore directory
\texttt{/tests}}{Explore directory /tests}}\label{explore-directory-tests}}

Look in the \texttt{/tests} directory to see how those tests work. For
example Figure \ref{test_new_post} shows a screenshot of the admin new
post test in PHPStorm.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/cd79edbfb8a8153e7cb6baa58a0777fca556d2af.png}
\caption{The admin new post test in PHPStorm \label{test_new_post}}
\end{figure}

\hypertarget{learn-more}{%
\section{Learn more}\label{learn-more}}

Learn more about PHPUnit testing and Symfony by visiting:

\begin{itemize}
\tightlist
\item
  \url{https://symfony.com/doc/current/testing.html}
\end{itemize}

\hypertarget{solving-problems-with-symfony}{%
\chapter{\texorpdfstring{Solving problems with Symfony
\label{appendix_problem_solving}}{Solving problems with Symfony }}\label{solving-problems-with-symfony}}

\hypertarget{no-home-page-loading}{%
\section{No home page loading}\label{no-home-page-loading}}

Ensure web server is running (either from console, or a webserver
application with web root of the project's \texttt{/public} directory).

If Symfony thinks you are in \textbf{production} (live public website)
then when an error occurs it will throw a 500 server error (which a real
production site would catch and display some nicely sanitised message
for website visitors).

Since we are in \textbf{development} we want to see the \textbf{details}
of any errors. We set the environment in the \texttt{.env} file. For
development mode you should see the following in this file:

\begin{Shaded}
\begin{Highlighting}[]
    \VariableTok{APP_ENV=}\NormalTok{dev}
\end{Highlighting}
\end{Shaded}

In development you should then get a much more detailed description of
the error (including the class / line / template causing the problem
etc.).

Also, if you know where your server error logs are stored, you can see
the errors written to the log file. Symfony lots are usually create in
\texttt{/var/log}.

\hypertarget{route-not-found-error-after-adding-new-controller-method}{%
\section{``Route not Found'' error after adding new controller
method}\label{route-not-found-error-after-adding-new-controller-method}}

If you have issues of Symfony not finding a new route you've added via a
controller annotation comment, try the following.

It's a good idea to \textbf{CLEAR THE CACHE} when addeding/changing
routes, otherwise Symfony may not recognised the new or changed routes
\ldots{} Either manually delete the \texttt{/var/cache} directory, or
run the \texttt{cache:clear} console command:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console cache:clear}

    \ExtensionTok{//}\NormalTok{ Clearing the cache for the dev environment with debug true}
\NormalTok{    [}\ExtensionTok{OK}\NormalTok{] Cache for the }\StringTok{"dev"}\NormalTok{ environment (debug=true) }\ExtensionTok{was}\NormalTok{ successfully cleared.}
\end{Highlighting}
\end{Shaded}

Symfony caches (stores) routing data and also rendered pages from Twig,
to speed up response time. But if you have changed controllers and
routes, sometimes you have to manually delete the cache to ensure all
new routes are checked against new requests.

\hypertarget{issues-with-timezone}{%
\section{Issues with timezone}\label{issues-with-timezone}}

Try adding the following construction to \texttt{/app/AppKernel.php} to
solve timeszone problems:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{public} \KeywordTok{function} \FunctionTok{__construct}\OtherTok{(}\KeywordTok{$environment}\OtherTok{,} \KeywordTok{$debug}\OtherTok{)}
\NormalTok{    \{}
        \FunctionTok{date_default_timezone_set}\OtherTok{(} \StringTok{'Europe/Dublin'} \OtherTok{);}
\NormalTok{        parent::}\FunctionTok{__construct}\OtherTok{(}\KeywordTok{$environment}\OtherTok{,} \KeywordTok{$debug}\OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{issues-with-symfony-3-and-phpunit.phar}{%
\section{Issues with Symfony 3 and
PHPUnit.phar}\label{issues-with-symfony-3-and-phpunit.phar}}

Symfon 3.2 has issues with PHPUnit (it's PHPUnit's fault!). You can
solve the problem with the Symphony PHPUnit \texttt{bridge} - which you
install via Composer:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{composer}\NormalTok{ require --dev symfony/phpunit-bridge}
\end{Highlighting}
\end{Shaded}

You then execute your PHPUnit test with the \texttt{simple-phpunit}
command in \texttt{/vendor/bin} as follows:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{./vendor/bin/simple-phpunit}
\end{Highlighting}
\end{Shaded}

Source:

\begin{itemize}
\tightlist
\item
  \href{http://symfony.com/blog/how-to-solve-phpunit-issues-in-symfony-3-2-applications}{Symfony
  Blog December 2016}
\end{itemize}

\hypertarget{phpunit-installed-via-composer}{%
\section{PHPUnit installed via
Composer}\label{phpunit-installed-via-composer}}

To install PHPUnit with Composer run the following Composer update CLI
command:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{composer}\NormalTok{ require --dev phpunit/phpunit ^6.1}
\end{Highlighting}
\end{Shaded}

To run tests in directory \texttt{/tests} exectute the following CLI
command:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{./vendor/bin/phpunit}\NormalTok{ tests}
\end{Highlighting}
\end{Shaded}

Source:

\begin{itemize}
\tightlist
\item
  \href{https://stackoverflow.com/questions/13764309/how-to-use-phpunit-installed-from-composer}{Stack
  overflow}
\end{itemize}

As always you can add a shortcut script to your \texttt{composer.json}
file to save typing, e.g.:

\begin{Shaded}
\begin{Highlighting}[]
    \ErrorTok{"scripts":} \FunctionTok{\{}
        \DataTypeTok{"run"}\FunctionTok{:}\StringTok{"php bin/console server:run"}\FunctionTok{,}
        \DataTypeTok{"test"}\FunctionTok{:}\StringTok{"./vendor/bin/phpunit tests"}\FunctionTok{,}

        \ErrorTok{...}
    \FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{publish-via-fortrabbit-php-as-a-service}{%
\chapter{\texorpdfstring{Publish via Fortrabbit (PHP as a
service)\label{appendix_fortrabbit}}{Publish via Fortrabbit (PHP as a service)}}\label{publish-via-fortrabbit-php-as-a-service}}

\hypertarget{ssh-key}{%
\section{SSH key}\label{ssh-key}}

Ensure your computer has an SSH key setup, since you'll need this for
secure communication with Fortrabbit.

\hypertarget{windows-ssh-key-setup}{%
\subsection{Windows SSH key setup}\label{windows-ssh-key-setup}}

A guide to generate SSH keys on Windows can be found at:

\begin{itemize}
\tightlist
\item
  \url{http://guides.beanstalkapp.com/version-control/git-on-windows.html}
\end{itemize}

\hypertarget{mac-ssh-key-setup}{%
\subsection{Mac SSH key setup}\label{mac-ssh-key-setup}}

A simple guide to generating SSH keys for the Mac can be found at:

\begin{itemize}
\tightlist
\item
  \url{https://secure.vexxhost.com/billing/knowledgebase/171/How-can-I-generate-SSH-keys-on-Mac-OS-X.html}
\end{itemize}

\hypertarget{linux-ssh-key-setup}{%
\subsection{Linux SSH key setup}\label{linux-ssh-key-setup}}

A guide to generating SSH keys for the Mac can be found at:

\begin{itemize}
\tightlist
\item
  \url{https://www.ssh.com/ssh/keygen/}
\end{itemize}

\hypertarget{fortrabbit}{%
\subsection{Fortrabbit}\label{fortrabbit}}

Do the following:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  On your Fortrabbit account page click to add a new SSH key. See Figure
  \ref{ssh1}.

  \begin{figure}
  \centering
  \includegraphics{./tex2pdf.-65f13e14688ab55b/16bacc5121bf66f2cd344b71767b21fe81c6df09.png}
  \caption{Screenshot - click to add new SSH key. \label{ssh1}}
  \end{figure}
\item
  Paste in SSH key. See Figure \ref{ssh2}.

  \begin{itemize}
  \tightlist
  \item
    or import from your Githiub account \ldots{}
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./tex2pdf.-65f13e14688ab55b/cd38aa4d3856efa6bb95ccd4bbb44e651b5db1f1.png}
  \caption{Screenshot - paste in SSH key. \label{ssh2}}
  \end{figure}
\end{enumerate}

\hypertarget{creating-a-new-web-app}{%
\section{Creating a new web App}\label{creating-a-new-web-app}}

Do the following:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to your account Dashboard, and click to create a new web App. See
  Figure \ref{app1}.

  \begin{figure}
  \centering
  \includegraphics{./tex2pdf.-65f13e14688ab55b/274589dca907ae4a7796c70c0ce9d6102b17c9e1.png}
  \caption{Screenshot - click to create new app. \label{app1}}
  \end{figure}
\item
  Enter an app name, e.g.~\texttt{myproject}. See Figure \ref{app2}.

  \begin{figure}
  \centering
  \includegraphics{./tex2pdf.-65f13e14688ab55b/b277521e01afbf69131997d17abdcd260953bed5.png}
  \caption{Screenshot - enter new app name. \label{app2}}
  \end{figure}
\item
  Choose \texttt{Symfony} project framework from the
  \texttt{Choose\ a\ sofware} page. See Figure \ref{app3}.

  \begin{figure}
  \centering
  \includegraphics{./tex2pdf.-65f13e14688ab55b/d725f6e5cd6f3460c3248abe7efe534100e8ed12.png}
  \caption{Screenshot - choose Symfony project type. \label{app3}}
  \end{figure}
\item
  Choose EU (Ireland) Data Center. See Figure \ref{app4}.

  \begin{figure}
  \centering
  \includegraphics{./tex2pdf.-65f13e14688ab55b/aa674c15f9cce2516f119d81337eb74bfe98e658.png}
  \caption{Screenshot - choose EU (Ireland) Data Center. \label{app4}}
  \end{figure}
\item
  Choose €5 Light Universal Stack. See Figure \ref{app5}.

  \begin{figure}
  \centering
  \includegraphics{./tex2pdf.-65f13e14688ab55b/a75d8ab0477a32ede1831265f0cf033ac69298b5.png}
  \caption{Screenshot - choose cheapest (Light Universal) Stack .
  \label{app5}}
  \end{figure}
\end{enumerate}

Your new Web App should now have been created!.

\hypertarget{cloning-and-populating-your-git-repo}{%
\section{Cloning and populating your Git
repo}\label{cloning-and-populating-your-git-repo}}

Fortrabbit has now created a unique \texttt{git} repo on its servers. Do
the following to make your deploy your existing Symfony project with
this repo:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Click the \texttt{How\ to\ deploy\ git} link. See Figure \ref{git1}.

  \begin{figure}
  \centering
  \includegraphics{./tex2pdf.-65f13e14688ab55b/728302ff79b17ff69542b5fda83564cfed93d110.png}
  \caption{Screenshot - click \texttt{how\ to\ deploy\ git} link.
  \label{git1}}
  \end{figure}
\item
  You'll now see a page with Git commands, customised to your repo/App
  name - so you can copy-and-paste them into a CLI Terminal. See Figure
  \ref{git2}.

  \begin{figure}
  \centering
  \includegraphics{./tex2pdf.-65f13e14688ab55b/6a2abdff42e3b7b3c8786ebd45e9c3866e6e8c7c.png}
  \caption{Screenshot - Git customized command page. \label{git2}}
  \end{figure}
\item
  Git \texttt{clone} the Fortrabbit repo to your local machine, then
  \texttt{cd} into it (you'll need to use your SSH password \ldots{}).
  See Figure \ref{git3}.

  \begin{figure}
  \centering
  \includegraphics{./tex2pdf.-65f13e14688ab55b/5a50a5674900d41609b2eb33517c1e5c992f1ea8.png}
  \caption{Screenshot - clone repo to local machine. \label{git3}}
  \end{figure}
\item
  Copy into your local folder the files for your Symfony project.

  \begin{itemize}
  \item
    NOTE: do the following for a clean database setup on your local
    machine (with migrations ready to use on remote deployment
    database\ldots{})

    \begin{itemize}
    \item
      Change the database name in \texttt{.env} to a new database
    \item
      delete any exiting \texttt{src/Migrations} directory
    \item
      create the database schema with
      \texttt{php\ bin/console\ doctrine:database:create}
    \item
      create migrations class with
      \texttt{php\ bin/console\ doctrine:migrations:diff}
    \item
      execute the migrations to create the table schema with
      \texttt{php\ bin/console\ doctrine:migrations:migrate}
    \item
      load the fixtures fixtures into the local database with
      \texttt{php\ bin/console\ doctrine:fixtures:load}
    \item
      test the fixtures with an \textbf{SQL} command, e.g.~to list users
      from table \texttt{user} you could execute:
      \texttt{php\ bin/console\ doctrine:query:sql\ "select\ *\ from\ user"}
    \end{itemize}
  \end{itemize}
\end{enumerate}

\hypertarget{fixing-the-fixtures-issue}{%
\section{Fixing the Fixtures issue}\label{fixing-the-fixtures-issue}}

For first-time database setup of a deployed project you'll usually wish
to create the fixtures in the database. However, the default setting of
the \textbf{environment} for a Fortrabbit project is
\textbf{production}. See Figure \ref{env1}.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/b96f5a799827863d83341d2a33f6223cd16080e4.png}
\caption{Screenshot - Fortrabbit \texttt{PROD} environment setting.
\label{env1}}
\end{figure}

However, the settings for when the Doctrine Fixtures `bundle' should be
included are only for development and test environments. So if we want
to be able to run Fixture insertion into the database, then we have to
add a statement that Fixtures should be available for all environments.

Add this line to file \texttt{/config/bundles.php}, before the end of
the array \texttt{{]}}:

\begin{verbatim}
    Doctrine\Bundle\FixturesBundle\DoctrineFixturesBundle::class => ['all' => true]
\end{verbatim}

So your listing for \texttt{/config/bundles.php} should now looks
something like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php}
    
    \KeywordTok{return} \OtherTok{[}
\NormalTok{        Symfony\textbackslash{}Bundle\textbackslash{}FrameworkBundle\textbackslash{}FrameworkBundle::}\KeywordTok{class}\NormalTok{ => }\OtherTok{[}\StringTok{'all'}\NormalTok{ => }\KeywordTok{true}\OtherTok{],}
\NormalTok{        Doctrine\textbackslash{}Bundle\textbackslash{}DoctrineCacheBundle\textbackslash{}DoctrineCacheBundle::}\KeywordTok{class}\NormalTok{ => }\OtherTok{[}\StringTok{'all'}\NormalTok{ => }\KeywordTok{true}\OtherTok{],}
        \StringTok{...}\NormalTok{ etc. lots more packages listed }\StringTok{...}
\NormalTok{        Symfony\textbackslash{}Bundle\textbackslash{}SecurityBundle\textbackslash{}SecurityBundle::}\KeywordTok{class}\NormalTok{ => }\OtherTok{[}\StringTok{'all'}\NormalTok{ => }\KeywordTok{true}\OtherTok{],}
\NormalTok{        Doctrine\textbackslash{}Bundle\textbackslash{}FixturesBundle\textbackslash{}DoctrineFixturesBundle::}\KeywordTok{class}\NormalTok{ => }\OtherTok{[}\StringTok{'all'}\NormalTok{ => }\KeywordTok{true}\OtherTok{]}
    \OtherTok{];}    
\end{Highlighting}
\end{Shaded}

\hypertarget{fixing-the-apache-.htaccess-issue}{%
\section{\texorpdfstring{Fixing the Apache \texttt{.htaccess}
issue}{Fixing the Apache .htaccess issue}}\label{fixing-the-apache-.htaccess-issue}}

Fortrabbit servers PHP projects using the Apache Open Source web server.
For the URL patterns to be correct parsed it needs special URL-rewrite
rules in a file \texttt{.htaccess} in the directory \texttt{//public}.
To create this file you can simply use Composer to require the dedicated
\texttt{symfony/apache-pack} package:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{composer}\NormalTok{ req symfony/apache-pack}
\end{Highlighting}
\end{Shaded}

NOTE: You may be asked to say \texttt{yes} to install this package since
it's been created by the community (and isn't an offical package at the
time of writing \ldots{})

\hypertarget{adding-committing-and-pushing-the-project-files-to-the-repo}{%
\section{Adding, committing and pushing the project files to the
repo}\label{adding-committing-and-pushing-the-project-files-to-the-repo}}

We are now ready to upload our production-ready project files to the
Fortrabbit repo.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the new/changed files for staging with \texttt{git\ add\ .}:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{matt}\NormalTok{$ git status}

\ExtensionTok{On}\NormalTok{ branch master}

\ExtensionTok{No}\NormalTok{ commits yet}

\ExtensionTok{Untracked}\NormalTok{ files:}
  \KeywordTok{(}\ExtensionTok{use} \StringTok{"git add <file>..."}\NormalTok{ to include in what will be committed}\KeywordTok{)}

    \ExtensionTok{.env}
    \ExtensionTok{.gitignore}
    \ExtensionTok{README.md}
    \ExtensionTok{bin/}
    \ExtensionTok{composer.json}
    \ExtensionTok{composer.lock}
    \ExtensionTok{config/}
    \ExtensionTok{public/}
    \ExtensionTok{src/}
    \ExtensionTok{symfony.lock}
    \ExtensionTok{templates/}

\ExtensionTok{nothing}\NormalTok{ added to commit but untracked files present (use }\StringTok{"git add"}\NormalTok{ to track)}

\ExtensionTok{matt}\NormalTok{$ git add .}
\end{Highlighting}
\end{Shaded}
\item
  Commit with first commit message with
  \texttt{git\ commit\ -m\ "\textless{}msg\textgreater{}"}:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{matt}\NormalTok{$ git commit -m }\StringTok{"first commit"}
\NormalTok{        [}\ExtensionTok{master}\NormalTok{ (root-commit) }\ExtensionTok{77946cc}\NormalTok{] first commit}
        \ExtensionTok{59}\NormalTok{ files changed, 6819 insertions(+)}
        \ExtensionTok{create}\NormalTok{ mode 100755 .env}
        \ExtensionTok{create}\NormalTok{ mode 100755 .gitignore}
        \ExtensionTok{create}\NormalTok{ mode 100755 README.md}
        \ExtensionTok{...}\NormalTok{ etc. for lots of files}
        \ExtensionTok{create}\NormalTok{ mode 100755 templates/security/success.html.twig}
        \ExtensionTok{create}\NormalTok{ mode 100755 templates/student/index.html.twig}
\end{Highlighting}
\end{Shaded}
\item
  Push the committed files to the Fortrabbit repo:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{matt}\NormalTok{$ git push -u origin master}
    \ExtensionTok{Enter}\NormalTok{ passphrase for key }\StringTok{'/Users/matt/.ssh/id_rsa'}\NormalTok{: }
    \ExtensionTok{Counting}\NormalTok{ objects: 80, done.}
    \ExtensionTok{Delta}\NormalTok{ compression using up to 12 threads.}
    \ExtensionTok{Compressing}\NormalTok{ objects: 100% (75/75), }\KeywordTok{done}\ExtensionTok{.}
    \ExtensionTok{Writing}\NormalTok{ objects: 100% (80/80), }\ExtensionTok{38.49}\NormalTok{ KiB }\KeywordTok{|} \ExtensionTok{3.21}\NormalTok{ MiB/s, done.}
    \ExtensionTok{Total}\NormalTok{ 80 (delta 7), }\ExtensionTok{reused}\NormalTok{ 0 (delta 0)}

    \ExtensionTok{Commit}\NormalTok{ received, starting build of branch master}
\end{Highlighting}
\end{Shaded}
\item
  Automatically (since we have a new commit to the \texttt{master}
  branch) a new build on the Fortrabbit server will be triggered:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    –––––––––––––––––––––––  }\ExtensionTok{*}\NormalTok{ƒ  –––––––––––––––––––––––}
    \ExtensionTok{B}\NormalTok{ U I L D}

    \ExtensionTok{Checksum}\NormalTok{:}
      \ExtensionTok{77946cc9c25fc7259e93080e89de48fc635c8a1e}

    \ExtensionTok{Composer}\NormalTok{:}
      \ExtensionTok{-}\NormalTok{ - -}
      \ExtensionTok{Loading}\NormalTok{ composer repositories with package information}
      \ExtensionTok{Installing}\NormalTok{ dependencies (including require-dev) }\ExtensionTok{from}\NormalTok{ lock file}
      \ExtensionTok{Package}\NormalTok{ operations: 80 installs, 0 updates, 0 removals}
        \ExtensionTok{-}\NormalTok{ Installing ocramius/package-versions (1.4.0)}\BuiltInTok{:}\NormalTok{ Downloading (100%)}
        \ExtensionTok{-}\NormalTok{ Installing symfony/flex (v1.2.0)}\BuiltInTok{:}\NormalTok{ Downloading (100%)}

      \ExtensionTok{Prefetching}\NormalTok{ 78 packages}
        \ExtensionTok{-}\NormalTok{ Downloading (100%)}

        \ExtensionTok{-}\NormalTok{ Installing symfony/polyfill-mbstring (v1.10.0)}\BuiltInTok{:}\NormalTok{ Loading from cache}
            \ExtensionTok{...}\NormalTok{ etc. Composer will install lots of files ...}
        \ExtensionTok{-}\NormalTok{ Installing symfony/process (v4.2.3)}\BuiltInTok{:}\NormalTok{ Loading from cache}
        \ExtensionTok{-}\NormalTok{ Installing symfony/web-server-bundle (v4.2.3)}\BuiltInTok{:}\NormalTok{ Loading from cache}
      \ExtensionTok{Generating}\NormalTok{ autoload files}

      \ExtensionTok{ocramius}\NormalTok{/package-versions:  }\ExtensionTok{Generating}\NormalTok{ version class...}
      \ExtensionTok{ocramius}\NormalTok{/package-versions: }\ExtensionTok{...done}\NormalTok{ generating version class}

      \ExtensionTok{Executing}\NormalTok{ script cache:clear [OK]}
      \ExtensionTok{Executing}\NormalTok{ script assets:install public [OK]}

      \ExtensionTok{-}\NormalTok{ - -}
      \ExtensionTok{6s}\NormalTok{ 268ms}

    \ExtensionTok{R}\NormalTok{ E L E A S E}

    \ExtensionTok{Size}\NormalTok{:}
      \ExtensionTok{6.7}\NormalTok{ MB}

    \ExtensionTok{Uploading}\NormalTok{:}
      \ExtensionTok{207ms}

    \ExtensionTok{Build} \KeywordTok{&} \ExtensionTok{release}\NormalTok{ done in 7s 51ms, now queued for final distribution.}

\NormalTok{    –––––––––––––––––––––––  }\ExtensionTok{*}\NormalTok{ƒ  –––––––––––––––––––––––    }
\end{Highlighting}
\end{Shaded}
\end{enumerate}

Note, from now on, we can simply use \texttt{git\ push} for any later
committed changes to our source code.

\hypertarget{shh-cli-termial-to-migrate-and-install-db-fixtures}{%
\section{SHH CLI Termial to migrate and install DB
fixtures}\label{shh-cli-termial-to-migrate-and-install-db-fixtures}}

The final step is to migrate the database (using the migrations from our
source code), and load any fixtures we require. We need to do this via
an SSH secure terminal connection to Fortrabbit.

Do the following:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use SSH to connect to the Fortrtabbit virtual Linux machine. See
  Figure \ref{db1}.

  \begin{figure}
  \centering
  \includegraphics{./tex2pdf.-65f13e14688ab55b/43675058c31ebd0caf6622793511e456534c6fc1.png}
  \caption{Screenshot - SSH connent to remote Fortrabbit system.
  \label{db1}}
  \end{figure}
\item
  Migrate the database schema with `doctrine:migrations:migrate (and say
  `yes' when asked). See Figure \ref{db2}.

  \begin{figure}
  \centering
  \includegraphics{./tex2pdf.-65f13e14688ab55b/f48a7e8b2a428b736e97242170a252e51f957759.png}
  \caption{Screenshot - migrate the DB schema. \label{db2}}
  \end{figure}
\item
  Load the fixtures with \texttt{doctrine:fixtures:load} (and say `yes'
  when asked). See Figure \ref{db3}.

  \begin{figure}
  \centering
  \includegraphics{./tex2pdf.-65f13e14688ab55b/54e04d6cbfad1e1f8e4b9a5331ea14024ab4548d.png}
  \caption{Screenshot - load the fixtures into the DB. \label{db3}}
  \end{figure}
\item
  Test the DB contents by listing users via SQL with
  \texttt{doctrine:query:sql\ "select\ *\ from\ user"}. See Figure
  \ref{db4}.

  \begin{figure}
  \centering
  \includegraphics{./tex2pdf.-65f13e14688ab55b/7e9af2f5758a19600a4ceccde52d547bb69d854e.png}
  \caption{Screenshot - testing fixtures by selecting all users via SQL
  query. \label{db4}}
  \end{figure}
\end{enumerate}

\hypertarget{symfony-project-should-now-by-fully-deployed}{%
\section{Symfony project should now by fully
deployed}\label{symfony-project-should-now-by-fully-deployed}}

Your Symfony project should now be fully deployed and working, with DB
fixtures and secure logins etc. See Figure \ref{deployed}.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/af428f0bc6709ab7e78931e577a89626644f7e13.png}
\caption{Screenshot - deployed working Symfony project \label{deployed}}
\end{figure}

\hypertarget{quick-setup-for-new-blog-project}{%
\chapter{\texorpdfstring{Quick setup for new `blog' project
\label{appendix_new_project}}{Quick setup for new `blog' project }}\label{quick-setup-for-new-blog-project}}

\hypertarget{create-a-new-project-e.g.-blog}{%
\section{Create a new project,
e.g.~`blog'}\label{create-a-new-project-e.g.-blog}}

Use the Symfony command line installer (if working for you) to create a
new project named `blog' (or whatever you want!)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{symfony}\NormalTok{ new blog}
\end{Highlighting}
\end{Shaded}

Or use Composer:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{composer}\NormalTok{ create-project symfony/framework-standard-edition blog}
\end{Highlighting}
\end{Shaded}

Read more at:

\begin{itemize}
\tightlist
\item
  \href{http://symfony.com/doc/current/best_practices/creating-the-project.html}{Symfony
  create project reference}
\end{itemize}

\hypertarget{set-up-your-localhost-browser-shortcut-to-for-app_dev.php}{%
\section{\texorpdfstring{Set up your localhost browser shortcut to for
\texttt{app\_dev.php}}{Set up your localhost browser shortcut to for app\_dev.php}}\label{set-up-your-localhost-browser-shortcut-to-for-app_dev.php}}

Set your web browser shortcut to the \texttt{app\_dev.php}, i.e.:

\begin{verbatim}
    http://localhost:8000/app_dev.php
\end{verbatim}

\hypertarget{add-run-shortcut-to-your-composer.json-scripts}{%
\section{\texorpdfstring{Add \texttt{run} shortcut to your Composer.json
scripts}{Add run shortcut to your Composer.json scripts}}\label{add-run-shortcut-to-your-composer.json-scripts}}

Make life easier - add a ``run'' Composer.json script shortcut to run
web server from command line:

\begin{Shaded}
\begin{Highlighting}[]
    \ErrorTok{"scripts":} \FunctionTok{\{}
        \DataTypeTok{"run"}\FunctionTok{:}\StringTok{"php bin/console server:run"}\FunctionTok{,}
        \ErrorTok{...}
\end{Highlighting}
\end{Shaded}

\hypertarget{change-directories-and-run-the-app}{%
\section{Change directories and run the
app}\label{change-directories-and-run-the-app}}

Change to new project directory and run the app

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    /}\ExtensionTok{~user/}\NormalTok{$ }\BuiltInTok{cd}\NormalTok{ blog}
\NormalTok{    /}\ExtensionTok{~user/blog/}\NormalTok{$ }\ExtensionTok{composer}\NormalTok{ run}
\end{Highlighting}
\end{Shaded}

Now visit: \texttt{http://localhost:8000/app\_dev.php} in your browser
to see the welcome page

\hypertarget{remove-default-content}{%
\section{Remove default content}\label{remove-default-content}}

If you want a \textbf{completely blank} Symfony project to work with,
then delete the following:

\begin{verbatim}
    /src/AppBundle/Controller/DefaultController.php
    /app/Resources/views/default/
    /app/Resources/views/base.html.twig
\end{verbatim}

Now you have no controllers or Twig templates, and can start from a
clean slate\ldots{}

\hypertarget{steps-to-download-code-and-get-website-up-and-running}{%
\chapter{Steps to download code and get website up and
running}\label{steps-to-download-code-and-get-website-up-and-running}}

\hypertarget{first-get-the-source-code}{%
\section{First get the source code}\label{first-get-the-source-code}}

First you need to get the source code for your Symfony website onto the
computer you want to use

\hypertarget{getting-code-from-a-zip-archive}{%
\subsection{Getting code from a zip
archive}\label{getting-code-from-a-zip-archive}}

Do the following:

\begin{itemize}
\tightlist
\item
  get the archive onto the desired computer and extract the contents
\item
  if there is no \texttt{/vendor} folder then run CLI command
  \texttt{composer\ update}
\end{itemize}

\hypertarget{getting-code-from-a-git-respository}{%
\subsection{Getting code from a Git
respository}\label{getting-code-from-a-git-respository}}

Do the following:

\begin{itemize}
\tightlist
\item
  on the computer to run the server \texttt{cd} to the web directory
\item
  clone the repository with CLI command
  \texttt{git\ clone\ \textless{}REPO-URL\textgreater{}}
\item
  populate the \texttt{/vendor} directory by running CLI command
  \texttt{composer\ update}
\end{itemize}

\hypertarget{once-you-have-the-source-code-with-vendor-do-the-following}{%
\section{Once you have the source code (with vendor) do the
following}\label{once-you-have-the-source-code-with-vendor-do-the-following}}

\begin{itemize}
\tightlist
\item
  update \texttt{/app/config/parameters.yml} with your DB user
  credentials and name and host of the Database to be used
\item
  start running your MySQL database server (assuming your project uses
  MySQL)
\item
  create the database with CLI command
  \texttt{php\ bin/console\ doctrine:database:create}
\item
  create the tables with CLI command
  \texttt{php\ bin/console\ doctrine:schema:update\ -\/-force}
\end{itemize}

\hypertarget{run-the-webserver}{%
\section{Run the webserver}\label{run-the-webserver}}

Either run your own webserver (pointing web root to \texttt{/web}, or

\begin{itemize}
\tightlist
\item
  run the webserver with CLI command
  \texttt{php\ bin/console\ server:run}
\item
  visit the website at \texttt{http://localhost:8000/}
\end{itemize}

\hypertarget{about-parameters.yml-and-config.yml}{%
\chapter{\texorpdfstring{About \texttt{parameters.yml} and
\texttt{config.yml}
\label{appendix_parameters}}{About parameters.yml and config.yml }}\label{about-parameters.yml-and-config.yml}}

\hypertarget{project-and-deployment-specific-settings-in-appconfigparameters.yml}{%
\section{\texorpdfstring{Project (and deployment) specific settings in
(\texttt{/app/config/parameters.yml})}{Project (and deployment) specific settings in (/app/config/parameters.yml)}}\label{project-and-deployment-specific-settings-in-appconfigparameters.yml}}

Usually the project-specific settings are declared in this file:

\begin{verbatim}
    /app/config/parameters.yml
\end{verbatim}

These parameters are referred to in the more generic
\texttt{/app/config/config.yml}.

For example the host of a MySQL database for the project woudl be
defined by the following variable in \texttt{parameters.yml}:

\begin{verbatim}
    parameters:
        database_host: 127.0.0.1
\end{verbatim}

Note that this file (\texttt{parameters.yml}) is include in the
\texttt{.gitignore}, so it is \textbf{not} archived in your Git folder.
Usually we need different parameter settings for different deployments,
so while on your local, development machine you'll have certain
settings, you'll need different settings for your public production
`live' website. Plus you don't want to accidently publically expose your
database credentials on a open source Github page :-)

If there isn't already a \texttt{parameters.yml} file, then you can copy
the \texttt{parameters.yml.dist} file end edit it as appropriate.

\hypertarget{more-general-project-configuration-appconfigconfig.yml}{%
\section{\texorpdfstring{More general project configuration
(\texttt{/app/config/config.yml})}{More general project configuration (/app/config/config.yml)}}\label{more-general-project-configuration-appconfigconfig.yml}}

The file \texttt{/app/config/config.yml} is actually the one used by
Symfony when it looks up project settings. So the \texttt{config.yml}
file uses references to the variables declared in the
\texttt{/app/config/parameters.yml} file. For example the following
lines in \texttt{config.yml} make a reference to the variable
\texttt{database\_path} that is declared in \texttt{parameters.yml}:

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{doctrine:}
        \FunctionTok{dbal:}
            \FunctionTok{driver:}\AttributeTok{   pdo_mysql}
            \FunctionTok{host:}\AttributeTok{     }\StringTok{"%database_host%"}
\end{Highlighting}
\end{Shaded}

For many projects we need to make \textbf{no changes} to the contents of
\texttt{config.yml}. Although, since Symfony is setup with defaults for
a MySQL database, if we are using SQLIte, for example then we do need to
change the configuration settings, as well as declaring appropriate
variables in \texttt{parameters.yml}. This is discussed in Appendix
\label{appendix_db_sqlite}, describing how to set up a Symfony project
to work with SQLite.

\hypertarget{setting-up-for-mysql-database}{%
\chapter{\texorpdfstring{Setting up for MySQL Database
\label{appendix_db_mysql}}{Setting up for MySQL Database }}\label{setting-up-for-mysql-database}}

\hypertarget{declaring-the-parameters-for-the-database-parameters.yml}{%
\section{\texorpdfstring{Declaring the parameters for the database
(\texttt{parameters.yml})}{Declaring the parameters for the database (parameters.yml)}}\label{declaring-the-parameters-for-the-database-parameters.yml}}

Usually the project-specific settings are declared in this file:

\begin{verbatim}
    /app/config/parameters.yml
\end{verbatim}

These parameters are referred to in the more generic
\texttt{/app/config/config.yml} - which for MySQL projects we don't need
to touch.

The simplest way to connect your Symfony application to a MySQL database
is by setting the following variables in \texttt{parameters.yml}
(located in (\texttt{/app/config/}):

\begin{verbatim}
    # This file is auto-generated during the composer install
    parameters:
        database_host: 127.0.0.1
        database_port: null
        database_name: symfony_book
        database_user: root
        database_password: null
\end{verbatim}

Note, you can learn move about \texttt{parameters.yml} and
\texttt{config.yml} in Appendix \ref{appendix_parameters}.

You can replace \texttt{127.0.0.1} with \texttt{localhost} if you wish.
If your code cannot connect to the database check the `port' that your
MySQL server is running at (usually 3306 but may be different, for
example my Mac MAMP server uses 8889 for MySQL for some reason). So my
parameters look like this:

\begin{verbatim}
    parameters:
        database_host:     127.0.0.1
        database_port:     8889
        database_name:     symfony_book
        database_user:     symfony
        database_password: pass
\end{verbatim}

We can now use the Symfony CLI to \textbf{generate} the new database for
us. You've guessed it, we type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console doctrine:database:create}
\end{Highlighting}
\end{Shaded}

You should now see a new database in your DB manager. Figure
\ref{new_db} shows our new \texttt{symfony\_book} database created for
us.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/b65ec4ce03c8433b078a3c259fd52c3851b65c5e.png}
\caption{CLI created database in PHPMyAdmin. \label{new_db}}
\end{figure}

\textbf{NOTE} Ensure your database server is running before trying the
above, or you'll get an error like this:

\begin{verbatim}
    [PDOException] SQLSTATE[HY000] [2002] Connection refused
\end{verbatim}

now we have a database it's time to start creating tables and populating
it with records \ldots{}

\hypertarget{setting-up-for-sqlite-database}{%
\chapter{\texorpdfstring{Setting up for SQLIte Database
\label{appendix_db_sqlite}}{Setting up for SQLIte Database }}\label{setting-up-for-sqlite-database}}

\hypertarget{note-regarding-fixtures}{%
\section{NOTE regarding FIXTURES}\label{note-regarding-fixtures}}

If you are using the Doctrine Fixtures Bundle, install that first
\textbf{before} changing paramaters and config for SQLite. The fixtures
bundle assumes MySQL, and will overwrite some of the parameters during
installation.

If that does happen, you'll just have to repeat the steps in this
Appdendix to set things back to SQLite after fixtures installation.

\hypertarget{sqlite-suitable-for-most-small-medium-websites}{%
\section{SQLite suitable for most small-medium
websites}\label{sqlite-suitable-for-most-small-medium-websites}}

For small/medium projects, and learning frameworks like Symfony, it's
often simplest to just use a file-based SQLite database.

Learn more about SQLite at the project's website, and their discussion
of when SQLite is a good choices, and when a networked DBMS like MySQL
is more appropriate:

\begin{itemize}
\item
  \href{https://www.sqlite.org/}{SQLite website}
\item
  \href{http://www.sqlite.org/whentouse.html}{Appropriate Uses For
  SQLite}
\end{itemize}

\hypertarget{create-directory-where-sqlite-database-will-be-stored}{%
\section{Create directory where SQLite database will be
stored}\label{create-directory-where-sqlite-database-will-be-stored}}

Setting one up with Symfony is \textbf{very} easy. These steps assume
you are gong to use an SQLite database file named \texttt{data.sqlite}
located in directory \texttt{/var/data}.

Our first step to configuring a Symfony project to work with SQLite is
to ensure the directory exists where the SQLIte file is to be created.
The usual location for Symfony projects is \texttt{/var/data}. So create
directory \texttt{data} in \texttt{/var} if it doesn't already exist in
your project.

\hypertarget{declaring-the-parameters-for-the-database-parameters.yml-1}{%
\section{\texorpdfstring{Declaring the parameters for the database
(\texttt{parameters.yml})}{Declaring the parameters for the database (parameters.yml)}}\label{declaring-the-parameters-for-the-database-parameters.yml-1}}

In \texttt{/app/parameters.yml} replace the default
\texttt{database\_host/name/user/password} parameters with a single
parameter \texttt{database\_path} as follows:

\begin{verbatim}
```yaml
    parameters:
        database_path: ../var/data/data.sqlite
        mailer_transport: smtp
        mailer_host: 127.0.0.1
        etc.
```
\end{verbatim}

\hypertarget{setting-project-configuraetion-to-work-with-the-sqlite-database-driver-and-path-appconfigconfig.yml}{%
\section{\texorpdfstring{Setting project configuraetion to work with the
SQLite database driver and path
(\texttt{/app/config/config.yml})}{Setting project configuraetion to work with the SQLite database driver and path (/app/config/config.yml)}}\label{setting-project-configuraetion-to-work-with-the-sqlite-database-driver-and-path-appconfigconfig.yml}}

In \texttt{/app/config.yml} change the \texttt{doctrine} settings
\textbf{from} these MySQL defaults:

\begin{verbatim}
```yaml
    # Doctrine Configuration
    doctrine:
        dbal:
            driver:   pdo_mysql
            host:     "%database_host%"
            port:     "%database_port%"
            dbname:   "%database_name%"
            user:     "%database_user%"
            password: "%database_password%"
            charset:  UTF8
```
\end{verbatim}

\textbf{to} these SQLite settings:

\begin{verbatim}
```yaml
    # Doctrine Configuration
    doctrine:
        dbal:
            driver:   pdo_sqlite
            path:     "%kernel.root_dir%/%database_path%"
```
\end{verbatim}

That's it! You can now tell Symfony to create your database with CLI
command:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{php}\NormalTok{ bin/console doctrine:database:create}
\end{Highlighting}
\end{Shaded}

You'll now have an SQLite database file at
\texttt{/var/data/data.sqlite}. You can even use the PHPStorm to open
and read the DB for you. See Figures \ref{phpstorm_new_db} and
\ref{sqlite_open}.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/a2b92f094ddfad8d3bdc55663f912ff690ebe336.png}
\caption{Open SQLite view in PHPMyAdmin. \label{phpstorm_new_db}}
\end{figure}

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/6676f98b95a796f23b47ff2c6b278a9a2b0b058f.png}
\caption{Viewing \texttt{/var/data.sqlite} in PHPStorm.
\label{sqlite_open}}
\end{figure}

\hypertarget{setting-up-adminer-for-db-gui-interaction}{%
\chapter{\texorpdfstring{Setting up Adminer for DB GUI interaction
\label{appendix_adminer}}{Setting up Adminer for DB GUI interaction }}\label{setting-up-adminer-for-db-gui-interaction}}

\hypertarget{adminer---small-and-simple-db-gui}{%
\section{Adminer - small and simple DB
GUI}\label{adminer---small-and-simple-db-gui}}

Adminer is a lightweight PHP, web-based GUI for DB interaction. It
supports both MySQL and SQLite.

Figure \ref{fxtures2_in_db} shows \textbf{Adminer} listing 2 user
records created from Symofny Doctrine fixtures.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/148e4d878c1e6f823aa9852f51b5b84ce977d972.png}
\caption{Using CLI to load database fixtures. \label{fxtures2_in_db}}
\end{figure}

\hypertarget{getting-adminer}{%
\section{Getting Adminer}\label{getting-adminer}}

Download Adminer from the project website. I recommedn you get the
English only version - it's smaller\ldots{}

\begin{itemize}
\tightlist
\item
  \href{https://www.adminer.org/}{Adminer.org website}
\end{itemize}

\hypertarget{setting-up}{%
\section{Setting up}\label{setting-up}}

Extract the file to a suitable location. For example you could create an
`/amdminer' directory in your current project:

\begin{verbatim}
    .../project/adminer/adminer.php
\end{verbatim}

To keep things simple, and also to remove the login requiremnt for
SQLIte access, create file \texttt{index.php} in your Adminer directory,
containing the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php}
    \CommentTok{// index.php}

    \KeywordTok{function}\NormalTok{ adminer_object}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{class}\NormalTok{ AdminerSoftware }\KeywordTok{extends}\NormalTok{ Adminer}
\NormalTok{        \{}
            \KeywordTok{function}\NormalTok{ login}\OtherTok{(}\KeywordTok{$login}\OtherTok{,} \KeywordTok{$password}\OtherTok{)}\NormalTok{ \{}
                \KeywordTok{return} \KeywordTok{true}\OtherTok{;}
\NormalTok{            \}}
\NormalTok{        \}}
        \KeywordTok{return} \KeywordTok{new}\NormalTok{ AdminerSoftware}\OtherTok{;}
\NormalTok{    \}}

    \KeywordTok{include} \KeywordTok{__DIR__}\NormalTok{ . }\StringTok{"/adminer.php"}\OtherTok{;}
\end{Highlighting}
\end{Shaded}

\hypertarget{running-adminer}{%
\section{Running Adminer}\label{running-adminer}}

Since we have an \texttt{index.php} page, we just need to run a web
server pointing its root to our Adminer directory. Perhaps the simplest
way to do this is with the built-in PHP server, e.g.:

\begin{verbatim}
    php -S localhost:3306 -t ./adminer
\end{verbatim}

To save typing, you could add a script alias to your
\texttt{composer.json} file:

\begin{Shaded}
\begin{Highlighting}[]
    \ErrorTok{"adminer":"php} \ErrorTok{-S} \ErrorTok{localhost:3306} \ErrorTok{-t} \ErrorTok{adminer",}
\end{Highlighting}
\end{Shaded}

When run, choose the appropriate DBMS from the dropdown menu
(e.g.~\textbf{SQLite 3}), and enter the required credentials. For SQLite
all we need to enter is the path to the location of the SQLite database
file, e.g.:

\begin{verbatim}
    /Users/matt/Desktop/kill/symfony/product1/var/data/data.sqlite
\end{verbatim}

\hypertarget{avoiding-issues-of-sql-reserved-words-in-entity-and-property-names}{%
\chapter{Avoiding issues of SQL reserved words in entity and property
names}\label{avoiding-issues-of-sql-reserved-words-in-entity-and-property-names}}

Watch out for issues when your Entity name is the same as SQL keywords.

Examples to \textbf{avoid} for your Entity names include:

\begin{itemize}
\tightlist
\item
  user
\item
  group
\item
  integer
\item
  number
\item
  text
\item
  date
\end{itemize}

If you have to use certain names for Entities or their properties then
you need to `escape' them for Doctrine.

\begin{itemize}
\tightlist
\item
  \href{http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/basic-mapping.html\#quoting-reserved-words}{Doctrine
  identifier escaping}
\end{itemize}

You can `validate' your entity-db mappings with the CLI validation
command:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ bin/console doctrine:schema:validate}
\end{Highlighting}
\end{Shaded}

\hypertarget{transcript-of-interactive-entity-generation}{%
\chapter{\texorpdfstring{Transcript of interactive entity generation
\label{appendix_entity_gen}}{Transcript of interactive entity generation }}\label{transcript-of-interactive-entity-generation}}

The following is a transcript of an interactive session in the terminal
CLI to create an \texttt{Item} entity class (and related
\texttt{ItemRepository} class) with thse properties:

\begin{itemize}
\tightlist
\item
  title (string)
\item
  price (float)
\end{itemize}

You start this interactive entity generation dialogue with the following
console command:

\begin{verbatim}
    php bin/console doctrine:generate:entity
\end{verbatim}

Here is the full transcript (note all entites are automatically given an
`id' property):

\begin{verbatim}
    $ php bin/console doctrine:generate:entity

      Welcome to the Doctrine2 entity generator

    This command helps you generate Doctrine2 entities.

    First, you need to give the entity name you want to generate.
    You must use the shortcut notation like AcmeBlogBundle:Post.

    The Entity shortcut name: AppBundle:Product/Item

    Determine the format to use for the mapping information.

    Configuration format (yml, xml, php, or annotation) [annotation]:

    Instead of starting with a blank entity, you can add some fields now.
    Note that the primary key will be added automatically (named id).

    Available types: array, simple_array, json_array, object,
    boolean, integer, smallint, bigint, string, text, datetime, datetimetz,
    date, time, decimal, float, binary, blob, guid.

    New field name (press <return> to stop adding fields): description
    Field type [string]:
    Field length [255]:
    Is nullable [false]:
    Unique [false]:

    New field name (press <return> to stop adding fields): price
    Field type [string]: float
    Is nullable [false]:
    Unique [false]:

    New field name (press <return> to stop adding fields):

      Entity generation

      created ./src/AppBundle/Entity/Product/
      created ./src/AppBundle/Entity/Product/Item.php
    > Generating entity class src/AppBundle/Entity/Product/Item.php: OK!
    > Generating repository class src/AppBundle/Repository/Product/ItemRepository.php: OK!

      Everything is OK! Now get to work :).

    $
\end{verbatim}

\hypertarget{killing-php-processes-in-os-x}{%
\chapter{Killing `php' processes in OS
X}\label{killing-php-processes-in-os-x}}

Do the following:

\begin{itemize}
\tightlist
\item
  run the \textbf{Activity Monitor}
\item
  search for Process Names that are \texttt{php}
\item
  double click them and choose \texttt{Quit} to kill them
\end{itemize}

voila!

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/af45cc524517d455fb592a3f7698a908cc00aa54.png}
\caption{Mac running \texttt{php} process.}
\end{figure}

\hypertarget{docker-and-symfony-projects}{%
\chapter{Docker and Symfony
projects}\label{docker-and-symfony-projects}}

\hypertarget{setup}{%
\section{Setup}\label{setup}}

Start with your Symfony project directory

\hypertarget{dockerfile}{%
\section{Dockerfile}\label{dockerfile}}

Create a file \texttt{Dockerfile}, containing the steps to build a
Docker Image of your virtual computer system.

This \texttt{Dockerfile} assumes your Symofny project code is in
directory ``admin-prototype'':

\begin{verbatim}
    FROM php:7.1.7-apache

    COPY admin-prototype /var/www

    ## Expose apache.
    EXPOSE 80

    ## Copy this repo into place. - if /www/site is referred to in Apache conf file ...
    #ADD admin-prototype/web /var/www/site

    ## Update the default apache site with the config we created.
    ADD apache-config.conf /etc/apache2/sites-enabled/000-default.conf

    ####### fix Symfony var Cache issue ################
    # source: http://symfony.com/doc/current/setup/file_permissions.html
    CMD  HTTPDUSER=$(ps axo user,comm | grep -E '[a]pache|[h]ttpd|[_]www|[w]ww-data|[n]ginx' | grep -v root | head -1 | cut -d\  -f1)
    CMD setfacl -dR -m u:"$HTTPDUSER":rwX -m u:$(whoami):rwX /var/www/var
    CMD setfacl -R -m u:"$HTTPDUSER":rwX -m u:$(whoami):rwX /var/www/var

    ## Run symfony server
    CMD php /var/www/bin/console server:run 0.0.0.0:80&
\end{verbatim}

\hypertarget{build-your-docker-image}{%
\section{Build your Docker image}\label{build-your-docker-image}}

Build your Docker image:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{docker}\NormalTok{ build -t my-application .}
\end{Highlighting}
\end{Shaded}

\hypertarget{run-a-container-process-based-on-your-image-exposing-http-port-80}{%
\section{Run a Container process based on your image (exposing HTTP port
80)}\label{run-a-container-process-based-on-your-image-exposing-http-port-80}}

Now run your Docker \textbf{Image} as a Docker \textbf{Container}
process. The \texttt{-p\ 80:80} option is to expose port 80 in the
container as port 80 on your main computer system, so you can visit the
web site via your web browser at \texttt{http://localhost}.

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{docker}\NormalTok{ run -it -p 80:80 my-application}
\end{Highlighting}
\end{Shaded}

\hypertarget{alternative-dockerfile-for-a-basic-php-application-using-apache}{%
\section{\texorpdfstring{Alternative \texttt{Dockerfile} for a basic PHP
application, using
Apache}{Alternative Dockerfile for a basic PHP application, using Apache}}\label{alternative-dockerfile-for-a-basic-php-application-using-apache}}

This \texttt{Dockerfile} assumes the PHP project files are in directory
``game1'':

\begin{verbatim}
    FROM php:7.1.7-apache

    COPY game1 /var/www

    ## Expose apache.
    EXPOSE 80

    ## Copy this repo into place. - if /www/site is referred to in Apache conf file ...
    #ADD game1/web /var/www/site

    ## Update the default apache site with the config we created.
    ADD apache-config.conf /etc/apache2/sites-enabled/000-default.conf

    ## By default start up apache in the foreground, override with /bin/bash for interative.
    CMD /usr/sbin/apache2ctl -D FOREGROUND
\end{verbatim}

\hypertarget{create-config-file-for-apache}{%
\section{Create config file for
Apache}\label{create-config-file-for-apache}}

Create a file \texttt{apache-config.conf}, containing the following:

\begin{verbatim}
    <VirtualHost *:80>
      ServerAdmin me@mydomain.com
      DocumentRoot /var/www/web

      <Directory /var/www/web/>
          Options Indexes FollowSymLinks MultiViews
          AllowOverride All
          Order deny,allow
          Allow from all
      </Directory>

      ErrorLog ${APACHE_LOG_DIR}/error.log
      CustomLog ${APACHE_LOG_DIR}/access.log combined

    </VirtualHost>
\end{verbatim}

\hypertarget{other-docker-reference-stuff}{%
\section{Other Docker reference
stuff}\label{other-docker-reference-stuff}}

\hypertarget{docker-images}{%
\subsection{Docker Images}\label{docker-images}}

List images on disk

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{docker}\NormalTok{ images}
\end{Highlighting}
\end{Shaded}

See the details of an image:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{docker}\NormalTok{ history php:7.1-cli}
\end{Highlighting}
\end{Shaded}

(hint: \texttt{php:7.1-cli} = repository name : tag)

\hypertarget{containers}{%
\subsection{Containers}\label{containers}}

List currently running containers (processes):

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{docker}\NormalTok{ ps}
\end{Highlighting}
\end{Shaded}

Run an image as a container process:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{docker}\NormalTok{ run -it repository:tag /bin/bash}
\end{Highlighting}
\end{Shaded}

Note:

\begin{itemize}
\item
  the ``-it'' means go into an INTERACTIVE TERMINAL
\item
  the ``/bin/bash'' is the command to run - i.e.~run our BASH shell
\end{itemize}

Kill a process:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{docker}\NormalTok{ kill NAME}
\end{Highlighting}
\end{Shaded}

E.g. if container name was \texttt{wonderful\_wozniak} then you'd type:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{docker}\NormalTok{ kill wonderful_wozniak}
\end{Highlighting}
\end{Shaded}

\hypertarget{new-image-from-current-changed-state-of-a-running-container}{%
\subsection{New Image from current (changed) state of a running
Container}\label{new-image-from-current-changed-state-of-a-running-container}}

To Save an updated filesystem in Container to a new Image do the
following:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{docker}\NormalTok{ commit -m }\StringTok{"comments"}\NormalTok{ containerName}
\end{Highlighting}
\end{Shaded}

E.g. if container name was \texttt{nifty\_hodgkin} and you'd installed,
say, git and composer, then write:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{docker}\NormalTok{ commit -m }\StringTok{"installed git and composer"}\NormalTok{ nifty_hodgkin}
    \ExtensionTok{sha256}\NormalTok{:7e555cc0df651a1b68593733a35cdac341175bed294084eb73b7fb23ebdc5bbd}
\NormalTok{    $}
\end{Highlighting}
\end{Shaded}

Note that the SHA is output, the ID of the new Image.

You can then add a \textbf{tag} to the new image.

First look at the images, and note its short Image Id:

\begin{verbatim}
    $ docker images
    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
    <none>              <none>              7e555cc0df65        5 days ago          433 MB
    phpd                latest              d0ee7be93033        5 days ago          372 MB
\end{verbatim}

Now give a TAG to our image, e.g.~\texttt{php\_composer\_git}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{docker}\NormalTok{ tag 7e555cc0df65 php_composer_git}
\end{Highlighting}
\end{Shaded}

Now we see our nicely tagged Image:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{docker}\NormalTok{ images}
    \ExtensionTok{REPOSITORY}\NormalTok{          TAG                 IMAGE ID            CREATED             SIZE}
    \ExtensionTok{php_composer_git}\NormalTok{    latest              7e555cc0df65        5 days ago          433 MB}
    \ExtensionTok{phpd}\NormalTok{                latest              d0ee7be93033        5 days ago          372 MB}
\end{Highlighting}
\end{Shaded}

\hypertarget{exposing-http-ports-for-containers-running-web-application-servers}{%
\subsection{Exposing HTTP ports for Containers running web application
servers}\label{exposing-http-ports-for-containers-running-web-application-servers}}

We can use the option \texttt{-p\ PORT:PORT} to expose a port from the
Container to our main conputer system.

E.g. To expose Container port 80 as port 80 on our computer we add
\texttt{-p\ 80:80}, as part of our \texttt{docker\ run} command:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{docker}\NormalTok{ run -it -p 80:80 php_composer_git /bin/bash}
\end{Highlighting}
\end{Shaded}

We can \textbf{Inspect} the details of a running Container with the
\texttt{docker\ inspect} command:

\begin{Shaded}
\begin{Highlighting}[]
    \ExtensionTok{docker}\NormalTok{ inspect wonderful_wozniak}
\end{Highlighting}
\end{Shaded}

\hypertarget{useful-reference-sites}{%
\section{Useful reference sites}\label{useful-reference-sites}}

Some useful sites for Docker and PHP include:

\begin{itemize}
\item
  (Good
  overview){[}http://odewahn.github.io/docker-jumpstart/docker-images.html{]}
\item
  (Web Server Docker - with note about Mac
  IP){[}https://writing.pupius.co.uk/apache-and-php-on-docker-44faef716150{]}
\item
  (Nice intro for
  PHP){[}https://semaphoreci.com/community/tutorials/dockerizing-a-php-application{]}
\end{itemize}

From the offical Docker documentation pages:

\begin{itemize}
\tightlist
\item
  (Introduction){[}https://docs.docker.com/get-started/\#conclusion{]}
\item
  (Download
  Docker){[}https://www.docker.com/community-edition\#/download{]}
\end{itemize}

\hypertarget{xdebug-for-windows}{%
\chapter{\texorpdfstring{xDebug for Windows
\label{appendix_xdebug}}{xDebug for Windows }}\label{xdebug-for-windows}}

\hypertarget{steps-for-windows}{%
\section{Steps for Windows}\label{steps-for-windows}}

To setup xDebug for Windows you need:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  to download the appropriate DLL for your PHP system into
  \texttt{C:\textbackslash{}php\textbackslash{}ext} (or elsewhere if you
  installed PHP somewhere else on your system)
\item
  add/uncomment the following line at the end of your \texttt{php.ini}
  file:

\begin{verbatim}
zend_extensions = C:\php\ext\php_xdebug-2-6-0-7.1-vc14-x86_64.dll
\end{verbatim}

  NOTE: The location / name of this file will depend on your PHP
  installation (see Wizard steps below)
\end{enumerate}

\hypertarget{steps-for-linuxmac}{%
\section{Steps for Linux/Mac}\label{steps-for-linuxmac}}

You can quickly confirm xDebug status with the following CLI command:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    $ }\ExtensionTok{php}\NormalTok{ -ini}\KeywordTok{|}\FunctionTok{grep} \StringTok{'xdebug support'}
    \ExtensionTok{xdebug}\NormalTok{ support =}\OperatorTok{>}\NormalTok{ enabled}
\end{Highlighting}
\end{Shaded}

If you see `enabled' then no further work is needed. Otherwise, the
simplest way to get xDebug working is to use the wizard \ldots{}

\hypertarget{use-the-xdebug-wizard}{%
\section{Use the xDebug wizard!}\label{use-the-xdebug-wizard}}

Perhaps the easiest way to setup xDebug is to follow the steps
recommended by their `wizard' at:

\begin{itemize}
\tightlist
\item
  \href{https://xdebug.org/wizard.php}{xDebug Windows wizard:
  https://xdebug.org/wizard.php}
\end{itemize}

Figure \ref{wizard} shows a screenshot of the xDebug wizard web page
output.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/fcc322f34a1c61c65d0663ead123e26912a861ba.png}
\caption{Screenshot xDebug wizard output. \label{phpinfo}}
\end{figure}

\hypertarget{php-function-phpinfo}{%
\section{\texorpdfstring{PHP Function
\texttt{phpinfo()}}{PHP Function phpinfo()}}\label{php-function-phpinfo}}

The \texttt{phpinfo()} output is a summary (as an HTML page) of your PHP
setup. Figure \ref{phpinfo} shows a screenshot of a browser showing a
PHP info page.

\begin{figure}
\centering
\includegraphics{./tex2pdf.-65f13e14688ab55b/55c33f35426a6e5d3cead4a6aca57b1e8fe66247.png}
\caption{Screenshot phpinfo in browser. \label{phpinfo}}
\end{figure}

To use the `wizard' you need to generate, copy and then paste the text
output of \texttt{print\ phpinfo()} into the web page form.

To get the output from \texttt{phpinfo()} you can do one of these:

\begin{itemize}
\item
  at the CLI type
  \texttt{\textasciigrave{}php\ -r\ \textquotesingle{}print\ phpinfo();\textquotesingle{}\ \textgreater{}\ info.html}

  and then get the contents of file \texttt{info.html}
\item
  create a temporary directory, containing PHP file \texttt{index.php}
  that contains

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    <}\OtherTok{?}\NormalTok{php}
    \KeywordTok{print} \FunctionTok{phpinfo}\OtherTok{();}
\end{Highlighting}
\end{Shaded}

  run your webserver and visit the directory. Then copy and paste the
  contents of your browser window
\item
  in Symfony you could create a temporary controller method that outputs
  a Reponse containing the outut of \texttt{phpinfo()}, e.g.

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{/**}
\CommentTok{     * }\AnnotationTok{@Route("/info")}
\CommentTok{     */}
    \KeywordTok{public} \KeywordTok{function}\NormalTok{ infoAction}\OtherTok{()}
\NormalTok{    \{}
        \KeywordTok{return} \KeywordTok{new}\NormalTok{ Response}\OtherTok{(} \FunctionTok{phpinfo}\OtherTok{()} \OtherTok{);}
\NormalTok{    \}}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\hypertarget{more-information}{%
\section{More information}\label{more-information}}

For more information follow the steps at:

\begin{itemize}
\item
  \href{https://xdebug.org/wizard.php}{xDebug Windows wizard}
\item
  \href{https://xdebug.org/}{xDebug project home page}
\end{itemize}

\backmatter

\hypertarget{list-of-references}{%
\chapter{List of References}\label{list-of-references}}

\end{document}
